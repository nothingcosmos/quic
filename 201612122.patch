diff --git a/src/BUILD.gn b/src/BUILD.gn
index e44935e..978dc4a 100644
--- a/src/BUILD.gn
+++ b/src/BUILD.gn
@@ -15,5 +15,7 @@ group("root") {
     "//net:net_unittests",
     "//net:quic_server",
     "//net:quic_client",
+    "//net:epoll_quic_client",
+    "//net:epoll_quic_server",
   ]
-}
\ No newline at end of file
+}
diff --git a/src/net/quic/core/congestion_control/bbr_sender.cc b/src/net/quic/core/congestion_control/bbr_sender.cc
index 3145d03..7996c04 100644
--- a/src/net/quic/core/congestion_control/bbr_sender.cc
+++ b/src/net/quic/core/congestion_control/bbr_sender.cc
@@ -235,12 +235,14 @@ QuicByteCount BbrSender::GetTargetCongestionWindow(float gain) const {
 }
 
 void BbrSender::EnterStartupMode() {
+  VLOG(0) << "Mode:STARTUP";
   mode_ = STARTUP;
   pacing_gain_ = kHighGain;
   congestion_window_gain_ = kHighGain;
 }
 
 void BbrSender::EnterProbeBandwidthMode(QuicTime now) {
+  VLOG(0) << "Mode:PROBE_BW";
   mode_ = PROBE_BW;
   congestion_window_gain_ = kCongestionWindowGain;
 
@@ -283,11 +285,13 @@ bool BbrSender::UpdateBandwidthAndMinRtt(
     last_sample_is_app_limited_ = bandwidth_sample.is_app_limited;
     if (!bandwidth_sample.rtt.IsZero()) {
       sample_min_rtt = std::min(sample_min_rtt, bandwidth_sample.rtt);
+      DVLOG(1) << "update sample_min_rtt:" << sample_min_rtt;
     }
 
     if (!bandwidth_sample.is_app_limited ||
         bandwidth_sample.bandwidth > BandwidthEstimate()) {
       max_bandwidth_.Update(bandwidth_sample.bandwidth, round_trip_count_);
+      DVLOG(1) << "update max_bandwidth:" << bandwidth_sample.bandwidth << "," << round_trip_count_;
     }
   }
 
@@ -301,7 +305,7 @@ bool BbrSender::UpdateBandwidthAndMinRtt(
       !min_rtt_.IsZero() && (now > (min_rtt_timestamp_ + kMinRttExpiry));
 
   if (min_rtt_expired || sample_min_rtt < min_rtt_ || min_rtt_.IsZero()) {
-    DVLOG(2) << "Min RTT updated, old value: " << min_rtt_
+    DVLOG(1) << "Min RTT updated, old value: " << min_rtt_
              << ", new value: " << sample_min_rtt
              << ", current time: " << now.ToDebuggingValue();
 
@@ -349,6 +353,7 @@ void BbrSender::CheckIfFullBandwidthReached() {
   }
 
   QuicBandwidth target = bandwidth_at_last_round_ * kStartupGrowthTarget;
+  DVLOG(1) << "target:" << target << ",Estimate" << BandwidthEstimate();
   if (BandwidthEstimate() >= target) {
     bandwidth_at_last_round_ = BandwidthEstimate();
     rounds_without_bandwidth_gain_ = 0;
@@ -364,6 +369,7 @@ void BbrSender::CheckIfFullBandwidthReached() {
 
 void BbrSender::MaybeExitStartupOrDrain(QuicTime now) {
   if (mode_ == STARTUP && is_at_full_bandwidth_) {
+    VLOG(0) << "Mode:DRAIN";
     mode_ = DRAIN;
     pacing_gain_ = kDrainGain;
     congestion_window_gain_ = kHighGain;
@@ -378,6 +384,7 @@ void BbrSender::MaybeEnterOrExitProbeRtt(QuicTime now,
                                          bool is_round_start,
                                          bool min_rtt_expired) {
   if (min_rtt_expired && !exiting_quiescence_ && mode_ != PROBE_RTT) {
+    VLOG(0) << "Mode:PROBE_RTT";
     mode_ = PROBE_RTT;
     pacing_gain_ = 1;
     // Do not decide on the time to exit PROBE_RTT until the |bytes_in_flight|
diff --git a/src/net/quic/core/congestion_control/rtt_stats.cc b/src/net/quic/core/congestion_control/rtt_stats.cc
index da3c146..2d4d404 100644
--- a/src/net/quic/core/congestion_control/rtt_stats.cc
+++ b/src/net/quic/core/congestion_control/rtt_stats.cc
@@ -33,7 +33,7 @@ void RttStats::ExpireSmoothedMetrics() {
                            (smoothed_rtt_ - latest_rtt_).ToMicroseconds())));
   smoothed_rtt_ = std::max(smoothed_rtt_, latest_rtt_);
 }
-
+int count=0;
 // Updates the RTT based on a new sample.
 void RttStats::UpdateRtt(QuicTime::Delta send_delta,
                          QuicTime::Delta ack_delay,
@@ -73,8 +73,12 @@ void RttStats::UpdateRtt(QuicTime::Delta send_delta,
         kOneMinusBeta * mean_deviation_.ToMicroseconds() +
         kBeta * std::abs((smoothed_rtt_ - rtt_sample).ToMicroseconds())));
     smoothed_rtt_ = kOneMinusAlpha * smoothed_rtt_ + kAlpha * rtt_sample;
-    DVLOG(1) << " smoothed_rtt(us):" << smoothed_rtt_.ToMicroseconds()
+    count++;
+    if (count==200) {
+      count=0;
+    VLOG(0) << " smoothed_rtt(us):" << smoothed_rtt_.ToMicroseconds()
              << " mean_deviation(us):" << mean_deviation_.ToMicroseconds();
+    }
   }
 }
 
diff --git a/src/net/quic/core/congestion_control/send_algorithm_interface.cc b/src/net/quic/core/congestion_control/send_algorithm_interface.cc
index badfd2b..2255713 100644
--- a/src/net/quic/core/congestion_control/send_algorithm_interface.cc
+++ b/src/net/quic/core/congestion_control/send_algorithm_interface.cc
@@ -28,6 +28,7 @@ SendAlgorithmInterface* SendAlgorithmInterface::Create(
   switch (congestion_control_type) {
     case kBBR:
       if (FLAGS_quic_allow_new_bbr) {
+        VLOG(0) << "using BbrSender";
         return new BbrSender(rtt_stats, unacked_packets,
                              initial_congestion_window, max_congestion_window,
                              random);
@@ -35,13 +36,15 @@ SendAlgorithmInterface* SendAlgorithmInterface::Create(
 
     // Fall back to CUBIC if BBR is disabled.
     case kCubic:
+      VLOG(0) << "using CubicSenderPackets";
       return new TcpCubicSenderPackets(
           clock, rtt_stats, false /* don't use Reno */,
-          initial_congestion_window, max_congestion_window, stats);
+          initial_congestion_window, 200*max_congestion_window, stats);
     case kCubicBytes:
+      VLOG(0) << "using CubicSenderBytes";
       return new TcpCubicSenderBytes(
           clock, rtt_stats, false /* don't use Reno */,
-          initial_congestion_window, max_congestion_window, stats);
+          initial_congestion_window, 200*max_congestion_window, stats);
     case kReno:
       return new TcpCubicSenderPackets(clock, rtt_stats, true /* use Reno */,
                                        initial_congestion_window,
diff --git a/src/net/quic/core/congestion_control/send_algorithm_interface.h b/src/net/quic/core/congestion_control/send_algorithm_interface.h
index dacccba..6efb22f 100644
--- a/src/net/quic/core/congestion_control/send_algorithm_interface.h
+++ b/src/net/quic/core/congestion_control/send_algorithm_interface.h
@@ -25,7 +25,7 @@ namespace net {
 class CachedNetworkParameters;
 class RttStats;
 
-const QuicPacketCount kDefaultMaxCongestionWindowPackets = 2000;
+const QuicPacketCount kDefaultMaxCongestionWindowPackets = 2000 * 100;//sakacho
 
 class QUIC_EXPORT_PRIVATE SendAlgorithmInterface {
  public:
diff --git a/src/net/quic/core/quic_connection.cc b/src/net/quic/core/quic_connection.cc
index 06c05f6..7bd606a 100644
--- a/src/net/quic/core/quic_connection.cc
+++ b/src/net/quic/core/quic_connection.cc
@@ -724,6 +724,7 @@ bool QuicConnection::OnAckFrame(const QuicAckFrame& incoming_ack) {
   if (!incoming_ack.packets.Empty() &&
       GetLeastUnacked(incoming_ack.path_id) > incoming_ack.packets.Min()) {
     ++stop_waiting_count_;
+    VLOG(0) << "stop_waiting_count" << stop_waiting_count_;
   } else {
     stop_waiting_count_ = 0;
   }
@@ -2208,13 +2209,18 @@ bool QuicConnection::ScopedPacketBundler::ShouldSendAck(
     AckBundling ack_mode) const {
   switch (ack_mode) {
     case SEND_ACK:
+      VLOG(0) << "SEND_ACK:true";
       return true;
     case SEND_ACK_IF_QUEUED:
+      VLOG(0) << "IF_QUEUED:" << connection_->ack_queued();
       return connection_->ack_queued();
     case SEND_ACK_IF_PENDING:
+      VLOG(0) << "IF_PENDING:" <<
+      (connection_->ack_alarm_->IsSet() || connection_->stop_waiting_count_ > 1);
       return connection_->ack_alarm_->IsSet() ||
              connection_->stop_waiting_count_ > 1;
     case NO_ACK:
+      VLOG(0) << "NO_ACK";
       return false;
     default:
       QUIC_BUG << "Unsupported ack_mode.";
diff --git a/src/net/quic/core/quic_connection.cc.orig b/src/net/quic/core/quic_connection.cc.orig
deleted file mode 100644
index 96ecadd..0000000
--- a/src/net/quic/core/quic_connection.cc.orig
+++ /dev/null
@@ -1,2562 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "net/quic/core/quic_connection.h"
-
-#include <string.h>
-#include <sys/types.h>
-
-#include <algorithm>
-#include <iterator>
-#include <limits>
-#include <memory>
-#include <set>
-#include <utility>
-
-#include "base/format_macros.h"
-#include "base/logging.h"
-#include "base/macros.h"
-#include "base/memory/ref_counted.h"
-#include "base/metrics/histogram_macros.h"
-#include "base/stl_util.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/stringprintf.h"
-#include "net/base/address_family.h"
-#include "net/base/ip_address.h"
-#include "net/base/net_errors.h"
-#include "net/quic/core/crypto/crypto_protocol.h"
-#include "net/quic/core/crypto/quic_decrypter.h"
-#include "net/quic/core/crypto/quic_encrypter.h"
-#include "net/quic/core/proto/cached_network_parameters.pb.h"
-#include "net/quic/core/quic_bandwidth.h"
-#include "net/quic/core/quic_bug_tracker.h"
-#include "net/quic/core/quic_config.h"
-#include "net/quic/core/quic_flags.h"
-#include "net/quic/core/quic_packet_generator.h"
-#include "net/quic/core/quic_sent_packet_manager.h"
-#include "net/quic/core/quic_utils.h"
-
-using base::StringPiece;
-using base::StringPrintf;
-using std::list;
-using std::make_pair;
-using std::max;
-using std::min;
-using std::numeric_limits;
-using std::set;
-using std::string;
-using std::vector;
-
-namespace net {
-
-class QuicDecrypter;
-class QuicEncrypter;
-
-namespace {
-
-// The largest gap in packets we'll accept without closing the connection.
-// This will likely have to be tuned.
-const QuicPacketNumber kMaxPacketGap = 5000;
-
-// Maximum number of acks received before sending an ack in response.
-const QuicPacketCount kMaxPacketsReceivedBeforeAckSend = 20;
-
-// Maximum number of retransmittable packets received before sending an ack.
-const QuicPacketCount kDefaultRetransmittablePacketsBeforeAck = 2;
-// Minimum number of packets received before ack decimation is enabled.
-// This intends to avoid the beginning of slow start, when CWNDs may be
-// rapidly increasing.
-const QuicPacketCount kMinReceivedBeforeAckDecimation = 100;
-// Wait for up to 10 retransmittable packets before sending an ack.
-const QuicPacketCount kMaxRetransmittablePacketsBeforeAck = 10;
-// One quarter RTT delay when doing ack decimation.
-const float kAckDecimationDelay = 0.25;
-// One eighth RTT delay when doing ack decimation.
-const float kShortAckDecimationDelay = 0.125;
-
-bool Near(QuicPacketNumber a, QuicPacketNumber b) {
-  QuicPacketNumber delta = (a > b) ? a - b : b - a;
-  return delta <= kMaxPacketGap;
-}
-
-bool IsInitializedIPEndPoint(const IPEndPoint& address) {
-  return net::GetAddressFamily(address.address()) !=
-         net::ADDRESS_FAMILY_UNSPECIFIED;
-}
-
-// An alarm that is scheduled to send an ack if a timeout occurs.
-class AckAlarmDelegate : public QuicAlarm::Delegate {
- public:
-  explicit AckAlarmDelegate(QuicConnection* connection)
-      : connection_(connection) {}
-
-  void OnAlarm() override {
-    DCHECK(connection_->ack_frame_updated());
-    QuicConnection::ScopedPacketBundler bundler(connection_,
-                                                QuicConnection::SEND_ACK);
-  }
-
- private:
-  QuicConnection* connection_;
-
-  DISALLOW_COPY_AND_ASSIGN(AckAlarmDelegate);
-};
-
-// This alarm will be scheduled any time a data-bearing packet is sent out.
-// When the alarm goes off, the connection checks to see if the oldest packets
-// have been acked, and retransmit them if they have not.
-class RetransmissionAlarmDelegate : public QuicAlarm::Delegate {
- public:
-  explicit RetransmissionAlarmDelegate(QuicConnection* connection)
-      : connection_(connection) {}
-
-  void OnAlarm() override { connection_->OnRetransmissionTimeout(); }
-
- private:
-  QuicConnection* connection_;
-
-  DISALLOW_COPY_AND_ASSIGN(RetransmissionAlarmDelegate);
-};
-
-// An alarm that is scheduled when the SentPacketManager requires a delay
-// before sending packets and fires when the packet may be sent.
-class SendAlarmDelegate : public QuicAlarm::Delegate {
- public:
-  explicit SendAlarmDelegate(QuicConnection* connection)
-      : connection_(connection) {}
-
-  void OnAlarm() override { connection_->WriteAndBundleAcksIfNotBlocked(); }
-
- private:
-  QuicConnection* connection_;
-
-  DISALLOW_COPY_AND_ASSIGN(SendAlarmDelegate);
-};
-
-class TimeoutAlarmDelegate : public QuicAlarm::Delegate {
- public:
-  explicit TimeoutAlarmDelegate(QuicConnection* connection)
-      : connection_(connection) {}
-
-  void OnAlarm() override { connection_->CheckForTimeout(); }
-
- private:
-  QuicConnection* connection_;
-
-  DISALLOW_COPY_AND_ASSIGN(TimeoutAlarmDelegate);
-};
-
-class PingAlarmDelegate : public QuicAlarm::Delegate {
- public:
-  explicit PingAlarmDelegate(QuicConnection* connection)
-      : connection_(connection) {}
-
-  void OnAlarm() override { connection_->OnPingTimeout(); }
-
- private:
-  QuicConnection* connection_;
-
-  DISALLOW_COPY_AND_ASSIGN(PingAlarmDelegate);
-};
-
-class MtuDiscoveryAlarmDelegate : public QuicAlarm::Delegate {
- public:
-  explicit MtuDiscoveryAlarmDelegate(QuicConnection* connection)
-      : connection_(connection) {}
-
-  void OnAlarm() override { connection_->DiscoverMtu(); }
-
- private:
-  QuicConnection* connection_;
-
-  DISALLOW_COPY_AND_ASSIGN(MtuDiscoveryAlarmDelegate);
-};
-
-// Listens for acks of MTU discovery packets and raises the maximum packet size
-// of the connection if the probe succeeds.
-class MtuDiscoveryAckListener : public QuicAckListenerInterface {
- public:
-  MtuDiscoveryAckListener(QuicConnection* connection, QuicByteCount probe_size)
-      : connection_(connection), probe_size_(probe_size) {}
-
-  void OnPacketAcked(int /*acked_bytes*/,
-                     QuicTime::Delta /*ack delay time*/) override {
-    // MTU discovery packets are not retransmittable, so it must be acked.
-    MaybeIncreaseMtu();
-  }
-
-  void OnPacketRetransmitted(int /*retransmitted_bytes*/) override {}
-
- protected:
-  // MtuDiscoveryAckListener is ref counted.
-  ~MtuDiscoveryAckListener() override {}
-
- private:
-  void MaybeIncreaseMtu() {
-    if (probe_size_ > connection_->max_packet_length()) {
-      connection_->SetMaxPacketLength(probe_size_);
-    }
-  }
-
-  QuicConnection* connection_;
-  QuicByteCount probe_size_;
-
-  DISALLOW_COPY_AND_ASSIGN(MtuDiscoveryAckListener);
-};
-
-}  // namespace
-
-#define ENDPOINT \
-  (perspective_ == Perspective::IS_SERVER ? "Server: " : "Client: ")
-
-QuicConnection::QuicConnection(QuicConnectionId connection_id,
-                               IPEndPoint address,
-                               QuicConnectionHelperInterface* helper,
-                               QuicAlarmFactory* alarm_factory,
-                               QuicPacketWriter* writer,
-                               bool owns_writer,
-                               Perspective perspective,
-                               const QuicVersionVector& supported_versions)
-    : framer_(supported_versions,
-              helper->GetClock()->ApproximateNow(),
-              perspective),
-      helper_(helper),
-      alarm_factory_(alarm_factory),
-      per_packet_options_(nullptr),
-      writer_(writer),
-      owns_writer_(owns_writer),
-      encryption_level_(ENCRYPTION_NONE),
-      has_forward_secure_encrypter_(false),
-      first_required_forward_secure_packet_(0),
-      clock_(helper->GetClock()),
-      random_generator_(helper->GetRandomGenerator()),
-      connection_id_(connection_id),
-      peer_address_(address),
-      active_peer_migration_type_(NO_CHANGE),
-      highest_packet_sent_before_peer_migration_(0),
-      last_packet_decrypted_(false),
-      last_size_(0),
-      current_packet_data_(nullptr),
-      last_decrypted_packet_level_(ENCRYPTION_NONE),
-      should_last_packet_instigate_acks_(false),
-      largest_seen_packet_with_ack_(0),
-      largest_seen_packet_with_stop_waiting_(0),
-      max_undecryptable_packets_(0),
-      pending_version_negotiation_packet_(false),
-      save_crypto_packets_as_termination_packets_(false),
-      idle_timeout_connection_close_behavior_(
-          ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET),
-      close_connection_after_five_rtos_(false),
-      received_packet_manager_(&stats_),
-      ack_queued_(false),
-      num_retransmittable_packets_received_since_last_ack_sent_(0),
-      last_ack_had_missing_packets_(false),
-      num_packets_received_since_last_ack_sent_(0),
-      stop_waiting_count_(0),
-      ack_mode_(TCP_ACKING),
-      ack_decimation_delay_(kAckDecimationDelay),
-      delay_setting_retransmission_alarm_(false),
-      pending_retransmission_alarm_(false),
-      defer_send_in_response_to_packets_(false),
-      arena_(),
-      ack_alarm_(alarm_factory_->CreateAlarm(arena_.New<AckAlarmDelegate>(this),
-                                             &arena_)),
-      retransmission_alarm_(alarm_factory_->CreateAlarm(
-          arena_.New<RetransmissionAlarmDelegate>(this),
-          &arena_)),
-      send_alarm_(
-          alarm_factory_->CreateAlarm(arena_.New<SendAlarmDelegate>(this),
-                                      &arena_)),
-      resume_writes_alarm_(
-          alarm_factory_->CreateAlarm(arena_.New<SendAlarmDelegate>(this),
-                                      &arena_)),
-      timeout_alarm_(
-          alarm_factory_->CreateAlarm(arena_.New<TimeoutAlarmDelegate>(this),
-                                      &arena_)),
-      ping_alarm_(
-          alarm_factory_->CreateAlarm(arena_.New<PingAlarmDelegate>(this),
-                                      &arena_)),
-      mtu_discovery_alarm_(alarm_factory_->CreateAlarm(
-          arena_.New<MtuDiscoveryAlarmDelegate>(this),
-          &arena_)),
-      visitor_(nullptr),
-      debug_visitor_(nullptr),
-      packet_generator_(connection_id_,
-                        &framer_,
-                        random_generator_,
-                        helper->GetBufferAllocator(),
-                        this),
-      idle_network_timeout_(QuicTime::Delta::Infinite()),
-      handshake_timeout_(QuicTime::Delta::Infinite()),
-      time_of_last_received_packet_(clock_->ApproximateNow()),
-      time_of_last_sent_new_packet_(clock_->ApproximateNow()),
-      last_send_for_timeout_(clock_->ApproximateNow()),
-      packet_number_of_last_sent_packet_(0),
-      sent_packet_manager_(new QuicSentPacketManager(perspective,
-                                                     kDefaultPathId,
-                                                     clock_,
-                                                     &stats_,
-                                                     kCubic,
-                                                     kNack,
-                                                     /*delegate=*/nullptr)),
-      version_negotiation_state_(START_NEGOTIATION),
-      perspective_(perspective),
-      connected_(true),
-      can_truncate_connection_ids_(true),
-      mtu_discovery_target_(0),
-      mtu_probe_count_(0),
-      packets_between_mtu_probes_(kPacketsBetweenMtuProbesBase),
-      next_mtu_probe_at_(kPacketsBetweenMtuProbesBase),
-      largest_received_packet_size_(0),
-      goaway_sent_(false),
-      goaway_received_(false),
-      multipath_enabled_(false),
-      write_error_occured_(false) {
-  DVLOG(1) << ENDPOINT
-           << "Created connection with connection_id: " << connection_id;
-  framer_.set_visitor(this);
-  framer_.set_received_entropy_calculator(&received_packet_manager_);
-  last_stop_waiting_frame_.least_unacked = 0;
-  stats_.connection_creation_time = clock_->ApproximateNow();
-  if (FLAGS_quic_enable_multipath) {
-    sent_packet_manager_.reset(new QuicMultipathSentPacketManager(
-        sent_packet_manager_.release(), this));
-  }
-  // TODO(ianswett): Supply the NetworkChangeVisitor as a constructor argument
-  // and make it required non-null, because it's always used.
-  sent_packet_manager_->SetNetworkChangeVisitor(this);
-  // Allow the packet writer to potentially reduce the packet size to a value
-  // even smaller than kDefaultMaxPacketSize.
-  SetMaxPacketLength(perspective_ == Perspective::IS_SERVER
-                         ? kDefaultServerMaxPacketSize
-                         : kDefaultMaxPacketSize);
-  received_packet_manager_.SetVersion(version());
-}
-
-QuicConnection::~QuicConnection() {
-  if (owns_writer_) {
-    delete writer_;
-  }
-  base::STLDeleteElements(&undecryptable_packets_);
-  ClearQueuedPackets();
-}
-
-void QuicConnection::ClearQueuedPackets() {
-  for (QueuedPacketList::iterator it = queued_packets_.begin();
-       it != queued_packets_.end(); ++it) {
-    // Delete the buffer before calling ClearSerializedPacket, which sets
-    // encrypted_buffer to nullptr.
-    delete[] it->encrypted_buffer;
-    QuicUtils::ClearSerializedPacket(&(*it));
-  }
-  queued_packets_.clear();
-}
-
-void QuicConnection::SetFromConfig(const QuicConfig& config) {
-  if (config.negotiated()) {
-    // Handshake complete, set handshake timeout to Infinite.
-    SetNetworkTimeouts(QuicTime::Delta::Infinite(),
-                       config.IdleConnectionStateLifetime());
-    if (config.SilentClose()) {
-      idle_timeout_connection_close_behavior_ =
-          ConnectionCloseBehavior::SILENT_CLOSE;
-    }
-    if (FLAGS_quic_enable_multipath && config.MultipathEnabled()) {
-      multipath_enabled_ = true;
-    }
-  } else {
-    SetNetworkTimeouts(config.max_time_before_crypto_handshake(),
-                       config.max_idle_time_before_crypto_handshake());
-  }
-
-  sent_packet_manager_->SetFromConfig(config);
-  if (config.HasReceivedBytesForConnectionId() &&
-      can_truncate_connection_ids_) {
-    packet_generator_.SetConnectionIdLength(
-        config.ReceivedBytesForConnectionId());
-  }
-  max_undecryptable_packets_ = config.max_undecryptable_packets();
-
-  if (config.HasClientSentConnectionOption(kMTUH, perspective_)) {
-    SetMtuDiscoveryTarget(kMtuDiscoveryTargetPacketSizeHigh);
-  }
-  if (config.HasClientSentConnectionOption(kMTUL, perspective_)) {
-    SetMtuDiscoveryTarget(kMtuDiscoveryTargetPacketSizeLow);
-  }
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnSetFromConfig(config);
-  }
-  if (config.HasClientSentConnectionOption(kACKD, perspective_)) {
-    ack_mode_ = ACK_DECIMATION;
-  }
-  if (config.HasClientSentConnectionOption(kAKD2, perspective_)) {
-    ack_mode_ = ACK_DECIMATION_WITH_REORDERING;
-  }
-  if (config.HasClientSentConnectionOption(kAKD3, perspective_)) {
-    ack_mode_ = ACK_DECIMATION;
-    ack_decimation_delay_ = kShortAckDecimationDelay;
-  }
-  if (config.HasClientSentConnectionOption(kAKD4, perspective_)) {
-    ack_mode_ = ACK_DECIMATION_WITH_REORDERING;
-    ack_decimation_delay_ = kShortAckDecimationDelay;
-  }
-  if (config.HasClientSentConnectionOption(k5RTO, perspective_)) {
-    close_connection_after_five_rtos_ = true;
-  }
-}
-
-void QuicConnection::OnSendConnectionState(
-    const CachedNetworkParameters& cached_network_params) {
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnSendConnectionState(cached_network_params);
-  }
-}
-
-void QuicConnection::OnReceiveConnectionState(
-    const CachedNetworkParameters& cached_network_params) {
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnReceiveConnectionState(cached_network_params);
-  }
-}
-
-void QuicConnection::ResumeConnectionState(
-    const CachedNetworkParameters& cached_network_params,
-    bool max_bandwidth_resumption) {
-  sent_packet_manager_->ResumeConnectionState(cached_network_params,
-                                              max_bandwidth_resumption);
-}
-
-void QuicConnection::SetMaxPacingRate(QuicBandwidth max_pacing_rate) {
-  sent_packet_manager_->SetMaxPacingRate(max_pacing_rate);
-}
-
-void QuicConnection::SetNumOpenStreams(size_t num_streams) {
-  sent_packet_manager_->SetNumOpenStreams(num_streams);
-}
-
-bool QuicConnection::SelectMutualVersion(
-    const QuicVersionVector& available_versions) {
-  // Try to find the highest mutual version by iterating over supported
-  // versions, starting with the highest, and breaking out of the loop once we
-  // find a matching version in the provided available_versions vector.
-  const QuicVersionVector& supported_versions = framer_.supported_versions();
-  for (size_t i = 0; i < supported_versions.size(); ++i) {
-    const QuicVersion& version = supported_versions[i];
-    if (base::ContainsValue(available_versions, version)) {
-      framer_.set_version(version);
-      return true;
-    }
-  }
-
-  return false;
-}
-
-void QuicConnection::OnError(QuicFramer* framer) {
-  // Packets that we can not or have not decrypted are dropped.
-  // TODO(rch): add stats to measure this.
-  if (!connected_ || last_packet_decrypted_ == false) {
-    return;
-  }
-  CloseConnection(framer->error(), framer->detailed_error(),
-                  ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-}
-
-void QuicConnection::OnPacket() {
-  last_packet_decrypted_ = false;
-}
-
-void QuicConnection::OnPublicResetPacket(const QuicPublicResetPacket& packet) {
-  // Check that any public reset packet with a different connection ID that was
-  // routed to this QuicConnection has been redirected before control reaches
-  // here.  (Check for a bug regression.)
-  DCHECK_EQ(connection_id_, packet.public_header.connection_id);
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnPublicResetPacket(packet);
-  }
-  const string error_details = "Received public reset.";
-  DVLOG(1) << ENDPOINT << error_details;
-  TearDownLocalConnectionState(QUIC_PUBLIC_RESET, error_details,
-                               ConnectionCloseSource::FROM_PEER);
-}
-
-bool QuicConnection::OnProtocolVersionMismatch(QuicVersion received_version) {
-  DVLOG(1) << ENDPOINT << "Received packet with mismatched version "
-           << received_version;
-  // TODO(satyamshekhar): Implement no server state in this mode.
-  if (perspective_ == Perspective::IS_CLIENT) {
-    const string error_details = "Protocol version mismatch.";
-    QUIC_BUG << ENDPOINT << error_details;
-    TearDownLocalConnectionState(QUIC_INTERNAL_ERROR, error_details,
-                                 ConnectionCloseSource::FROM_SELF);
-    return false;
-  }
-  DCHECK_NE(version(), received_version);
-
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnProtocolVersionMismatch(received_version);
-  }
-
-  switch (version_negotiation_state_) {
-    case START_NEGOTIATION:
-      if (!framer_.IsSupportedVersion(received_version)) {
-        SendVersionNegotiationPacket();
-        version_negotiation_state_ = NEGOTIATION_IN_PROGRESS;
-        return false;
-      }
-      break;
-
-    case NEGOTIATION_IN_PROGRESS:
-      if (!framer_.IsSupportedVersion(received_version)) {
-        SendVersionNegotiationPacket();
-        return false;
-      }
-      break;
-
-    case NEGOTIATED_VERSION:
-      // Might be old packets that were sent by the client before the version
-      // was negotiated. Drop these.
-      return false;
-
-    default:
-      DCHECK(false);
-  }
-
-  version_negotiation_state_ = NEGOTIATED_VERSION;
-  received_packet_manager_.SetVersion(received_version);
-  visitor_->OnSuccessfulVersionNegotiation(received_version);
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnSuccessfulVersionNegotiation(received_version);
-  }
-  DVLOG(1) << ENDPOINT << "version negotiated " << received_version;
-
-  // Store the new version.
-  framer_.set_version(received_version);
-
-  // TODO(satyamshekhar): Store the packet number of this packet and close the
-  // connection if we ever received a packet with incorrect version and whose
-  // packet number is greater.
-  return true;
-}
-
-// Handles version negotiation for client connection.
-void QuicConnection::OnVersionNegotiationPacket(
-    const QuicVersionNegotiationPacket& packet) {
-  // Check that any public reset packet with a different connection ID that was
-  // routed to this QuicConnection has been redirected before control reaches
-  // here.  (Check for a bug regression.)
-  DCHECK_EQ(connection_id_, packet.connection_id);
-  if (perspective_ == Perspective::IS_SERVER) {
-    const string error_details = "Server receieved version negotiation packet.";
-    QUIC_BUG << error_details;
-    TearDownLocalConnectionState(QUIC_INTERNAL_ERROR, error_details,
-                                 ConnectionCloseSource::FROM_SELF);
-    return;
-  }
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnVersionNegotiationPacket(packet);
-  }
-
-  if (version_negotiation_state_ != START_NEGOTIATION) {
-    // Possibly a duplicate version negotiation packet.
-    return;
-  }
-
-  if (base::ContainsValue(packet.versions, version())) {
-    const string error_details =
-        "Server already supports client's version and should have accepted the "
-        "connection.";
-    DLOG(WARNING) << error_details;
-    TearDownLocalConnectionState(QUIC_INVALID_VERSION_NEGOTIATION_PACKET,
-                                 error_details,
-                                 ConnectionCloseSource::FROM_SELF);
-    return;
-  }
-
-  if (!SelectMutualVersion(packet.versions)) {
-    CloseConnection(QUIC_INVALID_VERSION, "No common version found.",
-                    ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-    return;
-  }
-
-  DVLOG(1) << ENDPOINT
-           << "Negotiated version: " << QuicVersionToString(version());
-  received_packet_manager_.SetVersion(version());
-  server_supported_versions_ = packet.versions;
-  version_negotiation_state_ = NEGOTIATION_IN_PROGRESS;
-  RetransmitUnackedPackets(ALL_UNACKED_RETRANSMISSION);
-}
-
-bool QuicConnection::OnUnauthenticatedPublicHeader(
-    const QuicPacketPublicHeader& header) {
-  if (header.connection_id == connection_id_) {
-    return true;
-  }
-
-  ++stats_.packets_dropped;
-  DVLOG(1) << ENDPOINT << "Ignoring packet from unexpected ConnectionId: "
-           << header.connection_id << " instead of " << connection_id_;
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnIncorrectConnectionId(header.connection_id);
-  }
-  // If this is a server, the dispatcher routes each packet to the
-  // QuicConnection responsible for the packet's connection ID.  So if control
-  // arrives here and this is a server, the dispatcher must be malfunctioning.
-  DCHECK_NE(Perspective::IS_SERVER, perspective_);
-  return false;
-}
-
-bool QuicConnection::OnUnauthenticatedHeader(const QuicPacketHeader& header) {
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnUnauthenticatedHeader(header);
-  }
-
-  // Check that any public reset packet with a different connection ID that was
-  // routed to this QuicConnection has been redirected before control reaches
-  // here.
-  DCHECK_EQ(connection_id_, header.public_header.connection_id);
-
-  // Multipath is not enabled, but a packet with multipath flag on is received.
-  if (!multipath_enabled_ && header.public_header.multipath_flag) {
-    const string error_details =
-        "Received a packet with multipath flag but multipath is not enabled.";
-    QUIC_BUG << error_details;
-    CloseConnection(QUIC_BAD_MULTIPATH_FLAG, error_details,
-                    ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-    return false;
-  }
-  if (!packet_generator_.IsPendingPacketEmpty()) {
-    // Incoming packets may change a queued ACK frame.
-    const string error_details =
-        "Pending frames must be serialized before incoming packets are "
-        "processed.";
-    QUIC_BUG << error_details;
-    CloseConnection(QUIC_INTERNAL_ERROR, error_details,
-                    ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-    return false;
-  }
-
-  // If this packet has already been seen, or the sender has told us that it
-  // will not be retransmitted, then stop processing the packet.
-  if (!received_packet_manager_.IsAwaitingPacket(header.packet_number)) {
-    DVLOG(1) << ENDPOINT << "Packet " << header.packet_number
-             << " no longer being waited for.  Discarding.";
-    if (debug_visitor_ != nullptr) {
-      debug_visitor_->OnDuplicatePacket(header.packet_number);
-    }
-    ++stats_.packets_dropped;
-    return false;
-  }
-
-  return true;
-}
-
-void QuicConnection::OnDecryptedPacket(EncryptionLevel level) {
-  last_decrypted_packet_level_ = level;
-  last_packet_decrypted_ = true;
-
-  // If this packet was foward-secure encrypted and the forward-secure encrypter
-  // is not being used, start using it.
-  if (encryption_level_ != ENCRYPTION_FORWARD_SECURE &&
-      has_forward_secure_encrypter_ && level == ENCRYPTION_FORWARD_SECURE) {
-    SetDefaultEncryptionLevel(ENCRYPTION_FORWARD_SECURE);
-  }
-
-  // Once the server receives a forward secure packet, the handshake is
-  // confirmed.
-  if (level == ENCRYPTION_FORWARD_SECURE &&
-      perspective_ == Perspective::IS_SERVER) {
-    sent_packet_manager_->SetHandshakeConfirmed();
-  }
-}
-
-bool QuicConnection::OnPacketHeader(const QuicPacketHeader& header) {
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnPacketHeader(header);
-  }
-
-  // Will be decremented below if we fall through to return true.
-  ++stats_.packets_dropped;
-
-  if (!ProcessValidatedPacket(header)) {
-    return false;
-  }
-
-  // Only migrate connection to a new peer address if a change is not underway.
-  PeerAddressChangeType peer_migration_type =
-      QuicUtils::DetermineAddressChangeType(peer_address_,
-                                            last_packet_source_address_);
-  // Do not migrate connection if the changed address packet is a reordered
-  // packet.
-  if (active_peer_migration_type_ == NO_CHANGE &&
-      peer_migration_type != NO_CHANGE &&
-      header.packet_number > received_packet_manager_.GetLargestObserved()) {
-    StartPeerMigration(header.path_id, peer_migration_type);
-  }
-
-  --stats_.packets_dropped;
-  DVLOG(1) << ENDPOINT << "Received packet header: " << header;
-  last_header_ = header;
-  DCHECK(connected_);
-  return true;
-}
-
-bool QuicConnection::OnStreamFrame(const QuicStreamFrame& frame) {
-  DCHECK(connected_);
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnStreamFrame(frame);
-  }
-  if (frame.stream_id != kCryptoStreamId &&
-      last_decrypted_packet_level_ == ENCRYPTION_NONE) {
-    if (MaybeConsiderAsMemoryCorruption(frame)) {
-      CloseConnection(QUIC_MAYBE_CORRUPTED_MEMORY,
-                      "Received crypto frame on non crypto stream.",
-                      ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-      return false;
-    }
-
-    QUIC_BUG << ENDPOINT
-             << "Received an unencrypted data frame: closing connection"
-             << " packet_number:" << last_header_.packet_number
-             << " stream_id:" << frame.stream_id
-             << " received_packets:" << received_packet_manager_.ack_frame();
-    CloseConnection(QUIC_UNENCRYPTED_STREAM_DATA,
-                    "Unencrypted stream data seen.",
-                    ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-    return false;
-  }
-  visitor_->OnStreamFrame(frame);
-  visitor_->PostProcessAfterData();
-  stats_.stream_bytes_received += frame.data_length;
-  should_last_packet_instigate_acks_ = true;
-  return connected_;
-}
-
-bool QuicConnection::OnAckFrame(const QuicAckFrame& incoming_ack) {
-  DCHECK(connected_);
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnAckFrame(incoming_ack);
-  }
-  DVLOG(1) << ENDPOINT << "OnAckFrame: " << incoming_ack;
-
-  if (last_header_.packet_number <= largest_seen_packet_with_ack_) {
-    DVLOG(1) << ENDPOINT << "Received an old ack frame: ignoring";
-    return true;
-  }
-
-  const char* error = ValidateAckFrame(incoming_ack);
-  if (error != nullptr) {
-    CloseConnection(QUIC_INVALID_ACK_DATA, error,
-                    ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-    return false;
-  }
-
-  if (send_alarm_->IsSet()) {
-    send_alarm_->Cancel();
-  }
-  ProcessAckFrame(incoming_ack);
-  if (incoming_ack.is_truncated) {
-    should_last_packet_instigate_acks_ = true;
-  }
-  // If the incoming ack's packets set expresses missing packets: peer is still
-  // waiting for a packet lower than a packet that we are no longer planning to
-  // send.
-  // If the incoming ack's packets set expresses received packets: peer is still
-  // acking packets which we never care about.
-  // Send an ack to raise the high water mark.
-  if (!incoming_ack.packets.Empty() &&
-      GetLeastUnacked(incoming_ack.path_id) > incoming_ack.packets.Min()) {
-    ++stop_waiting_count_;
-  } else {
-    stop_waiting_count_ = 0;
-  }
-
-  return connected_;
-}
-
-void QuicConnection::ProcessAckFrame(const QuicAckFrame& incoming_ack) {
-  largest_seen_packet_with_ack_ = last_header_.packet_number;
-  sent_packet_manager_->OnIncomingAck(incoming_ack,
-                                      time_of_last_received_packet_);
-  if (version() <= QUIC_VERSION_33) {
-    sent_entropy_manager_.ClearEntropyBefore(
-        sent_packet_manager_->GetLeastPacketAwaitedByPeer(
-            incoming_ack.path_id) -
-        1);
-  }
-  // Always reset the retransmission alarm when an ack comes in, since we now
-  // have a better estimate of the current rtt than when it was set.
-  SetRetransmissionAlarm();
-}
-
-void QuicConnection::ProcessStopWaitingFrame(
-    const QuicStopWaitingFrame& stop_waiting) {
-  largest_seen_packet_with_stop_waiting_ = last_header_.packet_number;
-  received_packet_manager_.UpdatePacketInformationSentByPeer(stop_waiting);
-}
-
-bool QuicConnection::OnStopWaitingFrame(const QuicStopWaitingFrame& frame) {
-  DCHECK(connected_);
-
-  if (last_header_.packet_number <= largest_seen_packet_with_stop_waiting_) {
-    DVLOG(1) << ENDPOINT << "Received an old stop waiting frame: ignoring";
-    return true;
-  }
-
-  const char* error = ValidateStopWaitingFrame(frame);
-  if (error != nullptr) {
-    CloseConnection(QUIC_INVALID_STOP_WAITING_DATA, error,
-                    ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-    return false;
-  }
-
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnStopWaitingFrame(frame);
-  }
-
-  last_stop_waiting_frame_ = frame;
-  return connected_;
-}
-
-bool QuicConnection::OnPaddingFrame(const QuicPaddingFrame& frame) {
-  DCHECK(connected_);
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnPaddingFrame(frame);
-  }
-  return true;
-}
-
-bool QuicConnection::OnPingFrame(const QuicPingFrame& frame) {
-  DCHECK(connected_);
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnPingFrame(frame);
-  }
-  should_last_packet_instigate_acks_ = true;
-  return true;
-}
-
-const char* QuicConnection::ValidateAckFrame(const QuicAckFrame& incoming_ack) {
-  if (incoming_ack.largest_observed > packet_generator_.packet_number()) {
-    DLOG(WARNING) << ENDPOINT << "Peer's observed unsent packet:"
-                  << incoming_ack.largest_observed << " vs "
-                  << packet_generator_.packet_number();
-    // We got an error for data we have not sent.  Error out.
-    return "Largest observed too high.";
-  }
-
-  if (incoming_ack.largest_observed <
-      sent_packet_manager_->GetLargestObserved(incoming_ack.path_id)) {
-    VLOG(1) << ENDPOINT << "Peer's largest_observed packet decreased:"
-            << incoming_ack.largest_observed << " vs "
-            << sent_packet_manager_->GetLargestObserved(incoming_ack.path_id)
-            << " packet_number:" << last_header_.packet_number
-            << " largest seen with ack:" << largest_seen_packet_with_ack_
-            << " connection_id: " << connection_id_;
-    // A new ack has a diminished largest_observed value.  Error out.
-    // If this was an old packet, we wouldn't even have checked.
-    return "Largest observed too low.";
-  }
-
-  if (version() <= QUIC_VERSION_33) {
-    if (!incoming_ack.packets.Empty() &&
-        incoming_ack.packets.Max() > incoming_ack.largest_observed) {
-      LOG(WARNING) << ENDPOINT
-                   << "Peer sent missing packet: " << incoming_ack.packets.Max()
-                   << " which is greater than largest observed: "
-                   << incoming_ack.largest_observed;
-      return "Missing packet higher than largest observed.";
-    }
-
-    if (!incoming_ack.packets.Empty() &&
-        incoming_ack.packets.Min() <
-            sent_packet_manager_->GetLeastPacketAwaitedByPeer(
-                incoming_ack.path_id)) {
-      LOG(WARNING) << ENDPOINT
-                   << "Peer sent missing packet: " << incoming_ack.packets.Min()
-                   << " which is smaller than least_packet_awaited_by_peer_: "
-                   << sent_packet_manager_->GetLeastPacketAwaitedByPeer(
-                          incoming_ack.path_id);
-      return "Missing packet smaller than least awaited.";
-    }
-    if (!sent_entropy_manager_.IsValidEntropy(incoming_ack.largest_observed,
-                                              incoming_ack.packets,
-                                              incoming_ack.entropy_hash)) {
-      DLOG(WARNING) << ENDPOINT << "Peer sent invalid entropy."
-                    << " largest_observed:" << incoming_ack.largest_observed
-                    << " last_received:" << last_header_.packet_number;
-      return "Invalid entropy.";
-    }
-  } else {
-    if (!incoming_ack.packets.Empty() &&
-        incoming_ack.packets.Max() != incoming_ack.largest_observed) {
-      QUIC_BUG << ENDPOINT
-               << "Peer last received packet: " << incoming_ack.packets.Max()
-               << " which is not equal to largest observed: "
-               << incoming_ack.largest_observed;
-      return "Last received packet not equal to largest observed.";
-    }
-  }
-
-  return nullptr;
-}
-
-const char* QuicConnection::ValidateStopWaitingFrame(
-    const QuicStopWaitingFrame& stop_waiting) {
-  if (stop_waiting.least_unacked <
-      received_packet_manager_.peer_least_packet_awaiting_ack()) {
-    DLOG(ERROR) << ENDPOINT << "Peer's sent low least_unacked: "
-                << stop_waiting.least_unacked << " vs "
-                << received_packet_manager_.peer_least_packet_awaiting_ack();
-    // We never process old ack frames, so this number should only increase.
-    return "Least unacked too small.";
-  }
-
-  if (stop_waiting.least_unacked > last_header_.packet_number) {
-    DLOG(ERROR) << ENDPOINT
-                << "Peer sent least_unacked:" << stop_waiting.least_unacked
-                << " greater than the enclosing packet number:"
-                << last_header_.packet_number;
-    return "Least unacked too large.";
-  }
-
-  return nullptr;
-}
-
-bool QuicConnection::OnRstStreamFrame(const QuicRstStreamFrame& frame) {
-  DCHECK(connected_);
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnRstStreamFrame(frame);
-  }
-  DVLOG(1) << ENDPOINT
-           << "RST_STREAM_FRAME received for stream: " << frame.stream_id
-           << " with error: "
-           << QuicUtils::StreamErrorToString(frame.error_code);
-  visitor_->OnRstStream(frame);
-  visitor_->PostProcessAfterData();
-  should_last_packet_instigate_acks_ = true;
-  return connected_;
-}
-
-bool QuicConnection::OnConnectionCloseFrame(
-    const QuicConnectionCloseFrame& frame) {
-  DCHECK(connected_);
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnConnectionCloseFrame(frame);
-  }
-  DVLOG(1) << ENDPOINT
-           << "Received ConnectionClose for connection: " << connection_id()
-           << ", with error: " << QuicUtils::ErrorToString(frame.error_code)
-           << " (" << frame.error_details << ")";
-  TearDownLocalConnectionState(frame.error_code, frame.error_details,
-                               ConnectionCloseSource::FROM_PEER);
-  return connected_;
-}
-
-bool QuicConnection::OnGoAwayFrame(const QuicGoAwayFrame& frame) {
-  DCHECK(connected_);
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnGoAwayFrame(frame);
-  }
-  DVLOG(1) << ENDPOINT << "GOAWAY_FRAME received with last good stream: "
-           << frame.last_good_stream_id
-           << " and error: " << QuicUtils::ErrorToString(frame.error_code)
-           << " and reason: " << frame.reason_phrase;
-
-  goaway_received_ = true;
-  visitor_->OnGoAway(frame);
-  visitor_->PostProcessAfterData();
-  should_last_packet_instigate_acks_ = true;
-  return connected_;
-}
-
-bool QuicConnection::OnWindowUpdateFrame(const QuicWindowUpdateFrame& frame) {
-  DCHECK(connected_);
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnWindowUpdateFrame(frame);
-  }
-  DVLOG(1) << ENDPOINT
-           << "WINDOW_UPDATE_FRAME received for stream: " << frame.stream_id
-           << " with byte offset: " << frame.byte_offset;
-  visitor_->OnWindowUpdateFrame(frame);
-  visitor_->PostProcessAfterData();
-  should_last_packet_instigate_acks_ = true;
-  return connected_;
-}
-
-bool QuicConnection::OnBlockedFrame(const QuicBlockedFrame& frame) {
-  DCHECK(connected_);
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnBlockedFrame(frame);
-  }
-  DVLOG(1) << ENDPOINT
-           << "BLOCKED_FRAME received for stream: " << frame.stream_id;
-  visitor_->OnBlockedFrame(frame);
-  visitor_->PostProcessAfterData();
-  should_last_packet_instigate_acks_ = true;
-  return connected_;
-}
-
-bool QuicConnection::OnPathCloseFrame(const QuicPathCloseFrame& frame) {
-  DCHECK(connected_);
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnPathCloseFrame(frame);
-  }
-  DVLOG(1) << ENDPOINT
-           << "PATH_CLOSE_FRAME received for path: " << frame.path_id;
-  OnPathClosed(frame.path_id);
-  return connected_;
-}
-
-void QuicConnection::OnPacketComplete() {
-  // Don't do anything if this packet closed the connection.
-  if (!connected_) {
-    ClearLastFrames();
-    return;
-  }
-
-  DVLOG(1) << ENDPOINT << "Got packet " << last_header_.packet_number << " for "
-           << last_header_.public_header.connection_id;
-
-  // An ack will be sent if a missing retransmittable packet was received;
-  const bool was_missing =
-      should_last_packet_instigate_acks_ &&
-      received_packet_manager_.IsMissing(last_header_.packet_number);
-
-  // Record received to populate ack info correctly before processing stream
-  // frames, since the processing may result in a response packet with a bundled
-  // ack.
-  received_packet_manager_.RecordPacketReceived(last_size_, last_header_,
-                                                time_of_last_received_packet_);
-
-  // Process stop waiting frames here, instead of inline, because the packet
-  // needs to be considered 'received' before the entropy can be updated.
-  if (last_stop_waiting_frame_.least_unacked > 0) {
-    ProcessStopWaitingFrame(last_stop_waiting_frame_);
-    if (!connected_) {
-      return;
-    }
-  }
-
-  MaybeQueueAck(was_missing);
-
-  ClearLastFrames();
-  MaybeCloseIfTooManyOutstandingPackets();
-}
-
-void QuicConnection::MaybeQueueAck(bool was_missing) {
-  ++num_packets_received_since_last_ack_sent_;
-  // Always send an ack every 20 packets in order to allow the peer to discard
-  // information from the SentPacketManager and provide an RTT measurement.
-  if (num_packets_received_since_last_ack_sent_ >=
-      kMaxPacketsReceivedBeforeAckSend) {
-    ack_queued_ = true;
-  }
-
-  // Determine whether the newly received packet was missing before recording
-  // the received packet.
-  // Ack decimation with reordering relies on the timer to send an ack, but if
-  // missing packets we reported in the previous ack, send an ack immediately.
-  if (was_missing && (ack_mode_ != ACK_DECIMATION_WITH_REORDERING ||
-                      last_ack_had_missing_packets_)) {
-    ack_queued_ = true;
-  }
-
-  if (should_last_packet_instigate_acks_ && !ack_queued_) {
-    ++num_retransmittable_packets_received_since_last_ack_sent_;
-    if (ack_mode_ != TCP_ACKING &&
-        last_header_.packet_number > kMinReceivedBeforeAckDecimation) {
-      // Ack up to 10 packets at once.
-      if (num_retransmittable_packets_received_since_last_ack_sent_ >=
-          kMaxRetransmittablePacketsBeforeAck) {
-        ack_queued_ = true;
-      } else if (!ack_alarm_->IsSet()) {
-        // Wait the minimum of a quarter min_rtt and the delayed ack time.
-        QuicTime::Delta ack_delay = std::min(
-            DelayedAckTime(), sent_packet_manager_->GetRttStats()->min_rtt() *
-                                  ack_decimation_delay_);
-        ack_alarm_->Set(clock_->ApproximateNow() + ack_delay);
-      }
-    } else {
-      // Ack with a timer or every 2 packets by default.
-      if (num_retransmittable_packets_received_since_last_ack_sent_ >=
-          kDefaultRetransmittablePacketsBeforeAck) {
-        ack_queued_ = true;
-      } else if (!ack_alarm_->IsSet()) {
-        ack_alarm_->Set(clock_->ApproximateNow() + DelayedAckTime());
-      }
-    }
-
-    // If there are new missing packets to report, send an ack immediately.
-    if (received_packet_manager_.HasNewMissingPackets()) {
-      if (ack_mode_ == ACK_DECIMATION_WITH_REORDERING) {
-        // Wait the minimum of an eighth min_rtt and the existing ack time.
-        QuicTime ack_time =
-            clock_->ApproximateNow() +
-            0.125 * sent_packet_manager_->GetRttStats()->min_rtt();
-        if (!ack_alarm_->IsSet() || ack_alarm_->deadline() > ack_time) {
-          ack_alarm_->Update(ack_time, QuicTime::Delta::Zero());
-        }
-      } else {
-        ack_queued_ = true;
-      }
-    }
-  }
-
-  if (ack_queued_) {
-    ack_alarm_->Cancel();
-  }
-}
-
-void QuicConnection::ClearLastFrames() {
-  should_last_packet_instigate_acks_ = false;
-  last_stop_waiting_frame_.least_unacked = 0;
-}
-
-void QuicConnection::MaybeCloseIfTooManyOutstandingPackets() {
-  if (version() > QUIC_VERSION_33) {
-    return;
-  }
-  // This occurs if we don't discard old packets we've sent fast enough.
-  // It's possible largest observed is less than least unacked.
-  if (sent_packet_manager_->GetLargestObserved(last_header_.path_id) >
-      (sent_packet_manager_->GetLeastUnacked(last_header_.path_id) +
-       kMaxTrackedPackets)) {
-    CloseConnection(
-        QUIC_TOO_MANY_OUTSTANDING_SENT_PACKETS,
-        StringPrintf("More than %" PRIu64 " outstanding.", kMaxTrackedPackets),
-        ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-  }
-  // This occurs if there are received packet gaps and the peer does not raise
-  // the least unacked fast enough.
-  if (received_packet_manager_.NumTrackedPackets() > kMaxTrackedPackets) {
-    CloseConnection(
-        QUIC_TOO_MANY_OUTSTANDING_RECEIVED_PACKETS,
-        StringPrintf("More than %" PRIu64 " outstanding.", kMaxTrackedPackets),
-        ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-  }
-}
-
-const QuicFrame QuicConnection::GetUpdatedAckFrame() {
-  return received_packet_manager_.GetUpdatedAckFrame(clock_->ApproximateNow());
-}
-
-void QuicConnection::PopulateStopWaitingFrame(
-    QuicStopWaitingFrame* stop_waiting) {
-  stop_waiting->least_unacked = GetLeastUnacked(stop_waiting->path_id);
-  if (version() <= QUIC_VERSION_33) {
-    stop_waiting->entropy_hash = sent_entropy_manager_.GetCumulativeEntropy(
-        stop_waiting->least_unacked - 1);
-  }
-}
-
-QuicPacketNumber QuicConnection::GetLeastUnacked(QuicPathId path_id) const {
-  return sent_packet_manager_->GetLeastUnacked(path_id);
-}
-
-void QuicConnection::MaybeSendInResponseToPacket() {
-  if (!connected_) {
-    return;
-  }
-  // Now that we have received an ack, we might be able to send packets which
-  // are queued locally, or drain streams which are blocked.
-  if (defer_send_in_response_to_packets_) {
-    send_alarm_->Update(clock_->ApproximateNow(), QuicTime::Delta::Zero());
-  } else {
-    WriteAndBundleAcksIfNotBlocked();
-  }
-}
-
-void QuicConnection::SendVersionNegotiationPacket() {
-  pending_version_negotiation_packet_ = true;
-  if (writer_->IsWriteBlocked()) {
-    visitor_->OnWriteBlocked();
-    return;
-  }
-  DVLOG(1) << ENDPOINT << "Sending version negotiation packet: {"
-           << QuicVersionVectorToString(framer_.supported_versions()) << "}";
-  std::unique_ptr<QuicEncryptedPacket> version_packet(
-      packet_generator_.SerializeVersionNegotiationPacket(
-          framer_.supported_versions()));
-  WriteResult result = writer_->WritePacket(
-      version_packet->data(), version_packet->length(),
-      self_address().address(), peer_address(), per_packet_options_);
-
-  if (result.status == WRITE_STATUS_ERROR) {
-    OnWriteError(result.error_code);
-    return;
-  }
-  if (result.status == WRITE_STATUS_BLOCKED) {
-    visitor_->OnWriteBlocked();
-    if (writer_->IsWriteBlockedDataBuffered()) {
-      pending_version_negotiation_packet_ = false;
-    }
-    return;
-  }
-
-  pending_version_negotiation_packet_ = false;
-}
-
-QuicConsumedData QuicConnection::SendStreamData(
-    QuicStreamId id,
-    QuicIOVector iov,
-    QuicStreamOffset offset,
-    bool fin,
-    QuicAckListenerInterface* listener) {
-  if (!fin && iov.total_length == 0) {
-    QUIC_BUG << "Attempt to send empty stream frame";
-    return QuicConsumedData(0, false);
-  }
-
-  // Opportunistically bundle an ack with every outgoing packet.
-  // Particularly, we want to bundle with handshake packets since we don't know
-  // which decrypter will be used on an ack packet following a handshake
-  // packet (a handshake packet from client to server could result in a REJ or a
-  // SHLO from the server, leading to two different decrypters at the server.)
-  ScopedRetransmissionScheduler alarm_delayer(this);
-  ScopedPacketBundler ack_bundler(this, SEND_ACK_IF_PENDING);
-  // The optimized path may be used for data only packets which fit into a
-  // standard buffer and don't need padding.
-  if (id != kCryptoStreamId && !packet_generator_.HasQueuedFrames() &&
-      iov.total_length > kMaxPacketSize) {
-    // Use the fast path to send full data packets.
-    return packet_generator_.ConsumeDataFastPath(id, iov, offset, fin,
-                                                 listener);
-  }
-  return packet_generator_.ConsumeData(id, iov, offset, fin, listener);
-}
-
-void QuicConnection::SendRstStream(QuicStreamId id,
-                                   QuicRstStreamErrorCode error,
-                                   QuicStreamOffset bytes_written) {
-  // Opportunistically bundle an ack with this outgoing packet.
-  ScopedPacketBundler ack_bundler(this, SEND_ACK_IF_PENDING);
-  packet_generator_.AddControlFrame(QuicFrame(new QuicRstStreamFrame(
-      id, AdjustErrorForVersion(error, version()), bytes_written)));
-
-  if (error == QUIC_STREAM_NO_ERROR) {
-    // All data for streams which are reset with QUIC_STREAM_NO_ERROR must
-    // be received by the peer.
-    return;
-  }
-
-  sent_packet_manager_->CancelRetransmissionsForStream(id);
-  // Remove all queued packets which only contain data for the reset stream.
-  QueuedPacketList::iterator packet_iterator = queued_packets_.begin();
-  while (packet_iterator != queued_packets_.end()) {
-    QuicFrames* retransmittable_frames =
-        &packet_iterator->retransmittable_frames;
-    if (retransmittable_frames->empty()) {
-      ++packet_iterator;
-      continue;
-    }
-    QuicUtils::RemoveFramesForStream(retransmittable_frames, id);
-    if (!retransmittable_frames->empty()) {
-      ++packet_iterator;
-      continue;
-    }
-    delete[] packet_iterator->encrypted_buffer;
-    QuicUtils::ClearSerializedPacket(&(*packet_iterator));
-    packet_iterator = queued_packets_.erase(packet_iterator);
-  }
-}
-
-void QuicConnection::SendWindowUpdate(QuicStreamId id,
-                                      QuicStreamOffset byte_offset) {
-  // Opportunistically bundle an ack with this outgoing packet.
-  ScopedPacketBundler ack_bundler(this, SEND_ACK_IF_PENDING);
-  packet_generator_.AddControlFrame(
-      QuicFrame(new QuicWindowUpdateFrame(id, byte_offset)));
-}
-
-void QuicConnection::SendBlocked(QuicStreamId id) {
-  // Opportunistically bundle an ack with this outgoing packet.
-  ScopedPacketBundler ack_bundler(this, SEND_ACK_IF_PENDING);
-  packet_generator_.AddControlFrame(QuicFrame(new QuicBlockedFrame(id)));
-}
-
-void QuicConnection::SendPathClose(QuicPathId path_id) {
-  // Opportunistically bundle an ack with this outgoing packet.
-  ScopedPacketBundler ack_bundler(this, SEND_ACK_IF_PENDING);
-  packet_generator_.AddControlFrame(QuicFrame(new QuicPathCloseFrame(path_id)));
-  OnPathClosed(path_id);
-}
-
-const QuicConnectionStats& QuicConnection::GetStats() {
-  const RttStats* rtt_stats = sent_packet_manager_->GetRttStats();
-
-  // Update rtt and estimated bandwidth.
-  QuicTime::Delta min_rtt = rtt_stats->min_rtt();
-  if (min_rtt.IsZero()) {
-    // If min RTT has not been set, use initial RTT instead.
-    min_rtt = QuicTime::Delta::FromMicroseconds(rtt_stats->initial_rtt_us());
-  }
-  stats_.min_rtt_us = min_rtt.ToMicroseconds();
-
-  QuicTime::Delta srtt = rtt_stats->smoothed_rtt();
-  if (srtt.IsZero()) {
-    // If SRTT has not been set, use initial RTT instead.
-    srtt = QuicTime::Delta::FromMicroseconds(rtt_stats->initial_rtt_us());
-  }
-  stats_.srtt_us = srtt.ToMicroseconds();
-
-  stats_.estimated_bandwidth = sent_packet_manager_->BandwidthEstimate();
-  stats_.max_packet_size = packet_generator_.GetCurrentMaxPacketLength();
-  stats_.max_received_packet_size = largest_received_packet_size_;
-  return stats_;
-}
-
-void QuicConnection::ProcessUdpPacket(const IPEndPoint& self_address,
-                                      const IPEndPoint& peer_address,
-                                      const QuicReceivedPacket& packet) {
-  if (!connected_) {
-    return;
-  }
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnPacketReceived(self_address, peer_address, packet);
-  }
-  last_size_ = packet.length();
-  current_packet_data_ = packet.data();
-
-  last_packet_destination_address_ = self_address;
-  last_packet_source_address_ = peer_address;
-  if (!IsInitializedIPEndPoint(self_address_)) {
-    self_address_ = last_packet_destination_address_;
-  }
-  if (!IsInitializedIPEndPoint(peer_address_)) {
-    peer_address_ = last_packet_source_address_;
-  }
-
-  stats_.bytes_received += packet.length();
-  ++stats_.packets_received;
-
-  time_of_last_received_packet_ = packet.receipt_time();
-  DVLOG(1) << ENDPOINT << "time of last received packet: "
-           << time_of_last_received_packet_.ToDebuggingValue();
-
-  ScopedRetransmissionScheduler alarm_delayer(this);
-  if (!framer_.ProcessPacket(packet)) {
-    // If we are unable to decrypt this packet, it might be
-    // because the CHLO or SHLO packet was lost.
-    if (framer_.error() == QUIC_DECRYPTION_FAILURE) {
-      if (encryption_level_ != ENCRYPTION_FORWARD_SECURE &&
-          undecryptable_packets_.size() < max_undecryptable_packets_) {
-        QueueUndecryptablePacket(packet);
-      } else if (debug_visitor_ != nullptr) {
-        debug_visitor_->OnUndecryptablePacket();
-      }
-    }
-    DVLOG(1) << ENDPOINT << "Unable to process packet.  Last packet processed: "
-             << last_header_.packet_number;
-    current_packet_data_ = nullptr;
-    return;
-  }
-
-  ++stats_.packets_processed;
-  if (active_peer_migration_type_ != NO_CHANGE &&
-      sent_packet_manager_->GetLargestObserved(last_header_.path_id) >
-          highest_packet_sent_before_peer_migration_) {
-    OnPeerMigrationValidated(last_header_.path_id);
-  }
-  MaybeProcessUndecryptablePackets();
-  MaybeSendInResponseToPacket();
-  SetPingAlarm();
-  current_packet_data_ = nullptr;
-}
-
-void QuicConnection::OnCanWrite() {
-  DCHECK(!writer_->IsWriteBlocked());
-
-  WriteQueuedPackets();
-  WritePendingRetransmissions();
-
-  // Sending queued packets may have caused the socket to become write blocked,
-  // or the congestion manager to prohibit sending.  If we've sent everything
-  // we had queued and we're still not blocked, let the visitor know it can
-  // write more.
-  if (!CanWrite(HAS_RETRANSMITTABLE_DATA)) {
-    return;
-  }
-
-  {
-    ScopedPacketBundler bundler(this, SEND_ACK_IF_QUEUED);
-    visitor_->OnCanWrite();
-    visitor_->PostProcessAfterData();
-  }
-
-  // After the visitor writes, it may have caused the socket to become write
-  // blocked or the congestion manager to prohibit sending, so check again.
-  if (visitor_->WillingAndAbleToWrite() && !resume_writes_alarm_->IsSet() &&
-      CanWrite(HAS_RETRANSMITTABLE_DATA)) {
-    // We're not write blocked, but some stream didn't write out all of its
-    // bytes. Register for 'immediate' resumption so we'll keep writing after
-    // other connections and events have had a chance to use the thread.
-    resume_writes_alarm_->Set(clock_->ApproximateNow());
-  }
-}
-
-void QuicConnection::WriteIfNotBlocked() {
-  if (!writer_->IsWriteBlocked()) {
-    OnCanWrite();
-  }
-}
-
-void QuicConnection::WriteAndBundleAcksIfNotBlocked() {
-  if (!writer_->IsWriteBlocked()) {
-    ScopedPacketBundler bundler(this, SEND_ACK_IF_QUEUED);
-    OnCanWrite();
-  }
-}
-
-bool QuicConnection::ProcessValidatedPacket(const QuicPacketHeader& header) {
-  if (header.fec_flag) {
-    // Drop any FEC packet.
-    return false;
-  }
-
-  if (perspective_ == Perspective::IS_SERVER &&
-      IsInitializedIPEndPoint(self_address_) &&
-      IsInitializedIPEndPoint(last_packet_destination_address_) &&
-      (!(self_address_ == last_packet_destination_address_))) {
-    CloseConnection(QUIC_ERROR_MIGRATING_ADDRESS,
-                    "Self address migration is not supported at the server.",
-                    ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-    return false;
-  }
-
-  if (!Near(header.packet_number, last_header_.packet_number)) {
-    DVLOG(1) << ENDPOINT << "Packet " << header.packet_number
-             << " out of bounds.  Discarding";
-    CloseConnection(QUIC_INVALID_PACKET_HEADER, "packet number out of bounds.",
-                    ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-    return false;
-  }
-
-  if (version_negotiation_state_ != NEGOTIATED_VERSION) {
-    if (perspective_ == Perspective::IS_SERVER) {
-      if (!header.public_header.version_flag) {
-        // Packets should have the version flag till version negotiation is
-        // done.
-        string error_details =
-            StringPrintf("%s Packet %" PRIu64
-                         " without version flag before version negotiated.",
-                         ENDPOINT, header.packet_number);
-        DLOG(WARNING) << error_details;
-        CloseConnection(QUIC_INVALID_VERSION, error_details,
-                        ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-        return false;
-      } else {
-        DCHECK_EQ(1u, header.public_header.versions.size());
-        DCHECK_EQ(header.public_header.versions[0], version());
-        version_negotiation_state_ = NEGOTIATED_VERSION;
-        received_packet_manager_.SetVersion(version());
-        visitor_->OnSuccessfulVersionNegotiation(version());
-        if (debug_visitor_ != nullptr) {
-          debug_visitor_->OnSuccessfulVersionNegotiation(version());
-        }
-      }
-    } else {
-      DCHECK(!header.public_header.version_flag);
-      // If the client gets a packet without the version flag from the server
-      // it should stop sending version since the version negotiation is done.
-      packet_generator_.StopSendingVersion();
-      version_negotiation_state_ = NEGOTIATED_VERSION;
-      received_packet_manager_.SetVersion(version());
-      visitor_->OnSuccessfulVersionNegotiation(version());
-      if (debug_visitor_ != nullptr) {
-        debug_visitor_->OnSuccessfulVersionNegotiation(version());
-      }
-    }
-  }
-
-  DCHECK_EQ(NEGOTIATED_VERSION, version_negotiation_state_);
-
-  if (last_size_ > largest_received_packet_size_) {
-    largest_received_packet_size_ = last_size_;
-  }
-
-  if (perspective_ == Perspective::IS_SERVER &&
-      encryption_level_ == ENCRYPTION_NONE &&
-      last_size_ > packet_generator_.GetCurrentMaxPacketLength()) {
-    SetMaxPacketLength(last_size_);
-  }
-  return true;
-}
-
-void QuicConnection::WriteQueuedPackets() {
-  DCHECK(!writer_->IsWriteBlocked());
-
-  if (pending_version_negotiation_packet_) {
-    SendVersionNegotiationPacket();
-  }
-
-  QueuedPacketList::iterator packet_iterator = queued_packets_.begin();
-  while (packet_iterator != queued_packets_.end() &&
-         WritePacket(&(*packet_iterator))) {
-    delete[] packet_iterator->encrypted_buffer;
-    QuicUtils::ClearSerializedPacket(&(*packet_iterator));
-    packet_iterator = queued_packets_.erase(packet_iterator);
-  }
-}
-
-void QuicConnection::WritePendingRetransmissions() {
-  // Keep writing as long as there's a pending retransmission which can be
-  // written.
-  while (sent_packet_manager_->HasPendingRetransmissions()) {
-    const PendingRetransmission pending =
-        sent_packet_manager_->NextPendingRetransmission();
-    if (!CanWrite(HAS_RETRANSMITTABLE_DATA)) {
-      break;
-    }
-
-    // Re-packetize the frames with a new packet number for retransmission.
-    // Retransmitted packets use the same packet number length as the
-    // original.
-    // Flush the packet generator before making a new packet.
-    // TODO(ianswett): Implement ReserializeAllFrames as a separate path that
-    // does not require the creator to be flushed.
-    packet_generator_.FlushAllQueuedFrames();
-    char buffer[kMaxPacketSize];
-    packet_generator_.ReserializeAllFrames(pending, buffer, kMaxPacketSize);
-  }
-}
-
-void QuicConnection::RetransmitUnackedPackets(
-    TransmissionType retransmission_type) {
-  sent_packet_manager_->RetransmitUnackedPackets(retransmission_type);
-
-  WriteIfNotBlocked();
-}
-
-void QuicConnection::NeuterUnencryptedPackets() {
-  sent_packet_manager_->NeuterUnencryptedPackets();
-  // This may have changed the retransmission timer, so re-arm it.
-  SetRetransmissionAlarm();
-}
-
-bool QuicConnection::ShouldGeneratePacket(
-    HasRetransmittableData retransmittable,
-    IsHandshake handshake) {
-  // We should serialize handshake packets immediately to ensure that they
-  // end up sent at the right encryption level.
-  if (handshake == IS_HANDSHAKE) {
-    return true;
-  }
-
-  return CanWrite(retransmittable);
-}
-
-bool QuicConnection::CanWrite(HasRetransmittableData retransmittable) {
-  if (!connected_) {
-    return false;
-  }
-
-  if (writer_->IsWriteBlocked()) {
-    visitor_->OnWriteBlocked();
-    return false;
-  }
-
-  // Allow acks to be sent immediately.
-  if (retransmittable == NO_RETRANSMITTABLE_DATA) {
-    return true;
-  }
-  // If the send alarm is set, wait for it to fire.
-  if (send_alarm_->IsSet()) {
-    return false;
-  }
-
-  // TODO(fayang): If delay is not infinite, the next packet will be created and
-  // sent on path_id.
-  QuicPathId path_id = kInvalidPathId;
-  QuicTime now = clock_->Now();
-  QuicTime::Delta delay = sent_packet_manager_->TimeUntilSend(now, &path_id);
-  if (delay.IsInfinite()) {
-    DCHECK_EQ(kInvalidPathId, path_id);
-    send_alarm_->Cancel();
-    return false;
-  }
-
-  DCHECK_NE(kInvalidPathId, path_id);
-  // If the scheduler requires a delay, then we can not send this packet now.
-  if (!delay.IsZero()) {
-    send_alarm_->Update(now + delay, QuicTime::Delta::FromMilliseconds(1));
-    DVLOG(1) << ENDPOINT << "Delaying sending " << delay.ToMilliseconds()
-             << "ms";
-    return false;
-  }
-  return true;
-}
-
-bool QuicConnection::WritePacket(SerializedPacket* packet) {
-  if (packet->packet_number <
-      sent_packet_manager_->GetLargestSentPacket(packet->path_id)) {
-    QUIC_BUG << "Attempt to write packet:" << packet->packet_number << " after:"
-             << sent_packet_manager_->GetLargestSentPacket(packet->path_id);
-    CloseConnection(QUIC_INTERNAL_ERROR, "Packet written out of order.",
-                    ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-    return true;
-  }
-  if (ShouldDiscardPacket(*packet)) {
-    ++stats_.packets_discarded;
-    return true;
-  }
-  // Termination packets are encrypted and saved, so don't exit early.
-  const bool is_termination_packet = IsTerminationPacket(*packet);
-  if (writer_->IsWriteBlocked() && !is_termination_packet) {
-    return false;
-  }
-
-  QuicPacketNumber packet_number = packet->packet_number;
-  DCHECK_LE(packet_number_of_last_sent_packet_, packet_number);
-  packet_number_of_last_sent_packet_ = packet_number;
-
-  QuicPacketLength encrypted_length = packet->encrypted_length;
-  // Termination packets are eventually owned by TimeWaitListManager.
-  // Others are deleted at the end of this call.
-  if (is_termination_packet) {
-    if (termination_packets_.get() == nullptr) {
-      termination_packets_.reset(
-          new std::vector<std::unique_ptr<QuicEncryptedPacket>>);
-    }
-    // Copy the buffer so it's owned in the future.
-    char* buffer_copy = QuicUtils::CopyBuffer(*packet);
-    termination_packets_->push_back(std::unique_ptr<QuicEncryptedPacket>(
-        new QuicEncryptedPacket(buffer_copy, encrypted_length, true)));
-    // This assures we won't try to write *forced* packets when blocked.
-    // Return true to stop processing.
-    if (writer_->IsWriteBlocked()) {
-      visitor_->OnWriteBlocked();
-      return true;
-    }
-  }
-
-  DCHECK_LE(encrypted_length, kMaxPacketSize);
-  DCHECK_LE(encrypted_length, packet_generator_.GetCurrentMaxPacketLength());
-  DVLOG(1) << ENDPOINT << "Sending packet " << packet_number << " : "
-           << (IsRetransmittable(*packet) == HAS_RETRANSMITTABLE_DATA
-                   ? "data bearing "
-                   : " ack only ")
-           << ", encryption level: "
-           << QuicUtils::EncryptionLevelToString(packet->encryption_level)
-           << ", encrypted length:" << encrypted_length;
-  DVLOG(2) << ENDPOINT << "packet(" << packet_number << "): " << std::endl
-           << QuicUtils::HexDump(
-                  StringPiece(packet->encrypted_buffer, encrypted_length));
-
-  // Measure the RTT from before the write begins to avoid underestimating the
-  // min_rtt_, especially in cases where the thread blocks or gets swapped out
-  // during the WritePacket below.
-  QuicTime packet_send_time = clock_->Now();
-  WriteResult result = writer_->WritePacket(
-      packet->encrypted_buffer, encrypted_length, self_address().address(),
-      peer_address(), per_packet_options_);
-  if (result.error_code == ERR_IO_PENDING) {
-    DCHECK_EQ(WRITE_STATUS_BLOCKED, result.status);
-  }
-
-  if (result.status == WRITE_STATUS_BLOCKED) {
-    visitor_->OnWriteBlocked();
-    // If the socket buffers the the data, then the packet should not
-    // be queued and sent again, which would result in an unnecessary
-    // duplicate packet being sent.  The helper must call OnCanWrite
-    // when the write completes, and OnWriteError if an error occurs.
-    if (!writer_->IsWriteBlockedDataBuffered()) {
-      return false;
-    }
-  }
-  if (result.status != WRITE_STATUS_ERROR && debug_visitor_ != nullptr) {
-    // Pass the write result to the visitor.
-    debug_visitor_->OnPacketSent(*packet, packet->original_path_id,
-                                 packet->original_packet_number,
-                                 packet->transmission_type, packet_send_time);
-  }
-  if (packet->transmission_type == NOT_RETRANSMISSION) {
-    time_of_last_sent_new_packet_ = packet_send_time;
-    if (IsRetransmittable(*packet) == HAS_RETRANSMITTABLE_DATA &&
-        last_send_for_timeout_ <= time_of_last_received_packet_) {
-      last_send_for_timeout_ = packet_send_time;
-    }
-  }
-  SetPingAlarm();
-  MaybeSetMtuAlarm();
-  DVLOG(1) << ENDPOINT << "time we began writing last sent packet: "
-           << packet_send_time.ToDebuggingValue();
-
-  if (!FLAGS_quic_simple_packet_number_length_2) {
-    // TODO(ianswett): Change the packet number length and other packet creator
-    // options by a more explicit API than setting a struct value directly,
-    // perhaps via the NetworkChangeVisitor.
-    if (FLAGS_quic_least_unacked_packet_number_length) {
-      packet_generator_.UpdateSequenceNumberLength(
-          sent_packet_manager_->GetLeastUnacked(packet->path_id),
-          sent_packet_manager_->EstimateMaxPacketsInFlight(
-              max_packet_length()));
-    } else {
-      packet_generator_.UpdateSequenceNumberLength(
-          sent_packet_manager_->GetLeastPacketAwaitedByPeer(packet->path_id),
-          sent_packet_manager_->EstimateMaxPacketsInFlight(
-              max_packet_length()));
-    }
-  }
-
-  bool reset_retransmission_alarm = sent_packet_manager_->OnPacketSent(
-      packet, packet->original_path_id, packet->original_packet_number,
-      packet_send_time, packet->transmission_type, IsRetransmittable(*packet));
-
-  if (reset_retransmission_alarm || !retransmission_alarm_->IsSet()) {
-    SetRetransmissionAlarm();
-  }
-
-  if (FLAGS_quic_simple_packet_number_length_2) {
-    // The packet number length must be updated after OnPacketSent, because it
-    // may change the packet number length in packet.
-    if (FLAGS_quic_least_unacked_packet_number_length) {
-      packet_generator_.UpdateSequenceNumberLength(
-          sent_packet_manager_->GetLeastUnacked(packet->path_id),
-          sent_packet_manager_->EstimateMaxPacketsInFlight(
-              max_packet_length()));
-    } else {
-      packet_generator_.UpdateSequenceNumberLength(
-          sent_packet_manager_->GetLeastPacketAwaitedByPeer(packet->path_id),
-          sent_packet_manager_->EstimateMaxPacketsInFlight(
-              max_packet_length()));
-    }
-  }
-
-  stats_.bytes_sent += result.bytes_written;
-  ++stats_.packets_sent;
-  if (packet->transmission_type != NOT_RETRANSMISSION) {
-    stats_.bytes_retransmitted += result.bytes_written;
-    ++stats_.packets_retransmitted;
-  }
-
-  if (result.status == WRITE_STATUS_ERROR) {
-    OnWriteError(result.error_code);
-    DLOG(ERROR) << ENDPOINT << "failed writing " << encrypted_length
-                << " bytes "
-                << " from host " << (self_address().address().empty()
-                                         ? " empty address "
-                                         : self_address().ToStringWithoutPort())
-                << " to address " << peer_address().ToString();
-    return false;
-  }
-
-  return true;
-}
-
-bool QuicConnection::ShouldDiscardPacket(const SerializedPacket& packet) {
-  if (!connected_) {
-    DVLOG(1) << ENDPOINT << "Not sending packet as connection is disconnected.";
-    return true;
-  }
-
-  QuicPacketNumber packet_number = packet.packet_number;
-  if (encryption_level_ == ENCRYPTION_FORWARD_SECURE &&
-      packet.encryption_level == ENCRYPTION_NONE) {
-    // Drop packets that are NULL encrypted since the peer won't accept them
-    // anymore.
-    DVLOG(1) << ENDPOINT << "Dropping NULL encrypted packet: " << packet_number
-             << " since the connection is forward secure.";
-    return true;
-  }
-
-  return false;
-}
-
-void QuicConnection::OnWriteError(int error_code) {
-  if (FLAGS_quic_close_connection_on_packet_too_large && write_error_occured_) {
-    // A write error already occurred. The connection is being closed.
-    return;
-  }
-  write_error_occured_ = true;
-
-  const string error_details = "Write failed with error: " +
-                               base::IntToString(error_code) + " (" +
-                               ErrorToString(error_code) + ")";
-  DVLOG(1) << ENDPOINT << error_details;
-  // We can't send an error as the socket is presumably borked.
-  switch (error_code) {
-    case ERR_MSG_TOO_BIG:
-      if (FLAGS_quic_close_connection_on_packet_too_large) {  // NOLINT
-        CloseConnection(QUIC_PACKET_WRITE_ERROR, error_details,
-                        ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-        break;
-      }
-    default:
-      // We can't send an error as the socket is presumably borked.
-      TearDownLocalConnectionState(QUIC_PACKET_WRITE_ERROR, error_details,
-                                   ConnectionCloseSource::FROM_SELF);
-  }
-}
-
-void QuicConnection::OnSerializedPacket(SerializedPacket* serialized_packet) {
-  DCHECK_NE(kInvalidPathId, serialized_packet->path_id);
-  if (serialized_packet->encrypted_buffer == nullptr) {
-    // We failed to serialize the packet, so close the connection.
-    // TearDownLocalConnectionState does not send close packet, so no infinite
-    // loop here.
-    // TODO(ianswett): This is actually an internal error, not an
-    // encryption failure.
-    TearDownLocalConnectionState(
-        QUIC_ENCRYPTION_FAILURE,
-        "Serialized packet does not have an encrypted buffer.",
-        ConnectionCloseSource::FROM_SELF);
-    return;
-  }
-  SendOrQueuePacket(serialized_packet);
-}
-
-void QuicConnection::OnUnrecoverableError(QuicErrorCode error,
-                                          const string& error_details,
-                                          ConnectionCloseSource source) {
-  // The packet creator or generator encountered an unrecoverable error: tear
-  // down local connection state immediately.
-  TearDownLocalConnectionState(error, error_details, source);
-}
-
-void QuicConnection::OnCongestionChange() {
-  visitor_->OnCongestionWindowChange(clock_->ApproximateNow());
-
-  // Uses the connection's smoothed RTT. If zero, uses initial_rtt.
-  QuicTime::Delta rtt = sent_packet_manager_->GetRttStats()->smoothed_rtt();
-  if (rtt.IsZero()) {
-    rtt = QuicTime::Delta::FromMicroseconds(
-        sent_packet_manager_->GetRttStats()->initial_rtt_us());
-  }
-
-  if (debug_visitor_)
-    debug_visitor_->OnRttChanged(rtt);
-}
-
-void QuicConnection::OnPathDegrading() {
-  visitor_->OnPathDegrading();
-}
-
-void QuicConnection::OnPathMtuIncreased(QuicPacketLength packet_size) {
-  DCHECK(FLAGS_quic_no_mtu_discovery_ack_listener);
-  if (packet_size > max_packet_length()) {
-    SetMaxPacketLength(packet_size);
-  }
-}
-
-void QuicConnection::OnHandshakeComplete() {
-  sent_packet_manager_->SetHandshakeConfirmed();
-  // The client should immediately ack the SHLO to confirm the handshake is
-  // complete with the server.
-  if (perspective_ == Perspective::IS_CLIENT && !ack_queued_ &&
-      ack_frame_updated()) {
-    ack_alarm_->Update(clock_->ApproximateNow(), QuicTime::Delta::Zero());
-  }
-}
-
-void QuicConnection::SendOrQueuePacket(SerializedPacket* packet) {
-  // The caller of this function is responsible for checking CanWrite().
-  if (packet->encrypted_buffer == nullptr) {
-    QUIC_BUG << "packet.encrypted_buffer == nullptr in to SendOrQueuePacket";
-    return;
-  }
-  if (version() <= QUIC_VERSION_33) {
-    sent_entropy_manager_.RecordPacketEntropyHash(packet->packet_number,
-                                                  packet->entropy_hash);
-  }
-  // If there are already queued packets, queue this one immediately to ensure
-  // it's written in sequence number order.
-  if (!queued_packets_.empty() || !WritePacket(packet)) {
-    // Take ownership of the underlying encrypted packet.
-    packet->encrypted_buffer = QuicUtils::CopyBuffer(*packet);
-    queued_packets_.push_back(*packet);
-    packet->retransmittable_frames.clear();
-  }
-
-  QuicUtils::ClearSerializedPacket(packet);
-  // If a forward-secure encrypter is available but is not being used and the
-  // next packet number is the first packet which requires
-  // forward security, start using the forward-secure encrypter.
-  if (!FLAGS_quic_remove_obsolete_forward_secure &&
-      encryption_level_ != ENCRYPTION_FORWARD_SECURE &&
-      has_forward_secure_encrypter_ &&
-      packet->packet_number >= first_required_forward_secure_packet_ - 1) {
-    SetDefaultEncryptionLevel(ENCRYPTION_FORWARD_SECURE);
-  }
-}
-
-void QuicConnection::OnPingTimeout() {
-  if (!retransmission_alarm_->IsSet()) {
-    SendPing();
-  }
-}
-
-void QuicConnection::SendPing() {
-  ScopedPacketBundler bundler(this, SEND_ACK_IF_QUEUED);
-  packet_generator_.AddControlFrame(QuicFrame(QuicPingFrame()));
-  // Send PING frame immediately, without checking for congestion window bounds.
-  packet_generator_.FlushAllQueuedFrames();
-}
-
-void QuicConnection::SendAck() {
-  ack_alarm_->Cancel();
-  ack_queued_ = false;
-  stop_waiting_count_ = 0;
-  num_retransmittable_packets_received_since_last_ack_sent_ = 0;
-  last_ack_had_missing_packets_ = received_packet_manager_.HasMissingPackets();
-  num_packets_received_since_last_ack_sent_ = 0;
-
-  packet_generator_.SetShouldSendAck(true);
-}
-
-void QuicConnection::OnRetransmissionTimeout() {
-  DCHECK(sent_packet_manager_->HasUnackedPackets());
-
-  if (close_connection_after_five_rtos_ &&
-      sent_packet_manager_->GetConsecutiveRtoCount() >= 4) {
-    // Close on the 5th consecutive RTO, so after 4 previous RTOs have occurred.
-    CloseConnection(QUIC_TOO_MANY_RTOS, "5 consecutive retransmission timeouts",
-                    ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-    return;
-  }
-
-  sent_packet_manager_->OnRetransmissionTimeout();
-  WriteIfNotBlocked();
-
-  // A write failure can result in the connection being closed, don't attempt to
-  // write further packets, or to set alarms.
-  if (!connected_) {
-    return;
-  }
-
-  // In the TLP case, the SentPacketManager gives the connection the opportunity
-  // to send new data before retransmitting.
-  if (sent_packet_manager_->MaybeRetransmitTailLossProbe()) {
-    // Send the pending retransmission now that it's been queued.
-    WriteIfNotBlocked();
-  }
-
-  // Ensure the retransmission alarm is always set if there are unacked packets
-  // and nothing waiting to be sent.
-  // This happens if the loss algorithm invokes a timer based loss, but the
-  // packet doesn't need to be retransmitted.
-  if (!HasQueuedData() && !retransmission_alarm_->IsSet()) {
-    SetRetransmissionAlarm();
-  }
-}
-
-void QuicConnection::SetEncrypter(EncryptionLevel level,
-                                  QuicEncrypter* encrypter) {
-  packet_generator_.SetEncrypter(level, encrypter);
-  if (!FLAGS_quic_remove_obsolete_forward_secure &&
-      level == ENCRYPTION_FORWARD_SECURE) {
-    has_forward_secure_encrypter_ = true;
-    first_required_forward_secure_packet_ =
-        packet_number_of_last_sent_packet_ +
-        // 3 times the current congestion window (in slow start) should cover
-        // about two full round trips worth of packets, which should be
-        // sufficient.
-        3 *
-            sent_packet_manager_->EstimateMaxPacketsInFlight(
-                max_packet_length());
-  }
-}
-
-void QuicConnection::SetDiversificationNonce(const DiversificationNonce nonce) {
-  DCHECK_EQ(Perspective::IS_SERVER, perspective_);
-  packet_generator_.SetDiversificationNonce(nonce);
-}
-
-void QuicConnection::SetDefaultEncryptionLevel(EncryptionLevel level) {
-  encryption_level_ = level;
-  packet_generator_.set_encryption_level(level);
-}
-
-void QuicConnection::SetDecrypter(EncryptionLevel level,
-                                  QuicDecrypter* decrypter) {
-  framer_.SetDecrypter(level, decrypter);
-}
-
-void QuicConnection::SetAlternativeDecrypter(EncryptionLevel level,
-                                             QuicDecrypter* decrypter,
-                                             bool latch_once_used) {
-  framer_.SetAlternativeDecrypter(level, decrypter, latch_once_used);
-}
-
-const QuicDecrypter* QuicConnection::decrypter() const {
-  return framer_.decrypter();
-}
-
-const QuicDecrypter* QuicConnection::alternative_decrypter() const {
-  return framer_.alternative_decrypter();
-}
-
-void QuicConnection::QueueUndecryptablePacket(
-    const QuicEncryptedPacket& packet) {
-  DVLOG(1) << ENDPOINT << "Queueing undecryptable packet.";
-  undecryptable_packets_.push_back(packet.Clone());
-}
-
-void QuicConnection::MaybeProcessUndecryptablePackets() {
-  if (undecryptable_packets_.empty() || encryption_level_ == ENCRYPTION_NONE) {
-    return;
-  }
-
-  while (connected_ && !undecryptable_packets_.empty()) {
-    DVLOG(1) << ENDPOINT << "Attempting to process undecryptable packet";
-    QuicEncryptedPacket* packet = undecryptable_packets_.front();
-    if (!framer_.ProcessPacket(*packet) &&
-        framer_.error() == QUIC_DECRYPTION_FAILURE) {
-      DVLOG(1) << ENDPOINT << "Unable to process undecryptable packet...";
-      break;
-    }
-    DVLOG(1) << ENDPOINT << "Processed undecryptable packet!";
-    ++stats_.packets_processed;
-    delete packet;
-    undecryptable_packets_.pop_front();
-  }
-
-  // Once forward secure encryption is in use, there will be no
-  // new keys installed and hence any undecryptable packets will
-  // never be able to be decrypted.
-  if (encryption_level_ == ENCRYPTION_FORWARD_SECURE) {
-    if (debug_visitor_ != nullptr) {
-      // TODO(rtenneti): perhaps more efficient to pass the number of
-      // undecryptable packets as the argument to OnUndecryptablePacket so that
-      // we just need to call OnUndecryptablePacket once?
-      for (size_t i = 0; i < undecryptable_packets_.size(); ++i) {
-        debug_visitor_->OnUndecryptablePacket();
-      }
-    }
-    base::STLDeleteElements(&undecryptable_packets_);
-  }
-}
-
-void QuicConnection::CloseConnection(
-    QuicErrorCode error,
-    const string& error_details,
-    ConnectionCloseBehavior connection_close_behavior) {
-  DCHECK(!error_details.empty());
-  if (!connected_) {
-    DVLOG(1) << "Connection is already closed.";
-    return;
-  }
-
-  DVLOG(1) << ENDPOINT << "Closing connection: " << connection_id()
-           << ", with error: " << QuicUtils::ErrorToString(error) << " ("
-           << error << "), and details:  " << error_details;
-
-  if (connection_close_behavior ==
-      ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET) {
-    SendConnectionClosePacket(error, error_details);
-  }
-
-  TearDownLocalConnectionState(error, error_details,
-                               ConnectionCloseSource::FROM_SELF);
-}
-
-void QuicConnection::SendConnectionClosePacket(QuicErrorCode error,
-                                               const string& details) {
-  DVLOG(1) << ENDPOINT << "Sending connection close packet.";
-  ClearQueuedPackets();
-  ScopedPacketBundler ack_bundler(this, SEND_ACK);
-  QuicConnectionCloseFrame* frame = new QuicConnectionCloseFrame();
-  frame->error_code = error;
-  frame->error_details = details;
-  packet_generator_.AddControlFrame(QuicFrame(frame));
-  packet_generator_.FlushAllQueuedFrames();
-}
-
-void QuicConnection::TearDownLocalConnectionState(
-    QuicErrorCode error,
-    const string& error_details,
-    ConnectionCloseSource source) {
-  if (!connected_) {
-    DVLOG(1) << "Connection is already closed.";
-    return;
-  }
-  connected_ = false;
-  DCHECK(visitor_ != nullptr);
-  // TODO(rtenneti): crbug.com/546668. A temporary fix. Added a check for null
-  // |visitor_| to fix crash bug. Delete |visitor_| check and histogram after
-  // fix is merged.
-  if (visitor_ != nullptr) {
-    visitor_->OnConnectionClosed(error, error_details, source);
-  } else {
-    UMA_HISTOGRAM_BOOLEAN("Net.QuicCloseConnection.NullVisitor", true);
-  }
-  if (debug_visitor_ != nullptr) {
-    debug_visitor_->OnConnectionClosed(error, error_details, source);
-  }
-  // Cancel the alarms so they don't trigger any action now that the
-  // connection is closed.
-  CancelAllAlarms();
-}
-
-void QuicConnection::CancelAllAlarms() {
-  ack_alarm_->Cancel();
-  ping_alarm_->Cancel();
-  resume_writes_alarm_->Cancel();
-  retransmission_alarm_->Cancel();
-  send_alarm_->Cancel();
-  timeout_alarm_->Cancel();
-  mtu_discovery_alarm_->Cancel();
-}
-
-void QuicConnection::SendGoAway(QuicErrorCode error,
-                                QuicStreamId last_good_stream_id,
-                                const string& reason) {
-  if (goaway_sent_) {
-    return;
-  }
-  goaway_sent_ = true;
-
-  DVLOG(1) << ENDPOINT << "Going away with error "
-           << QuicUtils::ErrorToString(error) << " (" << error << ")";
-
-  // Opportunistically bundle an ack with this outgoing packet.
-  ScopedPacketBundler ack_bundler(this, SEND_ACK_IF_PENDING);
-  packet_generator_.AddControlFrame(
-      QuicFrame(new QuicGoAwayFrame(error, last_good_stream_id, reason)));
-}
-
-QuicByteCount QuicConnection::max_packet_length() const {
-  return packet_generator_.GetCurrentMaxPacketLength();
-}
-
-void QuicConnection::SetMaxPacketLength(QuicByteCount length) {
-  return packet_generator_.SetMaxPacketLength(LimitMaxPacketSize(length));
-}
-
-bool QuicConnection::HasQueuedData() const {
-  return pending_version_negotiation_packet_ || !queued_packets_.empty() ||
-         packet_generator_.HasQueuedFrames();
-}
-
-void QuicConnection::EnableSavingCryptoPackets() {
-  save_crypto_packets_as_termination_packets_ = true;
-}
-
-bool QuicConnection::CanWriteStreamData() {
-  // Don't write stream data if there are negotiation or queued data packets
-  // to send. Otherwise, continue and bundle as many frames as possible.
-  if (pending_version_negotiation_packet_ || !queued_packets_.empty()) {
-    return false;
-  }
-
-  IsHandshake pending_handshake =
-      visitor_->HasPendingHandshake() ? IS_HANDSHAKE : NOT_HANDSHAKE;
-  // Sending queued packets may have caused the socket to become write blocked,
-  // or the congestion manager to prohibit sending.  If we've sent everything
-  // we had queued and we're still not blocked, let the visitor know it can
-  // write more.
-  return ShouldGeneratePacket(HAS_RETRANSMITTABLE_DATA, pending_handshake);
-}
-
-void QuicConnection::SetNetworkTimeouts(QuicTime::Delta handshake_timeout,
-                                        QuicTime::Delta idle_timeout) {
-  QUIC_BUG_IF(idle_timeout > handshake_timeout)
-      << "idle_timeout:" << idle_timeout.ToMilliseconds()
-      << " handshake_timeout:" << handshake_timeout.ToMilliseconds();
-  // Adjust the idle timeout on client and server to prevent clients from
-  // sending requests to servers which have already closed the connection.
-  if (perspective_ == Perspective::IS_SERVER) {
-    idle_timeout = idle_timeout + QuicTime::Delta::FromSeconds(3);
-  } else if (idle_timeout > QuicTime::Delta::FromSeconds(1)) {
-    idle_timeout = idle_timeout - QuicTime::Delta::FromSeconds(1);
-  }
-  handshake_timeout_ = handshake_timeout;
-  idle_network_timeout_ = idle_timeout;
-
-  SetTimeoutAlarm();
-}
-
-void QuicConnection::CheckForTimeout() {
-  QuicTime now = clock_->ApproximateNow();
-  QuicTime time_of_last_packet =
-      max(time_of_last_received_packet_, last_send_for_timeout_);
-
-  // |delta| can be < 0 as |now| is approximate time but |time_of_last_packet|
-  // is accurate time. However, this should not change the behavior of
-  // timeout handling.
-  QuicTime::Delta idle_duration = now - time_of_last_packet;
-  DVLOG(1) << ENDPOINT << "last packet "
-           << time_of_last_packet.ToDebuggingValue()
-           << " now:" << now.ToDebuggingValue()
-           << " idle_duration:" << idle_duration.ToMicroseconds()
-           << " idle_network_timeout: "
-           << idle_network_timeout_.ToMicroseconds();
-  if (idle_duration >= idle_network_timeout_) {
-    const string error_details = "No recent network activity.";
-    DVLOG(1) << ENDPOINT << error_details;
-    CloseConnection(QUIC_NETWORK_IDLE_TIMEOUT, error_details,
-                    idle_timeout_connection_close_behavior_);
-    return;
-  }
-
-  if (!handshake_timeout_.IsInfinite()) {
-    QuicTime::Delta connected_duration = now - stats_.connection_creation_time;
-    DVLOG(1) << ENDPOINT
-             << "connection time: " << connected_duration.ToMicroseconds()
-             << " handshake timeout: " << handshake_timeout_.ToMicroseconds();
-    if (connected_duration >= handshake_timeout_) {
-      const string error_details = "Handshake timeout expired.";
-      DVLOG(1) << ENDPOINT << error_details;
-      CloseConnection(QUIC_HANDSHAKE_TIMEOUT, error_details,
-                      ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
-      return;
-    }
-  }
-
-  SetTimeoutAlarm();
-}
-
-void QuicConnection::SetTimeoutAlarm() {
-  QuicTime time_of_last_packet =
-      max(time_of_last_received_packet_, time_of_last_sent_new_packet_);
-
-  QuicTime deadline = time_of_last_packet + idle_network_timeout_;
-  if (!handshake_timeout_.IsInfinite()) {
-    deadline =
-        min(deadline, stats_.connection_creation_time + handshake_timeout_);
-  }
-
-  timeout_alarm_->Update(deadline, QuicTime::Delta::Zero());
-}
-
-void QuicConnection::SetPingAlarm() {
-  if (perspective_ == Perspective::IS_SERVER) {
-    // Only clients send pings.
-    return;
-  }
-  if (!visitor_->HasOpenDynamicStreams()) {
-    ping_alarm_->Cancel();
-    // Don't send a ping unless there are open streams.
-    return;
-  }
-  QuicTime::Delta ping_timeout = QuicTime::Delta::FromSeconds(kPingTimeoutSecs);
-  ping_alarm_->Update(clock_->ApproximateNow() + ping_timeout,
-                      QuicTime::Delta::FromSeconds(1));
-}
-
-void QuicConnection::SetRetransmissionAlarm() {
-  if (delay_setting_retransmission_alarm_) {
-    pending_retransmission_alarm_ = true;
-    return;
-  }
-  QuicTime retransmission_time = sent_packet_manager_->GetRetransmissionTime();
-  retransmission_alarm_->Update(retransmission_time,
-                                QuicTime::Delta::FromMilliseconds(1));
-}
-
-void QuicConnection::MaybeSetMtuAlarm() {
-  // Do not set the alarm if the target size is less than the current size.
-  // This covers the case when |mtu_discovery_target_| is at its default value,
-  // zero.
-  if (mtu_discovery_target_ <= max_packet_length()) {
-    return;
-  }
-
-  if (mtu_probe_count_ >= kMtuDiscoveryAttempts) {
-    return;
-  }
-
-  if (mtu_discovery_alarm_->IsSet()) {
-    return;
-  }
-
-  if (packet_number_of_last_sent_packet_ >= next_mtu_probe_at_) {
-    // Use an alarm to send the MTU probe to ensure that no ScopedPacketBundlers
-    // are active.
-    mtu_discovery_alarm_->Set(clock_->ApproximateNow());
-  }
-}
-
-QuicConnection::ScopedPacketBundler::ScopedPacketBundler(
-    QuicConnection* connection,
-    AckBundling ack_mode)
-    : connection_(connection),
-      already_in_batch_mode_(connection != nullptr &&
-                             connection->packet_generator_.InBatchMode()) {
-  if (connection_ == nullptr) {
-    return;
-  }
-  // Move generator into batch mode. If caller wants us to include an ack,
-  // check the delayed-ack timer to see if there's ack info to be sent.
-  if (!already_in_batch_mode_) {
-    DVLOG(2) << "Entering Batch Mode.";
-    connection_->packet_generator_.StartBatchOperations();
-  }
-  if (ShouldSendAck(ack_mode)) {
-    DVLOG(1) << "Bundling ack with outgoing packet.";
-    DCHECK(ack_mode == SEND_ACK || connection_->ack_frame_updated() ||
-           connection_->stop_waiting_count_ > 1);
-    connection_->SendAck();
-  }
-}
-
-bool QuicConnection::ScopedPacketBundler::ShouldSendAck(
-    AckBundling ack_mode) const {
-  switch (ack_mode) {
-    case SEND_ACK:
-      return true;
-    case SEND_ACK_IF_QUEUED:
-      return connection_->ack_queued();
-    case SEND_ACK_IF_PENDING:
-      return connection_->ack_alarm_->IsSet() ||
-             connection_->stop_waiting_count_ > 1;
-    default:
-      QUIC_BUG << "Unsupported ack_mode.";
-      return true;
-  }
-}
-
-QuicConnection::ScopedPacketBundler::~ScopedPacketBundler() {
-  if (connection_ == nullptr) {
-    return;
-  }
-  // If we changed the generator's batch state, restore original batch state.
-  if (!already_in_batch_mode_) {
-    DVLOG(2) << "Leaving Batch Mode.";
-    connection_->packet_generator_.FinishBatchOperations();
-
-    // Once all transmissions are done, check if there is any outstanding data
-    // to send and notify the congestion controller if not.
-    //
-    // Note that this means that the application limited check will happen as
-    // soon as the last bundler gets destroyed, which is typically after a
-    // single stream write is finished.  This means that if all the data from a
-    // single write goes through the connection, the application-limited signal
-    // will fire even if the caller does a write operation immediately after.
-    // There are two important approaches to remedy this situation:
-    // (1) Instantiate ScopedPacketBundler before performing multiple subsequent
-    //     writes, thus deferring this check until all writes are done.
-    // (2) Write data in chunks sufficiently large so that they cause the
-    //     connection to be limited by the congestion control.  Typically, this
-    //     would mean writing chunks larger than the product of the current
-    //     pacing rate and the pacer granularity.  So, for instance, if the
-    //     pacing rate of the connection is 1 Gbps, and the pacer granularity is
-    //     1 ms, the caller should send at least 125k bytes in order to not
-    //     be marked as application-limited.
-    if (FLAGS_quic_enable_app_limited_check) {
-      connection_->CheckIfApplicationLimited();
-    }
-  }
-  DCHECK_EQ(already_in_batch_mode_,
-            connection_->packet_generator_.InBatchMode());
-}
-
-QuicConnection::ScopedRetransmissionScheduler::ScopedRetransmissionScheduler(
-    QuicConnection* connection)
-    : connection_(connection),
-      already_delayed_(connection_->delay_setting_retransmission_alarm_) {
-  connection_->delay_setting_retransmission_alarm_ = true;
-}
-
-QuicConnection::ScopedRetransmissionScheduler::
-    ~ScopedRetransmissionScheduler() {
-  if (already_delayed_) {
-    return;
-  }
-  connection_->delay_setting_retransmission_alarm_ = false;
-  if (connection_->pending_retransmission_alarm_) {
-    connection_->SetRetransmissionAlarm();
-    connection_->pending_retransmission_alarm_ = false;
-  }
-}
-
-HasRetransmittableData QuicConnection::IsRetransmittable(
-    const SerializedPacket& packet) {
-  // Retransmitted packets retransmittable frames are owned by the unacked
-  // packet map, but are not present in the serialized packet.
-  if (packet.transmission_type != NOT_RETRANSMISSION ||
-      !packet.retransmittable_frames.empty()) {
-    return HAS_RETRANSMITTABLE_DATA;
-  } else {
-    return NO_RETRANSMITTABLE_DATA;
-  }
-}
-
-bool QuicConnection::IsTerminationPacket(const SerializedPacket& packet) {
-  if (packet.retransmittable_frames.empty()) {
-    return false;
-  }
-  for (const QuicFrame& frame : packet.retransmittable_frames) {
-    if (frame.type == CONNECTION_CLOSE_FRAME) {
-      return true;
-    }
-    if (save_crypto_packets_as_termination_packets_ &&
-        frame.type == STREAM_FRAME &&
-        frame.stream_frame->stream_id == kCryptoStreamId) {
-      return true;
-    }
-  }
-  return false;
-}
-
-void QuicConnection::SetMtuDiscoveryTarget(QuicByteCount target) {
-  mtu_discovery_target_ = LimitMaxPacketSize(target);
-}
-
-QuicByteCount QuicConnection::LimitMaxPacketSize(
-    QuicByteCount suggested_max_packet_size) {
-  if (peer_address_.address().empty()) {
-    QUIC_BUG << "Attempted to use a connection without a valid peer address";
-    return suggested_max_packet_size;
-  }
-
-  const QuicByteCount writer_limit = writer_->GetMaxPacketSize(peer_address());
-
-  QuicByteCount max_packet_size = suggested_max_packet_size;
-  if (max_packet_size > writer_limit) {
-    max_packet_size = writer_limit;
-  }
-  if (max_packet_size > kMaxPacketSize) {
-    max_packet_size = kMaxPacketSize;
-  }
-  return max_packet_size;
-}
-
-void QuicConnection::SendMtuDiscoveryPacket(QuicByteCount target_mtu) {
-  // Currently, this limit is ensured by the caller.
-  DCHECK_EQ(target_mtu, LimitMaxPacketSize(target_mtu));
-
-  // Create a listener for the new probe.  The ownership of the listener is
-  // transferred to the AckNotifierManager.  The notifier will get destroyed
-  // before the connection (because it's stored in one of the connection's
-  // subfields), hence |this| pointer is guaranteed to stay valid at all times.
-  scoped_refptr<MtuDiscoveryAckListener> last_mtu_discovery_ack_listener(
-      new MtuDiscoveryAckListener(this, target_mtu));
-
-  // Send the probe.
-  packet_generator_.GenerateMtuDiscoveryPacket(
-      target_mtu, FLAGS_quic_no_mtu_discovery_ack_listener
-                      ? nullptr
-                      : last_mtu_discovery_ack_listener.get());
-}
-
-void QuicConnection::DiscoverMtu() {
-  DCHECK(!mtu_discovery_alarm_->IsSet());
-
-  // Check if the MTU has been already increased.
-  if (mtu_discovery_target_ <= max_packet_length()) {
-    return;
-  }
-
-  // Calculate the packet number of the next probe *before* sending the current
-  // one.  Otherwise, when SendMtuDiscoveryPacket() is called,
-  // MaybeSetMtuAlarm() will not realize that the probe has been just sent, and
-  // will reschedule this probe again.
-  packets_between_mtu_probes_ *= 2;
-  next_mtu_probe_at_ =
-      packet_number_of_last_sent_packet_ + packets_between_mtu_probes_ + 1;
-  ++mtu_probe_count_;
-
-  DVLOG(2) << "Sending a path MTU discovery packet #" << mtu_probe_count_;
-  SendMtuDiscoveryPacket(mtu_discovery_target_);
-
-  DCHECK(!mtu_discovery_alarm_->IsSet());
-}
-
-void QuicConnection::OnPeerMigrationValidated(QuicPathId path_id) {
-  if (active_peer_migration_type_ == NO_CHANGE) {
-    QUIC_BUG << "No migration underway.";
-    return;
-  }
-  highest_packet_sent_before_peer_migration_ = 0;
-  active_peer_migration_type_ = NO_CHANGE;
-}
-
-// TODO(jri): Modify method to start migration whenever a new IP address is seen
-// from a packet with sequence number > the one that triggered the previous
-// migration. This should happen even if a migration is underway, since the
-// most recent migration is the one that we should pay attention to.
-void QuicConnection::StartPeerMigration(
-    QuicPathId path_id,
-    PeerAddressChangeType peer_migration_type) {
-  // TODO(fayang): Currently, all peer address change type are allowed. Need to
-  // add a method ShouldAllowPeerAddressChange(PeerAddressChangeType type) to
-  // determine whether |type| is allowed.
-  if (active_peer_migration_type_ != NO_CHANGE ||
-      peer_migration_type == NO_CHANGE) {
-    QUIC_BUG << "Migration underway or no new migration started.";
-    return;
-  }
-  DVLOG(1) << ENDPOINT << "Peer's ip:port changed from "
-           << peer_address_.ToString() << " to "
-           << last_packet_source_address_.ToString()
-           << ", migrating connection.";
-
-  highest_packet_sent_before_peer_migration_ =
-      packet_number_of_last_sent_packet_;
-  peer_address_ = last_packet_source_address_;
-  active_peer_migration_type_ = peer_migration_type;
-
-  // TODO(jri): Move these calls to OnPeerMigrationValidated. Rename
-  // OnConnectionMigration methods to OnPeerMigration.
-  visitor_->OnConnectionMigration(peer_migration_type);
-  sent_packet_manager_->OnConnectionMigration(path_id, peer_migration_type);
-}
-
-void QuicConnection::OnPathClosed(QuicPathId path_id) {
-  // Stop receiving packets on this path.
-  framer_.OnPathClosed(path_id);
-}
-
-bool QuicConnection::ack_frame_updated() const {
-  return received_packet_manager_.ack_frame_updated();
-}
-
-StringPiece QuicConnection::GetCurrentPacket() {
-  if (current_packet_data_ == nullptr) {
-    return StringPiece();
-  }
-  return StringPiece(current_packet_data_, last_size_);
-}
-
-bool QuicConnection::MaybeConsiderAsMemoryCorruption(
-    const QuicStreamFrame& frame) {
-  if (frame.stream_id == kCryptoStreamId ||
-      last_decrypted_packet_level_ != ENCRYPTION_NONE) {
-    return false;
-  }
-
-  if (perspective_ == Perspective::IS_SERVER &&
-      frame.data_length >= sizeof(kCHLO) &&
-      strncmp(frame.data_buffer, reinterpret_cast<const char*>(&kCHLO),
-              sizeof(kCHLO)) == 0) {
-    return true;
-  }
-
-  if (perspective_ == Perspective::IS_CLIENT &&
-      frame.data_length >= sizeof(kREJ) &&
-      strncmp(frame.data_buffer, reinterpret_cast<const char*>(&kREJ),
-              sizeof(kREJ)) == 0) {
-    return true;
-  }
-
-  return false;
-}
-
-// Uses a 25ms delayed ack timer. Also helps with better signaling
-// in low-bandwidth (< ~384 kbps), where an ack is sent per packet.
-// Ensures that the Delayed Ack timer is always set to a value lesser
-// than the retransmission timer's minimum value (MinRTO). We want the
-// delayed ack to get back to the QUIC peer before the sender's
-// retransmission timer triggers.  Since we do not know the
-// reverse-path one-way delay, we assume equal delays for forward and
-// reverse paths, and ensure that the timer is set to less than half
-// of the MinRTO.
-// There may be a value in making this delay adaptive with the help of
-// the sender and a signaling mechanism -- if the sender uses a
-// different MinRTO, we may get spurious retransmissions. May not have
-// any benefits, but if the delayed ack becomes a significant source
-// of (likely, tail) latency, then consider such a mechanism.
-const QuicTime::Delta QuicConnection::DelayedAckTime() {
-  return QuicTime::Delta::FromMilliseconds(
-      min(kMaxDelayedAckTimeMs, kMinRetransmissionTimeMs / 2));
-}
-
-void QuicConnection::CheckIfApplicationLimited() {
-  if (queued_packets_.empty() &&
-      !sent_packet_manager_->HasPendingRetransmissions() &&
-      !visitor_->WillingAndAbleToWrite()) {
-    sent_packet_manager_->OnApplicationLimited();
-  }
-}
-
-}  // namespace net
diff --git a/src/net/quic/core/quic_connection_test.cc.orig b/src/net/quic/core/quic_connection_test.cc.orig
deleted file mode 100644
index 1e1686e..0000000
--- a/src/net/quic/core/quic_connection_test.cc.orig
+++ /dev/null
@@ -1,5292 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "net/quic/core/quic_connection.h"
-
-#include <errno.h>
-#include <memory>
-#include <ostream>
-#include <utility>
-
-#include "base/bind.h"
-#include "base/macros.h"
-#include "base/stl_util.h"
-#include "net/base/ip_address.h"
-#include "net/base/net_errors.h"
-#include "net/quic/core/congestion_control/loss_detection_interface.h"
-#include "net/quic/core/congestion_control/send_algorithm_interface.h"
-#include "net/quic/core/crypto/null_encrypter.h"
-#include "net/quic/core/crypto/quic_decrypter.h"
-#include "net/quic/core/crypto/quic_encrypter.h"
-#include "net/quic/core/quic_flags.h"
-#include "net/quic/core/quic_protocol.h"
-#include "net/quic/core/quic_simple_buffer_allocator.h"
-#include "net/quic/core/quic_utils.h"
-#include "net/quic/test_tools/mock_clock.h"
-#include "net/quic/test_tools/mock_random.h"
-#include "net/quic/test_tools/quic_config_peer.h"
-#include "net/quic/test_tools/quic_connection_peer.h"
-#include "net/quic/test_tools/quic_framer_peer.h"
-#include "net/quic/test_tools/quic_packet_creator_peer.h"
-#include "net/quic/test_tools/quic_packet_generator_peer.h"
-#include "net/quic/test_tools/quic_sent_packet_manager_peer.h"
-#include "net/quic/test_tools/quic_test_utils.h"
-#include "net/quic/test_tools/simple_quic_framer.h"
-#include "net/test/gtest_util.h"
-#include "testing/gmock/include/gmock/gmock.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-using base::StringPiece;
-using std::map;
-using std::ostream;
-using std::string;
-using std::vector;
-using testing::AnyNumber;
-using testing::AtLeast;
-using testing::Contains;
-using testing::DoAll;
-using testing::InSequence;
-using testing::InvokeWithoutArgs;
-using testing::NiceMock;
-using testing::Ref;
-using testing::Return;
-using testing::SaveArg;
-using testing::SetArgPointee;
-using testing::StrictMock;
-using testing::_;
-
-namespace net {
-namespace test {
-namespace {
-
-const char data1[] = "foo";
-const char data2[] = "bar";
-
-const bool kFin = true;
-const bool kEntropyFlag = true;
-const bool kHasStopWaiting = true;
-
-const QuicPacketEntropyHash kTestEntropyHash = 76;
-
-const int kDefaultRetransmissionTimeMs = 500;
-
-const IPEndPoint kPeerAddress = IPEndPoint(Loopback6(), /*port=*/12345);
-const IPEndPoint kSelfAddress = IPEndPoint(Loopback6(), /*port=*/443);
-
-Perspective InvertPerspective(Perspective perspective) {
-  return perspective == Perspective::IS_CLIENT ? Perspective::IS_SERVER
-                                               : Perspective::IS_CLIENT;
-}
-
-// TaggingEncrypter appends kTagSize bytes of |tag| to the end of each message.
-class TaggingEncrypter : public QuicEncrypter {
- public:
-  explicit TaggingEncrypter(uint8_t tag) : tag_(tag) {}
-
-  ~TaggingEncrypter() override {}
-
-  // QuicEncrypter interface.
-  bool SetKey(StringPiece key) override { return true; }
-
-  bool SetNoncePrefix(StringPiece nonce_prefix) override { return true; }
-
-  bool EncryptPacket(QuicPathId path_id,
-                     QuicPacketNumber packet_number,
-                     StringPiece associated_data,
-                     StringPiece plaintext,
-                     char* output,
-                     size_t* output_length,
-                     size_t max_output_length) override {
-    const size_t len = plaintext.size() + kTagSize;
-    if (max_output_length < len) {
-      return false;
-    }
-    // Memmove is safe for inplace encryption.
-    memmove(output, plaintext.data(), plaintext.size());
-    output += plaintext.size();
-    memset(output, tag_, kTagSize);
-    *output_length = len;
-    return true;
-  }
-
-  size_t GetKeySize() const override { return 0; }
-  size_t GetNoncePrefixSize() const override { return 0; }
-
-  size_t GetMaxPlaintextSize(size_t ciphertext_size) const override {
-    return ciphertext_size - kTagSize;
-  }
-
-  size_t GetCiphertextSize(size_t plaintext_size) const override {
-    return plaintext_size + kTagSize;
-  }
-
-  StringPiece GetKey() const override { return StringPiece(); }
-
-  StringPiece GetNoncePrefix() const override { return StringPiece(); }
-
- private:
-  enum {
-    kTagSize = 12,
-  };
-
-  const uint8_t tag_;
-
-  DISALLOW_COPY_AND_ASSIGN(TaggingEncrypter);
-};
-
-// TaggingDecrypter ensures that the final kTagSize bytes of the message all
-// have the same value and then removes them.
-class TaggingDecrypter : public QuicDecrypter {
- public:
-  ~TaggingDecrypter() override {}
-
-  // QuicDecrypter interface
-  bool SetKey(StringPiece key) override { return true; }
-
-  bool SetNoncePrefix(StringPiece nonce_prefix) override { return true; }
-
-  bool SetPreliminaryKey(StringPiece key) override {
-    QUIC_BUG << "should not be called";
-    return false;
-  }
-
-  bool SetDiversificationNonce(DiversificationNonce key) override {
-    return true;
-  }
-
-  bool DecryptPacket(QuicPathId path_id,
-                     QuicPacketNumber packet_number,
-                     StringPiece associated_data,
-                     StringPiece ciphertext,
-                     char* output,
-                     size_t* output_length,
-                     size_t max_output_length) override {
-    if (ciphertext.size() < kTagSize) {
-      return false;
-    }
-    if (!CheckTag(ciphertext, GetTag(ciphertext))) {
-      return false;
-    }
-    *output_length = ciphertext.size() - kTagSize;
-    memcpy(output, ciphertext.data(), *output_length);
-    return true;
-  }
-
-  StringPiece GetKey() const override { return StringPiece(); }
-  StringPiece GetNoncePrefix() const override { return StringPiece(); }
-  const char* cipher_name() const override { return "Tagging"; }
-  // Use a distinct value starting with 0xFFFFFF, which is never used by TLS.
-  uint32_t cipher_id() const override { return 0xFFFFFFF0; }
-
- protected:
-  virtual uint8_t GetTag(StringPiece ciphertext) {
-    return ciphertext.data()[ciphertext.size() - 1];
-  }
-
- private:
-  enum {
-    kTagSize = 12,
-  };
-
-  bool CheckTag(StringPiece ciphertext, uint8_t tag) {
-    for (size_t i = ciphertext.size() - kTagSize; i < ciphertext.size(); i++) {
-      if (ciphertext.data()[i] != tag) {
-        return false;
-      }
-    }
-
-    return true;
-  }
-};
-
-// StringTaggingDecrypter ensures that the final kTagSize bytes of the message
-// match the expected value.
-class StrictTaggingDecrypter : public TaggingDecrypter {
- public:
-  explicit StrictTaggingDecrypter(uint8_t tag) : tag_(tag) {}
-  ~StrictTaggingDecrypter() override {}
-
-  // TaggingQuicDecrypter
-  uint8_t GetTag(StringPiece ciphertext) override { return tag_; }
-
-  const char* cipher_name() const override { return "StrictTagging"; }
-  // Use a distinct value starting with 0xFFFFFF, which is never used by TLS.
-  uint32_t cipher_id() const override { return 0xFFFFFFF1; }
-
- private:
-  const uint8_t tag_;
-};
-
-class TestConnectionHelper : public QuicConnectionHelperInterface {
- public:
-  TestConnectionHelper(MockClock* clock, MockRandom* random_generator)
-      : clock_(clock), random_generator_(random_generator) {
-    clock_->AdvanceTime(QuicTime::Delta::FromSeconds(1));
-  }
-
-  // QuicConnectionHelperInterface
-  const QuicClock* GetClock() const override { return clock_; }
-
-  QuicRandom* GetRandomGenerator() override { return random_generator_; }
-
-  QuicBufferAllocator* GetBufferAllocator() override {
-    return &buffer_allocator_;
-  }
-
- private:
-  MockClock* clock_;
-  MockRandom* random_generator_;
-  SimpleBufferAllocator buffer_allocator_;
-
-  DISALLOW_COPY_AND_ASSIGN(TestConnectionHelper);
-};
-
-class TestAlarmFactory : public QuicAlarmFactory {
- public:
-  class TestAlarm : public QuicAlarm {
-   public:
-    explicit TestAlarm(QuicArenaScopedPtr<QuicAlarm::Delegate> delegate)
-        : QuicAlarm(std::move(delegate)) {}
-
-    void SetImpl() override {}
-    void CancelImpl() override {}
-    using QuicAlarm::Fire;
-  };
-
-  TestAlarmFactory() {}
-
-  QuicAlarm* CreateAlarm(QuicAlarm::Delegate* delegate) override {
-    return new TestAlarm(QuicArenaScopedPtr<QuicAlarm::Delegate>(delegate));
-  }
-
-  QuicArenaScopedPtr<QuicAlarm> CreateAlarm(
-      QuicArenaScopedPtr<QuicAlarm::Delegate> delegate,
-      QuicConnectionArena* arena) override {
-    return arena->New<TestAlarm>(std::move(delegate));
-  }
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(TestAlarmFactory);
-};
-
-class TestPacketWriter : public QuicPacketWriter {
- public:
-  TestPacketWriter(QuicVersion version, MockClock* clock)
-      : version_(version),
-        framer_(SupportedVersions(version_)),
-        last_packet_size_(0),
-        write_blocked_(false),
-        write_should_fail_(false),
-        block_on_next_write_(false),
-        next_packet_too_large_(false),
-        always_get_packet_too_large_(false),
-        is_write_blocked_data_buffered_(false),
-        final_bytes_of_last_packet_(0),
-        final_bytes_of_previous_packet_(0),
-        use_tagging_decrypter_(false),
-        packets_write_attempts_(0),
-        clock_(clock),
-        write_pause_time_delta_(QuicTime::Delta::Zero()),
-        max_packet_size_(kMaxPacketSize) {}
-
-  // QuicPacketWriter interface
-  WriteResult WritePacket(const char* buffer,
-                          size_t buf_len,
-                          const IPAddress& self_address,
-                          const IPEndPoint& peer_address,
-                          PerPacketOptions* options) override {
-    QuicEncryptedPacket packet(buffer, buf_len);
-    ++packets_write_attempts_;
-
-    if (packet.length() >= sizeof(final_bytes_of_last_packet_)) {
-      final_bytes_of_previous_packet_ = final_bytes_of_last_packet_;
-      memcpy(&final_bytes_of_last_packet_, packet.data() + packet.length() - 4,
-             sizeof(final_bytes_of_last_packet_));
-    }
-
-    if (use_tagging_decrypter_) {
-      framer_.framer()->SetDecrypter(ENCRYPTION_NONE, new TaggingDecrypter);
-    }
-    EXPECT_TRUE(framer_.ProcessPacket(packet));
-    if (block_on_next_write_) {
-      write_blocked_ = true;
-      block_on_next_write_ = false;
-    }
-    if (next_packet_too_large_) {
-      next_packet_too_large_ = false;
-      return WriteResult(WRITE_STATUS_ERROR, ERR_MSG_TOO_BIG);
-    }
-    if (always_get_packet_too_large_) {
-      LOG(ERROR) << "RETURNING TOO BIG";
-      return WriteResult(WRITE_STATUS_ERROR, ERR_MSG_TOO_BIG);
-    }
-    if (IsWriteBlocked()) {
-      return WriteResult(WRITE_STATUS_BLOCKED, -1);
-    }
-
-    if (ShouldWriteFail()) {
-      return WriteResult(WRITE_STATUS_ERROR, 0);
-    }
-
-    last_packet_size_ = packet.length();
-
-    if (!write_pause_time_delta_.IsZero()) {
-      clock_->AdvanceTime(write_pause_time_delta_);
-    }
-    return WriteResult(WRITE_STATUS_OK, last_packet_size_);
-  }
-
-  bool IsWriteBlockedDataBuffered() const override {
-    return is_write_blocked_data_buffered_;
-  }
-
-  bool ShouldWriteFail() { return write_should_fail_; }
-
-  bool IsWriteBlocked() const override { return write_blocked_; }
-
-  void SetWritable() override { write_blocked_ = false; }
-
-  void SetShouldWriteFail() { write_should_fail_ = true; }
-
-  QuicByteCount GetMaxPacketSize(
-      const IPEndPoint& /*peer_address*/) const override {
-    return max_packet_size_;
-  }
-
-  void BlockOnNextWrite() { block_on_next_write_ = true; }
-
-  void SimulateNextPacketTooLarge() { next_packet_too_large_ = true; }
-
-  void AlwaysGetPacketTooLarge() { always_get_packet_too_large_ = true; }
-
-  // Sets the amount of time that the writer should before the actual write.
-  void SetWritePauseTimeDelta(QuicTime::Delta delta) {
-    write_pause_time_delta_ = delta;
-  }
-
-  const QuicPacketHeader& header() { return framer_.header(); }
-
-  size_t frame_count() const { return framer_.num_frames(); }
-
-  const vector<QuicAckFrame>& ack_frames() const {
-    return framer_.ack_frames();
-  }
-
-  const vector<QuicStopWaitingFrame>& stop_waiting_frames() const {
-    return framer_.stop_waiting_frames();
-  }
-
-  const vector<QuicConnectionCloseFrame>& connection_close_frames() const {
-    return framer_.connection_close_frames();
-  }
-
-  const vector<QuicRstStreamFrame>& rst_stream_frames() const {
-    return framer_.rst_stream_frames();
-  }
-
-  const vector<QuicStreamFrame*>& stream_frames() const {
-    return framer_.stream_frames();
-  }
-
-  const vector<QuicPingFrame>& ping_frames() const {
-    return framer_.ping_frames();
-  }
-
-  size_t last_packet_size() { return last_packet_size_; }
-
-  const QuicVersionNegotiationPacket* version_negotiation_packet() {
-    return framer_.version_negotiation_packet();
-  }
-
-  void set_is_write_blocked_data_buffered(bool buffered) {
-    is_write_blocked_data_buffered_ = buffered;
-  }
-
-  void set_perspective(Perspective perspective) {
-    // We invert perspective here, because the framer needs to parse packets
-    // we send.
-    QuicFramerPeer::SetPerspective(framer_.framer(),
-                                   InvertPerspective(perspective));
-  }
-
-  // final_bytes_of_last_packet_ returns the last four bytes of the previous
-  // packet as a little-endian, uint32_t. This is intended to be used with a
-  // TaggingEncrypter so that tests can determine which encrypter was used for
-  // a given packet.
-  uint32_t final_bytes_of_last_packet() { return final_bytes_of_last_packet_; }
-
-  // Returns the final bytes of the second to last packet.
-  uint32_t final_bytes_of_previous_packet() {
-    return final_bytes_of_previous_packet_;
-  }
-
-  void use_tagging_decrypter() { use_tagging_decrypter_ = true; }
-
-  uint32_t packets_write_attempts() { return packets_write_attempts_; }
-
-  void Reset() { framer_.Reset(); }
-
-  void SetSupportedVersions(const QuicVersionVector& versions) {
-    framer_.SetSupportedVersions(versions);
-  }
-
-  void set_max_packet_size(QuicByteCount max_packet_size) {
-    max_packet_size_ = max_packet_size;
-  }
-
- private:
-  QuicVersion version_;
-  SimpleQuicFramer framer_;
-  size_t last_packet_size_;
-  bool write_blocked_;
-  bool write_should_fail_;
-  bool block_on_next_write_;
-  bool next_packet_too_large_;
-  bool always_get_packet_too_large_;
-  bool is_write_blocked_data_buffered_;
-  uint32_t final_bytes_of_last_packet_;
-  uint32_t final_bytes_of_previous_packet_;
-  bool use_tagging_decrypter_;
-  uint32_t packets_write_attempts_;
-  MockClock* clock_;
-  // If non-zero, the clock will pause during WritePacket for this amount of
-  // time.
-  QuicTime::Delta write_pause_time_delta_;
-  QuicByteCount max_packet_size_;
-
-  DISALLOW_COPY_AND_ASSIGN(TestPacketWriter);
-};
-
-class TestConnection : public QuicConnection {
- public:
-  TestConnection(QuicConnectionId connection_id,
-                 IPEndPoint address,
-                 TestConnectionHelper* helper,
-                 TestAlarmFactory* alarm_factory,
-                 TestPacketWriter* writer,
-                 Perspective perspective,
-                 QuicVersion version)
-      : QuicConnection(connection_id,
-                       address,
-                       helper,
-                       alarm_factory,
-                       writer,
-                       /* owns_writer= */ false,
-                       perspective,
-                       SupportedVersions(version)) {
-    writer->set_perspective(perspective);
-  }
-
-  void SendAck() { QuicConnectionPeer::SendAck(this); }
-
-  void SetSendAlgorithm(QuicPathId path_id,
-                        SendAlgorithmInterface* send_algorithm) {
-    QuicConnectionPeer::SetSendAlgorithm(this, path_id, send_algorithm);
-  }
-
-  void SetLossAlgorithm(QuicPathId path_id,
-                        LossDetectionInterface* loss_algorithm) {
-    QuicConnectionPeer::SetLossAlgorithm(this, path_id, loss_algorithm);
-  }
-
-  void SendPacket(EncryptionLevel level,
-                  QuicPathId path_id,
-                  QuicPacketNumber packet_number,
-                  QuicPacket* packet,
-                  QuicPacketEntropyHash entropy_hash,
-                  HasRetransmittableData retransmittable,
-                  bool has_ack,
-                  bool has_pending_frames) {
-    char buffer[kMaxPacketSize];
-    size_t encrypted_length =
-        QuicConnectionPeer::GetFramer(this)->EncryptPayload(
-            ENCRYPTION_NONE, path_id, packet_number, *packet, buffer,
-            kMaxPacketSize);
-    delete packet;
-    SerializedPacket serialized_packet(
-        kDefaultPathId, packet_number, PACKET_6BYTE_PACKET_NUMBER, buffer,
-        encrypted_length, entropy_hash, has_ack, has_pending_frames);
-    if (retransmittable == HAS_RETRANSMITTABLE_DATA) {
-      serialized_packet.retransmittable_frames.push_back(
-          QuicFrame(new QuicStreamFrame()));
-    }
-    OnSerializedPacket(&serialized_packet);
-  }
-
-  QuicConsumedData SendStreamDataWithString(
-      QuicStreamId id,
-      StringPiece data,
-      QuicStreamOffset offset,
-      bool fin,
-      QuicAckListenerInterface* listener) {
-    struct iovec iov;
-    QuicIOVector data_iov(MakeIOVector(data, &iov));
-    return QuicConnection::SendStreamData(id, data_iov, offset, fin, listener);
-  }
-
-  QuicConsumedData SendStreamData3() {
-    return SendStreamDataWithString(kClientDataStreamId1, "food", 0, !kFin,
-                                    nullptr);
-  }
-
-  QuicConsumedData SendStreamData5() {
-    return SendStreamDataWithString(kClientDataStreamId2, "food2", 0, !kFin,
-                                    nullptr);
-  }
-
-  // Ensures the connection can write stream data before writing.
-  QuicConsumedData EnsureWritableAndSendStreamData5() {
-    EXPECT_TRUE(CanWriteStreamData());
-    return SendStreamData5();
-  }
-
-  // The crypto stream has special semantics so that it is not blocked by a
-  // congestion window limitation, and also so that it gets put into a separate
-  // packet (so that it is easier to reason about a crypto frame not being
-  // split needlessly across packet boundaries).  As a result, we have separate
-  // tests for some cases for this stream.
-  QuicConsumedData SendCryptoStreamData() {
-    return SendStreamDataWithString(kCryptoStreamId, "chlo", 0, !kFin, nullptr);
-  }
-
-  void set_version(QuicVersion version) {
-    QuicConnectionPeer::GetFramer(this)->set_version(version);
-  }
-
-  void SetSupportedVersions(const QuicVersionVector& versions) {
-    QuicConnectionPeer::GetFramer(this)->SetSupportedVersions(versions);
-    writer()->SetSupportedVersions(versions);
-  }
-
-  void set_perspective(Perspective perspective) {
-    writer()->set_perspective(perspective);
-    QuicConnectionPeer::SetPerspective(this, perspective);
-  }
-
-  // Enable path MTU discovery.  Assumes that the test is performed from the
-  // client perspective and the higher value of MTU target is used.
-  void EnablePathMtuDiscovery(MockSendAlgorithm* send_algorithm) {
-    ASSERT_EQ(Perspective::IS_CLIENT, perspective());
-
-    QuicConfig config;
-    QuicTagVector connection_options;
-    connection_options.push_back(kMTUH);
-    config.SetConnectionOptionsToSend(connection_options);
-    EXPECT_CALL(*send_algorithm, SetFromConfig(_, _));
-    SetFromConfig(config);
-
-    // Normally, the pacing would be disabled in the test, but calling
-    // SetFromConfig enables it.  Set nearly-infinite bandwidth to make the
-    // pacing algorithm work.
-    EXPECT_CALL(*send_algorithm, PacingRate(_))
-        .WillRepeatedly(Return(QuicBandwidth::Infinite()));
-  }
-
-  TestAlarmFactory::TestAlarm* GetAckAlarm() {
-    return reinterpret_cast<TestAlarmFactory::TestAlarm*>(
-        QuicConnectionPeer::GetAckAlarm(this));
-  }
-
-  TestAlarmFactory::TestAlarm* GetPingAlarm() {
-    return reinterpret_cast<TestAlarmFactory::TestAlarm*>(
-        QuicConnectionPeer::GetPingAlarm(this));
-  }
-
-  TestAlarmFactory::TestAlarm* GetResumeWritesAlarm() {
-    return reinterpret_cast<TestAlarmFactory::TestAlarm*>(
-        QuicConnectionPeer::GetResumeWritesAlarm(this));
-  }
-
-  TestAlarmFactory::TestAlarm* GetRetransmissionAlarm() {
-    return reinterpret_cast<TestAlarmFactory::TestAlarm*>(
-        QuicConnectionPeer::GetRetransmissionAlarm(this));
-  }
-
-  TestAlarmFactory::TestAlarm* GetSendAlarm() {
-    return reinterpret_cast<TestAlarmFactory::TestAlarm*>(
-        QuicConnectionPeer::GetSendAlarm(this));
-  }
-
-  TestAlarmFactory::TestAlarm* GetTimeoutAlarm() {
-    return reinterpret_cast<TestAlarmFactory::TestAlarm*>(
-        QuicConnectionPeer::GetTimeoutAlarm(this));
-  }
-
-  TestAlarmFactory::TestAlarm* GetMtuDiscoveryAlarm() {
-    return reinterpret_cast<TestAlarmFactory::TestAlarm*>(
-        QuicConnectionPeer::GetMtuDiscoveryAlarm(this));
-  }
-
-  void SetMaxTailLossProbes(QuicPathId path_id, size_t max_tail_loss_probes) {
-    QuicSentPacketManagerPeer::SetMaxTailLossProbes(
-        QuicConnectionPeer::GetSentPacketManager(this, path_id),
-        max_tail_loss_probes);
-  }
-
-  QuicByteCount GetBytesInFlight(QuicPathId path_id) {
-    return QuicSentPacketManagerPeer::GetBytesInFlight(
-        QuicConnectionPeer::GetSentPacketManager(this, path_id));
-  }
-
-  using QuicConnection::SelectMutualVersion;
-  using QuicConnection::set_defer_send_in_response_to_packets;
-
- private:
-  TestPacketWriter* writer() {
-    return static_cast<TestPacketWriter*>(QuicConnection::writer());
-  }
-
-  DISALLOW_COPY_AND_ASSIGN(TestConnection);
-};
-
-enum class AckResponse { kDefer, kImmediate };
-
-// Run tests with combinations of {QuicVersion, AckResponse}.
-struct TestParams {
-  TestParams(QuicVersion version, AckResponse ack_response)
-      : version(version), ack_response(ack_response) {}
-
-  friend ostream& operator<<(ostream& os, const TestParams& p) {
-    os << "{ client_version: " << QuicVersionToString(p.version)
-       << " ack_response: "
-       << (p.ack_response == AckResponse::kDefer ? "defer" : "immediate")
-       << " }";
-    return os;
-  }
-
-  QuicVersion version;
-  AckResponse ack_response;
-};
-
-// Constructs various test permutations.
-vector<TestParams> GetTestParams() {
-  vector<TestParams> params;
-  QuicVersionVector all_supported_versions = AllSupportedVersions();
-  for (size_t i = 0; i < all_supported_versions.size(); ++i) {
-    for (AckResponse ack_response :
-         {AckResponse::kDefer, AckResponse::kImmediate}) {
-      params.push_back(TestParams(all_supported_versions[i], ack_response));
-    }
-  }
-  return params;
-}
-
-class QuicConnectionTest : public ::testing::TestWithParam<TestParams> {
- protected:
-  QuicConnectionTest()
-      : connection_id_(42),
-        framer_(SupportedVersions(version()),
-                QuicTime::Zero(),
-                Perspective::IS_CLIENT),
-        send_algorithm_(new StrictMock<MockSendAlgorithm>),
-        loss_algorithm_(new MockLossAlgorithm()),
-        helper_(new TestConnectionHelper(&clock_, &random_generator_)),
-        alarm_factory_(new TestAlarmFactory()),
-        peer_framer_(SupportedVersions(version()),
-                     QuicTime::Zero(),
-                     Perspective::IS_SERVER),
-        peer_creator_(connection_id_,
-                      &peer_framer_,
-                      &random_generator_,
-                      &buffer_allocator_,
-                      /*delegate=*/nullptr),
-        writer_(new TestPacketWriter(version(), &clock_)),
-        connection_(connection_id_,
-                    kPeerAddress,
-                    helper_.get(),
-                    alarm_factory_.get(),
-                    writer_.get(),
-                    Perspective::IS_CLIENT,
-                    version()),
-        creator_(QuicConnectionPeer::GetPacketCreator(&connection_)),
-        generator_(QuicConnectionPeer::GetPacketGenerator(&connection_)),
-        manager_(QuicConnectionPeer::GetSentPacketManager(&connection_,
-                                                          kDefaultPathId)),
-        frame1_(1, false, 0, StringPiece(data1)),
-        frame2_(1, false, 3, StringPiece(data2)),
-        packet_number_length_(PACKET_6BYTE_PACKET_NUMBER),
-        connection_id_length_(PACKET_8BYTE_CONNECTION_ID) {
-    connection_.set_defer_send_in_response_to_packets(GetParam().ack_response ==
-                                                      AckResponse::kDefer);
-    connection_.set_visitor(&visitor_);
-    connection_.SetSendAlgorithm(kDefaultPathId, send_algorithm_);
-    connection_.SetLossAlgorithm(kDefaultPathId, loss_algorithm_.get());
-    framer_.set_received_entropy_calculator(&entropy_calculator_);
-    peer_framer_.set_received_entropy_calculator(&peer_entropy_calculator_);
-    EXPECT_CALL(*send_algorithm_, TimeUntilSend(_, _))
-        .WillRepeatedly(Return(QuicTime::Delta::Zero()));
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-        .Times(AnyNumber());
-    EXPECT_CALL(*send_algorithm_, RetransmissionDelay())
-        .WillRepeatedly(Return(QuicTime::Delta::Zero()));
-    EXPECT_CALL(*send_algorithm_, GetCongestionWindow())
-        .WillRepeatedly(Return(kDefaultTCPMSS));
-    EXPECT_CALL(*send_algorithm_, PacingRate(_))
-        .WillRepeatedly(Return(QuicBandwidth::Zero()));
-    ON_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-        .WillByDefault(Return(true));
-    EXPECT_CALL(*send_algorithm_, HasReliableBandwidthEstimate())
-        .Times(AnyNumber());
-    EXPECT_CALL(*send_algorithm_, BandwidthEstimate())
-        .Times(AnyNumber())
-        .WillRepeatedly(Return(QuicBandwidth::Zero()));
-    EXPECT_CALL(*send_algorithm_, InSlowStart()).Times(AnyNumber());
-    EXPECT_CALL(*send_algorithm_, InRecovery()).Times(AnyNumber());
-    EXPECT_CALL(*send_algorithm_, OnApplicationLimited(_)).Times(AnyNumber());
-    EXPECT_CALL(visitor_, WillingAndAbleToWrite()).Times(AnyNumber());
-    EXPECT_CALL(visitor_, HasPendingHandshake()).Times(AnyNumber());
-    EXPECT_CALL(visitor_, OnCanWrite()).Times(AnyNumber());
-    EXPECT_CALL(visitor_, PostProcessAfterData()).Times(AnyNumber());
-    EXPECT_CALL(visitor_, HasOpenDynamicStreams())
-        .WillRepeatedly(Return(false));
-    EXPECT_CALL(visitor_, OnCongestionWindowChange(_)).Times(AnyNumber());
-
-    EXPECT_CALL(*loss_algorithm_, GetLossTimeout())
-        .WillRepeatedly(Return(QuicTime::Zero()));
-    EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _))
-        .Times(AnyNumber());
-    // TODO(ianswett): Fix QuicConnectionTests so they don't attempt to write
-    // non-crypto stream data at ENCRYPTION_NONE.
-    FLAGS_quic_never_write_unencrypted_data = false;
-  }
-
-  QuicVersion version() { return GetParam().version; }
-
-  QuicAckFrame* outgoing_ack() {
-    QuicFrame ack_frame = QuicConnectionPeer::GetUpdatedAckFrame(&connection_);
-    ack_ = *ack_frame.ack_frame;
-    return &ack_;
-  }
-
-  QuicStopWaitingFrame* stop_waiting() {
-    QuicConnectionPeer::PopulateStopWaitingFrame(&connection_, &stop_waiting_);
-    return &stop_waiting_;
-  }
-
-  QuicPacketNumber least_unacked() {
-    if (writer_->stop_waiting_frames().empty()) {
-      return 0;
-    }
-    return writer_->stop_waiting_frames()[0].least_unacked;
-  }
-
-  void use_tagging_decrypter() { writer_->use_tagging_decrypter(); }
-
-  void ProcessPacket(QuicPathId path_id, QuicPacketNumber number) {
-    EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-    ProcessDataPacket(path_id, number, !kEntropyFlag);
-    if (connection_.GetSendAlarm()->IsSet()) {
-      connection_.GetSendAlarm()->Fire();
-    }
-  }
-
-  QuicPacketEntropyHash ProcessFramePacket(QuicFrame frame) {
-    return ProcessFramePacketWithAddresses(frame, kSelfAddress, kPeerAddress);
-  }
-
-  QuicPacketEntropyHash ProcessFramePacketWithAddresses(
-      QuicFrame frame,
-      IPEndPoint self_address,
-      IPEndPoint peer_address) {
-    QuicFrames frames;
-    frames.push_back(QuicFrame(frame));
-    QuicPacketCreatorPeer::SetSendVersionInPacket(
-        &peer_creator_, connection_.perspective() == Perspective::IS_SERVER);
-
-    char buffer[kMaxPacketSize];
-    SerializedPacket serialized_packet =
-        QuicPacketCreatorPeer::SerializeAllFrames(&peer_creator_, frames,
-                                                  buffer, kMaxPacketSize);
-    connection_.ProcessUdpPacket(
-        self_address, peer_address,
-        QuicReceivedPacket(serialized_packet.encrypted_buffer,
-                           serialized_packet.encrypted_length, clock_.Now()));
-    if (connection_.GetSendAlarm()->IsSet()) {
-      connection_.GetSendAlarm()->Fire();
-    }
-    return serialized_packet.entropy_hash;
-  }
-
-  QuicPacketEntropyHash ProcessFramePacketAtLevel(QuicPathId path_id,
-                                                  QuicPacketNumber number,
-                                                  QuicFrame frame,
-                                                  EncryptionLevel level) {
-    QuicPacketHeader header;
-    header.public_header.connection_id = connection_id_;
-    header.public_header.packet_number_length = packet_number_length_;
-    header.public_header.connection_id_length = connection_id_length_;
-    header.public_header.multipath_flag = path_id != kDefaultPathId;
-    header.path_id = path_id;
-    header.packet_number = number;
-    QuicFrames frames;
-    frames.push_back(frame);
-    std::unique_ptr<QuicPacket> packet(ConstructPacket(header, frames));
-
-    char buffer[kMaxPacketSize];
-    size_t encrypted_length = framer_.EncryptPayload(
-        level, path_id, number, *packet, buffer, kMaxPacketSize);
-    connection_.ProcessUdpPacket(
-        kSelfAddress, kPeerAddress,
-        QuicReceivedPacket(buffer, encrypted_length, QuicTime::Zero(), false));
-    return base::checked_cast<QuicPacketEntropyHash>(encrypted_length);
-  }
-
-  size_t ProcessDataPacket(QuicPathId path_id,
-                           QuicPacketNumber number,
-                           bool entropy_flag) {
-    return ProcessDataPacketAtLevel(path_id, number, entropy_flag, false,
-                                    ENCRYPTION_NONE);
-  }
-
-  size_t ProcessDataPacketAtLevel(QuicPathId path_id,
-                                  QuicPacketNumber number,
-                                  bool entropy_flag,
-                                  bool has_stop_waiting,
-                                  EncryptionLevel level) {
-    std::unique_ptr<QuicPacket> packet(
-        ConstructDataPacket(path_id, number, entropy_flag, has_stop_waiting));
-    char buffer[kMaxPacketSize];
-    size_t encrypted_length = framer_.EncryptPayload(
-        level, path_id, number, *packet, buffer, kMaxPacketSize);
-    connection_.ProcessUdpPacket(
-        kSelfAddress, kPeerAddress,
-        QuicReceivedPacket(buffer, encrypted_length, clock_.Now(), false));
-    if (connection_.GetSendAlarm()->IsSet()) {
-      connection_.GetSendAlarm()->Fire();
-    }
-    return encrypted_length;
-  }
-
-  void ProcessClosePacket(QuicPathId path_id, QuicPacketNumber number) {
-    std::unique_ptr<QuicPacket> packet(ConstructClosePacket(number));
-    char buffer[kMaxPacketSize];
-    size_t encrypted_length = framer_.EncryptPayload(
-        ENCRYPTION_NONE, path_id, number, *packet, buffer, kMaxPacketSize);
-    connection_.ProcessUdpPacket(
-        kSelfAddress, kPeerAddress,
-        QuicReceivedPacket(buffer, encrypted_length, QuicTime::Zero(), false));
-  }
-
-  QuicByteCount SendStreamDataToPeer(QuicStreamId id,
-                                     StringPiece data,
-                                     QuicStreamOffset offset,
-                                     bool fin,
-                                     QuicPacketNumber* last_packet) {
-    QuicByteCount packet_size;
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-        .WillOnce(DoAll(SaveArg<3>(&packet_size), Return(true)));
-    connection_.SendStreamDataWithString(id, data, offset, fin, nullptr);
-    if (last_packet != nullptr) {
-      *last_packet = creator_->packet_number();
-    }
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-        .Times(AnyNumber());
-    return packet_size;
-  }
-
-  void SendAckPacketToPeer() {
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-    connection_.SendAck();
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-        .Times(AnyNumber());
-  }
-
-  void ProcessAckPacket(QuicPacketNumber packet_number, QuicAckFrame* frame) {
-    QuicPacketCreatorPeer::SetPacketNumber(&peer_creator_, packet_number - 1);
-    ProcessFramePacket(QuicFrame(frame));
-  }
-
-  QuicPacketEntropyHash ProcessAckPacket(QuicAckFrame* frame) {
-    return ProcessFramePacket(QuicFrame(frame));
-  }
-
-  QuicPacketEntropyHash ProcessStopWaitingPacket(QuicStopWaitingFrame* frame) {
-    return ProcessFramePacket(QuicFrame(frame));
-  }
-
-  QuicPacketEntropyHash ProcessStopWaitingPacketAtLevel(
-      QuicPathId path_id,
-      QuicPacketNumber number,
-      QuicStopWaitingFrame* frame,
-      EncryptionLevel level) {
-    return ProcessFramePacketAtLevel(path_id, number, QuicFrame(frame),
-                                     ENCRYPTION_INITIAL);
-  }
-
-  QuicPacketEntropyHash ProcessGoAwayPacket(QuicGoAwayFrame* frame) {
-    return ProcessFramePacket(QuicFrame(frame));
-  }
-
-  QuicPacketEntropyHash ProcessPathClosePacket(QuicPathCloseFrame* frame) {
-    return ProcessFramePacket(QuicFrame(frame));
-  }
-
-  bool IsMissing(QuicPacketNumber number) {
-    return IsAwaitingPacket(*outgoing_ack(), number, 0);
-  }
-
-  QuicPacket* ConstructPacket(QuicPacketHeader header, QuicFrames frames) {
-    QuicPacket* packet = BuildUnsizedDataPacket(&peer_framer_, header, frames);
-    EXPECT_NE(nullptr, packet);
-    return packet;
-  }
-
-  QuicPacket* ConstructDataPacket(QuicPathId path_id,
-                                  QuicPacketNumber number,
-                                  bool entropy_flag,
-                                  bool has_stop_waiting) {
-    QuicPacketHeader header;
-    header.public_header.connection_id = connection_id_;
-    header.public_header.packet_number_length = packet_number_length_;
-    header.public_header.connection_id_length = connection_id_length_;
-    header.public_header.multipath_flag = path_id != kDefaultPathId;
-    header.entropy_flag = entropy_flag;
-    header.path_id = path_id;
-    header.packet_number = number;
-
-    QuicFrames frames;
-    frames.push_back(QuicFrame(&frame1_));
-    if (has_stop_waiting) {
-      frames.push_back(QuicFrame(&stop_waiting_));
-    }
-    return ConstructPacket(header, frames);
-  }
-
-  QuicPacket* ConstructClosePacket(QuicPacketNumber number) {
-    QuicPacketHeader header;
-    header.public_header.connection_id = connection_id_;
-    header.packet_number = number;
-
-    QuicConnectionCloseFrame qccf;
-    qccf.error_code = QUIC_PEER_GOING_AWAY;
-
-    QuicFrames frames;
-    frames.push_back(QuicFrame(&qccf));
-    return ConstructPacket(header, frames);
-  }
-
-  QuicTime::Delta DefaultRetransmissionTime() {
-    return QuicTime::Delta::FromMilliseconds(kDefaultRetransmissionTimeMs);
-  }
-
-  QuicTime::Delta DefaultDelayedAckTime() {
-    return QuicTime::Delta::FromMilliseconds(kMaxDelayedAckTimeMs);
-  }
-
-  // Initialize a frame acknowledging all packets up to largest_observed.
-  const QuicAckFrame InitAckFrame(QuicPacketNumber largest_observed) {
-    QuicAckFrame frame(MakeAckFrame(largest_observed));
-    if (GetParam().version <= QUIC_VERSION_33) {
-      if (largest_observed > 0) {
-        frame.entropy_hash = QuicConnectionPeer::GetSentEntropyHash(
-            &connection_, largest_observed);
-      }
-    } else {
-      frame.missing = false;
-      if (largest_observed > 0) {
-        frame.packets.Add(1, largest_observed + 1);
-      }
-    }
-    return frame;
-  }
-
-  const QuicStopWaitingFrame InitStopWaitingFrame(
-      QuicPacketNumber least_unacked) {
-    QuicStopWaitingFrame frame;
-    frame.least_unacked = least_unacked;
-    return frame;
-  }
-
-  // Explicitly nack a packet.
-  void NackPacket(QuicPacketNumber missing, QuicAckFrame* frame) {
-    if (frame->missing) {
-      frame->packets.Add(missing);
-      frame->entropy_hash ^=
-          QuicConnectionPeer::PacketEntropy(&connection_, missing);
-    } else {
-      frame->packets.Remove(missing);
-    }
-  }
-
-  // Undo nacking a packet within the frame.
-  void AckPacket(QuicPacketNumber arrived, QuicAckFrame* frame) {
-    if (frame->missing) {
-      EXPECT_TRUE(frame->packets.Contains(arrived));
-      frame->packets.Remove(arrived);
-      frame->entropy_hash ^=
-          QuicConnectionPeer::PacketEntropy(&connection_, arrived);
-    } else {
-      EXPECT_FALSE(frame->packets.Contains(arrived));
-      frame->packets.Add(arrived);
-    }
-  }
-
-  void TriggerConnectionClose() {
-    // Send an erroneous packet to close the connection.
-    EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_INVALID_PACKET_HEADER, _,
-                                             ConnectionCloseSource::FROM_SELF));
-    // Call ProcessDataPacket rather than ProcessPacket, as we should not get a
-    // packet call to the visitor.
-    ProcessDataPacket(kDefaultPathId, 6000, !kEntropyFlag);
-    EXPECT_FALSE(QuicConnectionPeer::GetConnectionClosePacket(&connection_) ==
-                 nullptr);
-  }
-
-  void BlockOnNextWrite() {
-    writer_->BlockOnNextWrite();
-    EXPECT_CALL(visitor_, OnWriteBlocked()).Times(AtLeast(1));
-  }
-
-  void SimulateNextPacketTooLarge() { writer_->SimulateNextPacketTooLarge(); }
-
-  void AlwaysGetPacketTooLarge() { writer_->AlwaysGetPacketTooLarge(); }
-
-  void SetWritePauseTimeDelta(QuicTime::Delta delta) {
-    writer_->SetWritePauseTimeDelta(delta);
-  }
-
-  void CongestionBlockWrites() {
-    EXPECT_CALL(*send_algorithm_, TimeUntilSend(_, _))
-        .WillRepeatedly(testing::Return(QuicTime::Delta::FromSeconds(1)));
-  }
-
-  void CongestionUnblockWrites() {
-    EXPECT_CALL(*send_algorithm_, TimeUntilSend(_, _))
-        .WillRepeatedly(testing::Return(QuicTime::Delta::Zero()));
-  }
-
-  void set_perspective(Perspective perspective) {
-    connection_.set_perspective(perspective);
-    QuicFramerPeer::SetPerspective(&peer_framer_,
-                                   InvertPerspective(perspective));
-  }
-
-  QuicFlagSaver flags_;  // Save/restore all QUIC flag values.
-
-  QuicConnectionId connection_id_;
-  QuicFramer framer_;
-  MockEntropyCalculator entropy_calculator_;
-  MockEntropyCalculator peer_entropy_calculator_;
-
-  MockSendAlgorithm* send_algorithm_;
-  std::unique_ptr<MockLossAlgorithm> loss_algorithm_;
-  MockClock clock_;
-  MockRandom random_generator_;
-  SimpleBufferAllocator buffer_allocator_;
-  std::unique_ptr<TestConnectionHelper> helper_;
-  std::unique_ptr<TestAlarmFactory> alarm_factory_;
-  QuicFramer peer_framer_;
-  QuicPacketCreator peer_creator_;
-  std::unique_ptr<TestPacketWriter> writer_;
-  TestConnection connection_;
-  QuicPacketCreator* creator_;
-  QuicPacketGenerator* generator_;
-  QuicSentPacketManagerInterface* manager_;
-  StrictMock<MockQuicConnectionVisitor> visitor_;
-
-  QuicStreamFrame frame1_;
-  QuicStreamFrame frame2_;
-  QuicAckFrame ack_;
-  QuicStopWaitingFrame stop_waiting_;
-  QuicPacketNumberLength packet_number_length_;
-  QuicConnectionIdLength connection_id_length_;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(QuicConnectionTest);
-};
-
-// Run all end to end tests with all supported versions.
-INSTANTIATE_TEST_CASE_P(SupportedVersion,
-                        QuicConnectionTest,
-                        ::testing::ValuesIn(GetTestParams()));
-
-TEST_P(QuicConnectionTest, SelfAddressChangeAtClient) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  EXPECT_EQ(Perspective::IS_CLIENT, connection_.perspective());
-  EXPECT_TRUE(connection_.connected());
-
-  QuicStreamFrame stream_frame(1u, false, 0u, StringPiece());
-  EXPECT_CALL(visitor_, OnStreamFrame(_));
-  ProcessFramePacketWithAddresses(QuicFrame(&stream_frame), kSelfAddress,
-                                  kPeerAddress);
-  // Cause change in self_address.
-  IPEndPoint self_address(IPAddress(1, 1, 1, 1), 123);
-  EXPECT_CALL(visitor_, OnStreamFrame(_));
-  ProcessFramePacketWithAddresses(QuicFrame(&stream_frame), self_address,
-                                  kPeerAddress);
-  EXPECT_TRUE(connection_.connected());
-}
-
-TEST_P(QuicConnectionTest, SelfAddressChangeAtServer) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  set_perspective(Perspective::IS_SERVER);
-  QuicPacketCreatorPeer::SetSendVersionInPacket(creator_, false);
-
-  EXPECT_EQ(Perspective::IS_SERVER, connection_.perspective());
-  EXPECT_TRUE(connection_.connected());
-
-  QuicStreamFrame stream_frame(1u, false, 0u, StringPiece());
-  EXPECT_CALL(visitor_, OnStreamFrame(_));
-  ProcessFramePacketWithAddresses(QuicFrame(&stream_frame), kSelfAddress,
-                                  kPeerAddress);
-  // Cause change in self_address.
-  IPEndPoint self_address(IPAddress(1, 1, 1, 1), 123);
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_ERROR_MIGRATING_ADDRESS, _, _));
-  ProcessFramePacketWithAddresses(QuicFrame(&stream_frame), self_address,
-                                  kPeerAddress);
-  EXPECT_FALSE(connection_.connected());
-}
-
-TEST_P(QuicConnectionTest, AllowSelfAddressChangeToMappedIpv4AddressAtServer) {
-  FLAGS_quic_allow_server_address_change_for_mapped_ipv4 = true;
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  set_perspective(Perspective::IS_SERVER);
-  QuicPacketCreatorPeer::SetSendVersionInPacket(creator_, false);
-
-  EXPECT_EQ(Perspective::IS_SERVER, connection_.perspective());
-  EXPECT_TRUE(connection_.connected());
-
-  QuicStreamFrame stream_frame(1u, false, 0u, StringPiece());
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(3);
-  IPEndPoint self_address1(IPAddress(1, 1, 1, 1), 443);
-  ProcessFramePacketWithAddresses(QuicFrame(&stream_frame), self_address1,
-                                  kPeerAddress);
-  // Cause self_address change to mapped Ipv4 address.
-  IPEndPoint self_address2(ConvertIPv4ToIPv4MappedIPv6(self_address1.address()),
-                           443);
-  ProcessFramePacketWithAddresses(QuicFrame(&stream_frame), self_address2,
-                                  kPeerAddress);
-  EXPECT_TRUE(connection_.connected());
-  // self_address change back to Ipv4 address.
-  ProcessFramePacketWithAddresses(QuicFrame(&stream_frame), self_address1,
-                                  kPeerAddress);
-  EXPECT_TRUE(connection_.connected());
-}
-
-TEST_P(QuicConnectionTest, ClientAddressChangeAndPacketReordered) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  set_perspective(Perspective::IS_SERVER);
-  QuicPacketCreatorPeer::SetSendVersionInPacket(creator_, false);
-  // Clear peer address.
-  QuicConnectionPeer::SetPeerAddress(&connection_, IPEndPoint());
-
-  QuicPacketCreatorPeer::SetPacketNumber(&peer_creator_, 5);
-  QuicStreamFrame stream_frame(1u, false, 0u, StringPiece());
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(AnyNumber());
-  const IPEndPoint kNewPeerAddress = IPEndPoint(Loopback6(),
-                                                /*port=*/23456);
-  ProcessFramePacketWithAddresses(QuicFrame(&stream_frame), kSelfAddress,
-                                  kNewPeerAddress);
-
-  // Decrease packet number to simulate out-of-order packets.
-  QuicPacketCreatorPeer::SetPacketNumber(&peer_creator_, 4);
-  // This is an old packet, do not migrate.
-  EXPECT_CALL(visitor_, OnConnectionMigration(PORT_CHANGE)).Times(0);
-  ProcessFramePacketWithAddresses(QuicFrame(&stream_frame), kSelfAddress,
-                                  kPeerAddress);
-}
-
-TEST_P(QuicConnectionTest, MaxPacketSize) {
-  EXPECT_EQ(Perspective::IS_CLIENT, connection_.perspective());
-  EXPECT_EQ(1350u, connection_.max_packet_length());
-}
-
-TEST_P(QuicConnectionTest, SmallerServerMaxPacketSize) {
-  QuicConnectionId connection_id = 42;
-  TestConnection connection(connection_id, kPeerAddress, helper_.get(),
-                            alarm_factory_.get(), writer_.get(),
-                            Perspective::IS_SERVER, version());
-  EXPECT_EQ(Perspective::IS_SERVER, connection.perspective());
-  EXPECT_EQ(1000u, connection.max_packet_length());
-}
-
-TEST_P(QuicConnectionTest, IncreaseServerMaxPacketSize) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  set_perspective(Perspective::IS_SERVER);
-  connection_.SetMaxPacketLength(1000);
-
-  QuicPacketHeader header;
-  header.public_header.connection_id = connection_id_;
-  header.public_header.version_flag = true;
-  header.path_id = kDefaultPathId;
-  header.packet_number = 1;
-
-  QuicFrames frames;
-  QuicPaddingFrame padding;
-  frames.push_back(QuicFrame(&frame1_));
-  frames.push_back(QuicFrame(padding));
-  std::unique_ptr<QuicPacket> packet(ConstructPacket(header, frames));
-  char buffer[kMaxPacketSize];
-  size_t encrypted_length = framer_.EncryptPayload(
-      ENCRYPTION_NONE, kDefaultPathId, 12, *packet, buffer, kMaxPacketSize);
-  EXPECT_EQ(kMaxPacketSize, encrypted_length);
-
-  framer_.set_version(version());
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  connection_.ProcessUdpPacket(
-      kSelfAddress, kPeerAddress,
-      QuicReceivedPacket(buffer, encrypted_length, QuicTime::Zero(), false));
-
-  EXPECT_EQ(kMaxPacketSize, connection_.max_packet_length());
-}
-
-TEST_P(QuicConnectionTest, IncreaseServerMaxPacketSizeWhileWriterLimited) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  const QuicByteCount lower_max_packet_size = 1240;
-  writer_->set_max_packet_size(lower_max_packet_size);
-  set_perspective(Perspective::IS_SERVER);
-  connection_.SetMaxPacketLength(1000);
-  EXPECT_EQ(1000u, connection_.max_packet_length());
-
-  QuicPacketHeader header;
-  header.public_header.connection_id = connection_id_;
-  header.public_header.version_flag = true;
-  header.path_id = kDefaultPathId;
-  header.packet_number = 1;
-
-  QuicFrames frames;
-  QuicPaddingFrame padding;
-  frames.push_back(QuicFrame(&frame1_));
-  frames.push_back(QuicFrame(padding));
-  std::unique_ptr<QuicPacket> packet(ConstructPacket(header, frames));
-  char buffer[kMaxPacketSize];
-  size_t encrypted_length = framer_.EncryptPayload(
-      ENCRYPTION_NONE, kDefaultPathId, 12, *packet, buffer, kMaxPacketSize);
-  EXPECT_EQ(kMaxPacketSize, encrypted_length);
-
-  framer_.set_version(version());
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  connection_.ProcessUdpPacket(
-      kSelfAddress, kPeerAddress,
-      QuicReceivedPacket(buffer, encrypted_length, QuicTime::Zero(), false));
-
-  // Here, the limit imposed by the writer is lower than the size of the packet
-  // received, so the writer max packet size is used.
-  EXPECT_EQ(lower_max_packet_size, connection_.max_packet_length());
-}
-
-TEST_P(QuicConnectionTest, LimitMaxPacketSizeByWriter) {
-  const QuicByteCount lower_max_packet_size = 1240;
-  writer_->set_max_packet_size(lower_max_packet_size);
-
-  static_assert(lower_max_packet_size < kDefaultMaxPacketSize,
-                "Default maximum packet size is too low");
-  connection_.SetMaxPacketLength(kDefaultMaxPacketSize);
-
-  EXPECT_EQ(lower_max_packet_size, connection_.max_packet_length());
-}
-
-TEST_P(QuicConnectionTest, LimitMaxPacketSizeByWriterForNewConnection) {
-  const QuicConnectionId connection_id = 17;
-  const QuicByteCount lower_max_packet_size = 1240;
-  writer_->set_max_packet_size(lower_max_packet_size);
-  TestConnection connection(connection_id, kPeerAddress, helper_.get(),
-                            alarm_factory_.get(), writer_.get(),
-                            Perspective::IS_CLIENT, version());
-  EXPECT_EQ(Perspective::IS_CLIENT, connection.perspective());
-  EXPECT_EQ(lower_max_packet_size, connection.max_packet_length());
-}
-
-TEST_P(QuicConnectionTest, PacketsInOrder) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  ProcessPacket(kDefaultPathId, 1);
-  EXPECT_EQ(1u, outgoing_ack()->largest_observed);
-  if (outgoing_ack()->missing) {
-    EXPECT_TRUE(outgoing_ack()->packets.Empty());
-  } else {
-    EXPECT_EQ(1u, outgoing_ack()->packets.NumIntervals());
-  }
-
-  ProcessPacket(kDefaultPathId, 2);
-  EXPECT_EQ(2u, outgoing_ack()->largest_observed);
-  if (outgoing_ack()->missing) {
-    EXPECT_TRUE(outgoing_ack()->packets.Empty());
-  } else {
-    EXPECT_EQ(1u, outgoing_ack()->packets.NumIntervals());
-  }
-
-  ProcessPacket(kDefaultPathId, 3);
-  EXPECT_EQ(3u, outgoing_ack()->largest_observed);
-  if (outgoing_ack()->missing) {
-    EXPECT_TRUE(outgoing_ack()->packets.Empty());
-  } else {
-    EXPECT_EQ(1u, outgoing_ack()->packets.NumIntervals());
-  }
-}
-
-TEST_P(QuicConnectionTest, PacketsOutOfOrder) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  ProcessPacket(kDefaultPathId, 3);
-  EXPECT_EQ(3u, outgoing_ack()->largest_observed);
-  EXPECT_TRUE(IsMissing(2));
-  EXPECT_TRUE(IsMissing(1));
-
-  ProcessPacket(kDefaultPathId, 2);
-  EXPECT_EQ(3u, outgoing_ack()->largest_observed);
-  EXPECT_FALSE(IsMissing(2));
-  EXPECT_TRUE(IsMissing(1));
-
-  ProcessPacket(kDefaultPathId, 1);
-  EXPECT_EQ(3u, outgoing_ack()->largest_observed);
-  EXPECT_FALSE(IsMissing(2));
-  EXPECT_FALSE(IsMissing(1));
-}
-
-TEST_P(QuicConnectionTest, DuplicatePacket) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  ProcessPacket(kDefaultPathId, 3);
-  EXPECT_EQ(3u, outgoing_ack()->largest_observed);
-  EXPECT_TRUE(IsMissing(2));
-  EXPECT_TRUE(IsMissing(1));
-
-  // Send packet 3 again, but do not set the expectation that
-  // the visitor OnStreamFrame() will be called.
-  ProcessDataPacket(kDefaultPathId, 3, !kEntropyFlag);
-  EXPECT_EQ(3u, outgoing_ack()->largest_observed);
-  EXPECT_TRUE(IsMissing(2));
-  EXPECT_TRUE(IsMissing(1));
-}
-
-TEST_P(QuicConnectionTest, PacketsOutOfOrderWithAdditionsAndLeastAwaiting) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  ProcessPacket(kDefaultPathId, 3);
-  EXPECT_EQ(3u, outgoing_ack()->largest_observed);
-  EXPECT_TRUE(IsMissing(2));
-  EXPECT_TRUE(IsMissing(1));
-
-  ProcessPacket(kDefaultPathId, 2);
-  EXPECT_EQ(3u, outgoing_ack()->largest_observed);
-  EXPECT_TRUE(IsMissing(1));
-
-  ProcessPacket(kDefaultPathId, 5);
-  EXPECT_EQ(5u, outgoing_ack()->largest_observed);
-  EXPECT_TRUE(IsMissing(1));
-  EXPECT_TRUE(IsMissing(4));
-
-  // Pretend at this point the client has gotten acks for 2 and 3 and 1 is a
-  // packet the peer will not retransmit.  It indicates this by sending 'least
-  // awaiting' is 4.  The connection should then realize 1 will not be
-  // retransmitted, and will remove it from the missing list.
-  QuicAckFrame frame = InitAckFrame(1);
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(_, _, _, _));
-  ProcessAckPacket(6, &frame);
-
-  // Force an ack to be sent.
-  SendAckPacketToPeer();
-  EXPECT_TRUE(IsMissing(4));
-}
-
-TEST_P(QuicConnectionTest, RejectPacketTooFarOut) {
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_INVALID_PACKET_HEADER, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  // Call ProcessDataPacket rather than ProcessPacket, as we should not get a
-  // packet call to the visitor.
-  ProcessDataPacket(kDefaultPathId, 6000, !kEntropyFlag);
-  EXPECT_FALSE(QuicConnectionPeer::GetConnectionClosePacket(&connection_) ==
-               nullptr);
-}
-
-TEST_P(QuicConnectionTest, RejectUnencryptedStreamData) {
-  // Process an unencrypted packet from the non-crypto stream.
-  frame1_.stream_id = 3;
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_UNENCRYPTED_STREAM_DATA, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  EXPECT_QUIC_BUG(ProcessDataPacket(kDefaultPathId, 1, !kEntropyFlag), "");
-  EXPECT_FALSE(QuicConnectionPeer::GetConnectionClosePacket(&connection_) ==
-               nullptr);
-  const vector<QuicConnectionCloseFrame>& connection_close_frames =
-      writer_->connection_close_frames();
-  EXPECT_EQ(1u, connection_close_frames.size());
-  EXPECT_EQ(QUIC_UNENCRYPTED_STREAM_DATA,
-            connection_close_frames[0].error_code);
-}
-
-TEST_P(QuicConnectionTest, TruncatedAck) {
-  if (GetParam().version > QUIC_VERSION_33) {
-    return;
-  }
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  QuicPacketNumber num_packets = 256 * 2 + 1;
-  for (QuicPacketNumber i = 0; i < num_packets; ++i) {
-    SendStreamDataToPeer(3, "foo", i * 3, !kFin, nullptr);
-  }
-
-  QuicAckFrame frame = InitAckFrame(num_packets);
-  // Create an ack with 256 nacks, none adjacent to one another.
-  for (QuicPacketNumber i = 1; i <= 256; ++i) {
-    NackPacket(i * 2, &frame);
-  }
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _));
-  EXPECT_CALL(peer_entropy_calculator_, EntropyHash(511))
-      .WillOnce(Return(static_cast<QuicPacketEntropyHash>(0)));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&frame);
-
-  // A truncated ack will not have the true largest observed.
-  EXPECT_GT(num_packets, manager_->GetLargestObserved(frame.path_id));
-
-  AckPacket(192, &frame);
-
-  // Removing one missing packet allows us to ack 192 and one more range, but
-  // 192 has already been declared lost, so it doesn't register as an ack.
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&frame);
-  EXPECT_EQ(num_packets, manager_->GetLargestObserved(frame.path_id));
-}
-
-TEST_P(QuicConnectionTest, AckReceiptCausesAckSendBadEntropy) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  ProcessPacket(kDefaultPathId, 1);
-  // Delay sending, then queue up an ack.
-  QuicConnectionPeer::SendAck(&connection_);
-
-  // Process an ack with a least unacked of the received ack.
-  // This causes an ack to be sent when TimeUntilSend returns 0.
-  EXPECT_CALL(*send_algorithm_, TimeUntilSend(_, _))
-      .WillRepeatedly(testing::Return(QuicTime::Delta::Zero()));
-  // Skip a packet and then record an ack.
-  QuicAckFrame frame = InitAckFrame(0);
-  ProcessAckPacket(3, &frame);
-}
-
-TEST_P(QuicConnectionTest, OutOfOrderReceiptCausesAckSend) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  ProcessPacket(kDefaultPathId, 3);
-  // Should ack immediately since we have missing packets.
-  EXPECT_EQ(1u, writer_->packets_write_attempts());
-
-  ProcessPacket(kDefaultPathId, 2);
-  // Should ack immediately since we have missing packets.
-  EXPECT_EQ(2u, writer_->packets_write_attempts());
-
-  ProcessPacket(kDefaultPathId, 1);
-  // Should ack immediately, since this fills the last hole.
-  EXPECT_EQ(3u, writer_->packets_write_attempts());
-
-  ProcessPacket(kDefaultPathId, 4);
-  // Should not cause an ack.
-  EXPECT_EQ(3u, writer_->packets_write_attempts());
-}
-
-TEST_P(QuicConnectionTest, OutOfOrderAckReceiptCausesNoAck) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  SendStreamDataToPeer(1, "foo", 0, !kFin, nullptr);
-  SendStreamDataToPeer(1, "bar", 3, !kFin, nullptr);
-  EXPECT_EQ(2u, writer_->packets_write_attempts());
-
-  QuicAckFrame ack1 = InitAckFrame(1);
-  QuicAckFrame ack2 = InitAckFrame(2);
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(2, &ack2);
-  // Should ack immediately since we have missing packets.
-  EXPECT_EQ(2u, writer_->packets_write_attempts());
-
-  ProcessAckPacket(1, &ack1);
-  // Should not ack an ack filling a missing packet.
-  EXPECT_EQ(2u, writer_->packets_write_attempts());
-}
-
-TEST_P(QuicConnectionTest, AckReceiptCausesAckSend) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  QuicPacketNumber original;
-  QuicByteCount packet_size;
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillOnce(
-          DoAll(SaveArg<2>(&original), SaveArg<3>(&packet_size), Return(true)));
-  connection_.SendStreamDataWithString(3, "foo", 0, !kFin, nullptr);
-  QuicAckFrame frame = InitAckFrame(original);
-  NackPacket(original, &frame);
-  // First nack triggers early retransmit.
-  SendAlgorithmInterface::CongestionVector lost_packets;
-  lost_packets.push_back(std::make_pair(1, kMaxPacketSize));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _))
-      .WillOnce(SetArgPointee<4>(lost_packets));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  QuicPacketNumber retransmission;
-  EXPECT_CALL(*send_algorithm_,
-              OnPacketSent(_, _, _, packet_size - kQuicVersionSize, _))
-      .WillOnce(DoAll(SaveArg<2>(&retransmission), Return(true)));
-
-  ProcessAckPacket(&frame);
-
-  QuicAckFrame frame2 = InitAckFrame(retransmission);
-  NackPacket(original, &frame2);
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _));
-  ProcessAckPacket(&frame2);
-
-  // Now if the peer sends an ack which still reports the retransmitted packet
-  // as missing, that will bundle an ack with data after two acks in a row
-  // indicate the high water mark needs to be raised.
-  EXPECT_CALL(*send_algorithm_,
-              OnPacketSent(_, _, _, _, HAS_RETRANSMITTABLE_DATA));
-  connection_.SendStreamDataWithString(3, "foo", 3, !kFin, nullptr);
-  // No ack sent.
-  EXPECT_EQ(1u, writer_->frame_count());
-  EXPECT_EQ(1u, writer_->stream_frames().size());
-
-  // No more packet loss for the rest of the test.
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _)).Times(AnyNumber());
-  ProcessAckPacket(&frame2);
-  EXPECT_CALL(*send_algorithm_,
-              OnPacketSent(_, _, _, _, HAS_RETRANSMITTABLE_DATA));
-  connection_.SendStreamDataWithString(3, "foo", 3, !kFin, nullptr);
-  // Ack bundled.
-  EXPECT_EQ(3u, writer_->frame_count());
-  EXPECT_EQ(1u, writer_->stream_frames().size());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-
-  // But an ack with no missing packets will not send an ack.
-  AckPacket(original, &frame2);
-  ProcessAckPacket(&frame2);
-  ProcessAckPacket(&frame2);
-}
-
-TEST_P(QuicConnectionTest, 20AcksCausesAckSend) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  SendStreamDataToPeer(1, "foo", 0, !kFin, nullptr);
-
-  QuicAlarm* ack_alarm = QuicConnectionPeer::GetAckAlarm(&connection_);
-  // But an ack with no missing packets will not send an ack.
-  QuicAckFrame frame = InitAckFrame(1);
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  for (int i = 0; i < 19; ++i) {
-    ProcessAckPacket(&frame);
-    EXPECT_FALSE(ack_alarm->IsSet());
-  }
-  EXPECT_EQ(1u, writer_->packets_write_attempts());
-  // The 20th ack packet will cause an ack to be sent.
-  ProcessAckPacket(&frame);
-  EXPECT_EQ(2u, writer_->packets_write_attempts());
-}
-
-TEST_P(QuicConnectionTest, LeastUnackedLower) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  SendStreamDataToPeer(1, "foo", 0, !kFin, nullptr);
-  SendStreamDataToPeer(1, "bar", 3, !kFin, nullptr);
-  SendStreamDataToPeer(1, "eep", 6, !kFin, nullptr);
-
-  // Start out saying the least unacked is 2.
-  QuicPacketCreatorPeer::SetPacketNumber(&peer_creator_, 5);
-  QuicStopWaitingFrame frame = InitStopWaitingFrame(2);
-  ProcessStopWaitingPacket(&frame);
-
-  // Change it to 1, but lower the packet number to fake out-of-order packets.
-  // This should be fine.
-  QuicPacketCreatorPeer::SetPacketNumber(&peer_creator_, 1);
-  // The scheduler will not process out of order acks, but all packet processing
-  // causes the connection to try to write.
-  EXPECT_CALL(visitor_, OnCanWrite());
-  QuicStopWaitingFrame frame2 = InitStopWaitingFrame(1);
-  ProcessStopWaitingPacket(&frame2);
-
-  // Now claim it's one, but set the ordering so it was sent "after" the first
-  // one.  This should cause a connection error.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  QuicPacketCreatorPeer::SetPacketNumber(&peer_creator_, 7);
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_INVALID_STOP_WAITING_DATA, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  QuicStopWaitingFrame frame3 = InitStopWaitingFrame(1);
-  ProcessStopWaitingPacket(&frame3);
-}
-
-TEST_P(QuicConnectionTest, TooManySentPackets) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  const int num_packets = kMaxTrackedPackets + 100;
-  for (int i = 0; i < num_packets; ++i) {
-    SendStreamDataToPeer(1, "foo", 3 * i, !kFin, nullptr);
-  }
-
-  // Ack packet 1, which leaves more than the limit outstanding.
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  if (GetParam().version <= QUIC_VERSION_33) {
-    EXPECT_CALL(visitor_,
-                OnConnectionClosed(QUIC_TOO_MANY_OUTSTANDING_SENT_PACKETS, _,
-                                   ConnectionCloseSource::FROM_SELF));
-    // We're receive buffer limited, so the connection won't try to write more.
-    EXPECT_CALL(visitor_, OnCanWrite()).Times(0);
-  }
-
-  // Nack the first packet and ack the rest, leaving a huge gap.
-  QuicAckFrame frame1 = InitAckFrame(num_packets);
-  NackPacket(1, &frame1);
-  ProcessAckPacket(&frame1);
-}
-
-TEST_P(QuicConnectionTest, TooManyReceivedPackets) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  if (GetParam().version <= QUIC_VERSION_33) {
-    EXPECT_CALL(visitor_,
-                OnConnectionClosed(QUIC_TOO_MANY_OUTSTANDING_RECEIVED_PACKETS,
-                                   _, ConnectionCloseSource::FROM_SELF));
-  }
-  // Miss 99 of every 100 packets for 5500 packets.
-  for (QuicPacketNumber i = 1; i < kMaxTrackedPackets + 500; i += 100) {
-    ProcessPacket(kDefaultPathId, i);
-    if (!connection_.connected()) {
-      break;
-    }
-  }
-}
-
-TEST_P(QuicConnectionTest, LargestObservedLower) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  SendStreamDataToPeer(1, "foo", 0, !kFin, nullptr);
-  SendStreamDataToPeer(1, "bar", 3, !kFin, nullptr);
-  SendStreamDataToPeer(1, "eep", 6, !kFin, nullptr);
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-
-  // Start out saying the largest observed is 2.
-  QuicAckFrame frame1 = InitAckFrame(1);
-  QuicAckFrame frame2 = InitAckFrame(2);
-  ProcessAckPacket(&frame2);
-
-  // Now change it to 1, and it should cause a connection error.
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_INVALID_ACK_DATA, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  EXPECT_CALL(visitor_, OnCanWrite()).Times(0);
-  ProcessAckPacket(&frame1);
-}
-
-TEST_P(QuicConnectionTest, AckUnsentData) {
-  // Ack a packet which has not been sent.
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_INVALID_ACK_DATA, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  QuicAckFrame frame(MakeAckFrame(1));
-  EXPECT_CALL(visitor_, OnCanWrite()).Times(0);
-  ProcessAckPacket(&frame);
-}
-
-TEST_P(QuicConnectionTest, AckAll) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  ProcessPacket(kDefaultPathId, 1);
-
-  QuicPacketCreatorPeer::SetPacketNumber(&peer_creator_, 1);
-  QuicAckFrame frame1 = InitAckFrame(0);
-  ProcessAckPacket(&frame1);
-}
-
-TEST_P(QuicConnectionTest, BasicSending) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  QuicPacketNumber last_packet;
-  SendStreamDataToPeer(1, "foo", 0, !kFin, &last_packet);  // Packet 1
-  EXPECT_EQ(1u, last_packet);
-  SendAckPacketToPeer();  // Packet 2
-
-  EXPECT_EQ(1u, least_unacked());
-
-  SendAckPacketToPeer();  // Packet 3
-  EXPECT_EQ(1u, least_unacked());
-
-  SendStreamDataToPeer(1, "bar", 3, !kFin, &last_packet);  // Packet 4
-  EXPECT_EQ(4u, last_packet);
-  SendAckPacketToPeer();  // Packet 5
-  EXPECT_EQ(1u, least_unacked());
-
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-
-  // Peer acks up to packet 3.
-  QuicAckFrame frame = InitAckFrame(3);
-  ProcessAckPacket(&frame);
-  SendAckPacketToPeer();  // Packet 6
-
-  // As soon as we've acked one, we skip ack packets 2 and 3 and note lack of
-  // ack for 4.
-  EXPECT_EQ(4u, least_unacked());
-
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-
-  // Peer acks up to packet 4, the last packet.
-  QuicAckFrame frame2 = InitAckFrame(6);
-  ProcessAckPacket(&frame2);  // Acks don't instigate acks.
-
-  // Verify that we did not send an ack.
-  EXPECT_EQ(6u, writer_->header().packet_number);
-
-  // So the last ack has not changed.
-  EXPECT_EQ(4u, least_unacked());
-
-  // If we force an ack, we shouldn't change our retransmit state.
-  SendAckPacketToPeer();  // Packet 7
-  EXPECT_EQ(7u, least_unacked());
-
-  // But if we send more data it should.
-  SendStreamDataToPeer(1, "eep", 6, !kFin, &last_packet);  // Packet 8
-  EXPECT_EQ(8u, last_packet);
-  SendAckPacketToPeer();  // Packet 9
-  EXPECT_EQ(7u, least_unacked());
-}
-
-// QuicConnection should record the the packet sent-time prior to sending the
-// packet.
-TEST_P(QuicConnectionTest, RecordSentTimeBeforePacketSent) {
-  // We're using a MockClock for the tests, so we have complete control over the
-  // time.
-  // Our recorded timestamp for the last packet sent time will be passed in to
-  // the send_algorithm.  Make sure that it is set to the correct value.
-  QuicTime actual_recorded_send_time = QuicTime::Zero();
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillOnce(DoAll(SaveArg<0>(&actual_recorded_send_time), Return(true)));
-
-  // First send without any pause and check the result.
-  QuicTime expected_recorded_send_time = clock_.Now();
-  connection_.SendStreamDataWithString(1, "foo", 0, !kFin, nullptr);
-  EXPECT_EQ(expected_recorded_send_time, actual_recorded_send_time)
-      << "Expected time = " << expected_recorded_send_time.ToDebuggingValue()
-      << ".  Actual time = " << actual_recorded_send_time.ToDebuggingValue();
-
-  // Now pause during the write, and check the results.
-  actual_recorded_send_time = QuicTime::Zero();
-  const QuicTime::Delta write_pause_time_delta =
-      QuicTime::Delta::FromMilliseconds(5000);
-  SetWritePauseTimeDelta(write_pause_time_delta);
-  expected_recorded_send_time = clock_.Now();
-
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillOnce(DoAll(SaveArg<0>(&actual_recorded_send_time), Return(true)));
-  connection_.SendStreamDataWithString(2, "baz", 0, !kFin, nullptr);
-  EXPECT_EQ(expected_recorded_send_time, actual_recorded_send_time)
-      << "Expected time = " << expected_recorded_send_time.ToDebuggingValue()
-      << ".  Actual time = " << actual_recorded_send_time.ToDebuggingValue();
-}
-
-TEST_P(QuicConnectionTest, FramePacking) {
-  // Send an ack and two stream frames in 1 packet by queueing them.
-  {
-    QuicConnection::ScopedPacketBundler bundler(&connection_,
-                                                QuicConnection::SEND_ACK);
-    connection_.SendStreamData3();
-    connection_.SendStreamData5();
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-  }
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-  EXPECT_FALSE(connection_.HasQueuedData());
-
-  // Parse the last packet and ensure it's an ack and two stream frames from
-  // two different streams.
-  EXPECT_EQ(4u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  ASSERT_EQ(2u, writer_->stream_frames().size());
-  EXPECT_EQ(kClientDataStreamId1, writer_->stream_frames()[0]->stream_id);
-  EXPECT_EQ(kClientDataStreamId2, writer_->stream_frames()[1]->stream_id);
-}
-
-TEST_P(QuicConnectionTest, FramePackingNonCryptoThenCrypto) {
-  // Send an ack and two stream frames (one non-crypto, then one crypto) in 2
-  // packets by queueing them.
-  {
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(2);
-    QuicConnection::ScopedPacketBundler bundler(&connection_,
-                                                QuicConnection::SEND_ACK);
-    connection_.SendStreamData3();
-    connection_.SendCryptoStreamData();
-  }
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-  EXPECT_FALSE(connection_.HasQueuedData());
-
-  // Parse the last packet and ensure it's the crypto stream frame.
-  EXPECT_EQ(1u, writer_->frame_count());
-  ASSERT_EQ(1u, writer_->stream_frames().size());
-  EXPECT_EQ(kCryptoStreamId, writer_->stream_frames()[0]->stream_id);
-}
-
-TEST_P(QuicConnectionTest, FramePackingCryptoThenNonCrypto) {
-  // Send an ack and two stream frames (one crypto, then one non-crypto) in 2
-  // packets by queueing them.
-  {
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(2);
-    QuicConnection::ScopedPacketBundler bundler(&connection_,
-                                                QuicConnection::SEND_ACK);
-    connection_.SendCryptoStreamData();
-    connection_.SendStreamData3();
-  }
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-  EXPECT_FALSE(connection_.HasQueuedData());
-
-  // Parse the last packet and ensure it's the stream frame from stream 3.
-  EXPECT_EQ(1u, writer_->frame_count());
-  ASSERT_EQ(1u, writer_->stream_frames().size());
-  EXPECT_EQ(kClientDataStreamId1, writer_->stream_frames()[0]->stream_id);
-}
-
-TEST_P(QuicConnectionTest, FramePackingAckResponse) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  // Process a data packet to queue up a pending ack.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacket(kDefaultPathId, 1, kEntropyFlag);
-
-  EXPECT_CALL(visitor_, OnCanWrite())
-      .WillOnce(DoAll(IgnoreResult(InvokeWithoutArgs(
-                          &connection_, &TestConnection::SendStreamData3)),
-                      IgnoreResult(InvokeWithoutArgs(
-                          &connection_, &TestConnection::SendStreamData5))));
-
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-
-  // Process an ack to cause the visitor's OnCanWrite to be invoked.
-  QuicAckFrame ack_one = InitAckFrame(0);
-  ProcessAckPacket(3, &ack_one);
-
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-  EXPECT_FALSE(connection_.HasQueuedData());
-
-  // Parse the last packet and ensure it's an ack and two stream frames from
-  // two different streams.
-  EXPECT_EQ(4u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  ASSERT_EQ(2u, writer_->stream_frames().size());
-  EXPECT_EQ(kClientDataStreamId1, writer_->stream_frames()[0]->stream_id);
-  EXPECT_EQ(kClientDataStreamId2, writer_->stream_frames()[1]->stream_id);
-}
-
-TEST_P(QuicConnectionTest, FramePackingSendv) {
-  // Send data in 1 packet by writing multiple blocks in a single iovector
-  // using writev.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-
-  char data[] = "ABCD";
-  struct iovec iov[2];
-  iov[0].iov_base = data;
-  iov[0].iov_len = 2;
-  iov[1].iov_base = data + 2;
-  iov[1].iov_len = 2;
-  connection_.SendStreamData(1, QuicIOVector(iov, 2, 4), 0, !kFin, nullptr);
-
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-  EXPECT_FALSE(connection_.HasQueuedData());
-
-  // Parse the last packet and ensure multiple iovector blocks have
-  // been packed into a single stream frame from one stream.
-  EXPECT_EQ(1u, writer_->frame_count());
-  EXPECT_EQ(1u, writer_->stream_frames().size());
-  QuicStreamFrame* frame = writer_->stream_frames()[0];
-  EXPECT_EQ(1u, frame->stream_id);
-  EXPECT_EQ("ABCD", StringPiece(frame->data_buffer, frame->data_length));
-}
-
-TEST_P(QuicConnectionTest, FramePackingSendvQueued) {
-  // Try to send two stream frames in 1 packet by using writev.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-
-  BlockOnNextWrite();
-  char data[] = "ABCD";
-  struct iovec iov[2];
-  iov[0].iov_base = data;
-  iov[0].iov_len = 2;
-  iov[1].iov_base = data + 2;
-  iov[1].iov_len = 2;
-  connection_.SendStreamData(1, QuicIOVector(iov, 2, 4), 0, !kFin, nullptr);
-
-  EXPECT_EQ(1u, connection_.NumQueuedPackets());
-  EXPECT_TRUE(connection_.HasQueuedData());
-
-  // Unblock the writes and actually send.
-  writer_->SetWritable();
-  connection_.OnCanWrite();
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-
-  // Parse the last packet and ensure it's one stream frame from one stream.
-  EXPECT_EQ(1u, writer_->frame_count());
-  EXPECT_EQ(1u, writer_->stream_frames().size());
-  EXPECT_EQ(1u, writer_->stream_frames()[0]->stream_id);
-}
-
-TEST_P(QuicConnectionTest, SendingZeroBytes) {
-  // Send a zero byte write with a fin using writev.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  QuicIOVector empty_iov(nullptr, 0, 0);
-  connection_.SendStreamData(kHeadersStreamId, empty_iov, 0, kFin, nullptr);
-
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-  EXPECT_FALSE(connection_.HasQueuedData());
-
-  // Parse the last packet and ensure it's one stream frame from one stream.
-  EXPECT_EQ(1u, writer_->frame_count());
-  EXPECT_EQ(1u, writer_->stream_frames().size());
-  EXPECT_EQ(kHeadersStreamId, writer_->stream_frames()[0]->stream_id);
-  EXPECT_TRUE(writer_->stream_frames()[0]->fin);
-}
-
-TEST_P(QuicConnectionTest, LargeSendWithPendingAck) {
-  // Set the ack alarm by processing a ping frame.
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  // Processs a PING frame.
-  ProcessFramePacket(QuicFrame(QuicPingFrame()));
-  // Ensure that this has caused the ACK alarm to be set.
-  QuicAlarm* ack_alarm = QuicConnectionPeer::GetAckAlarm(&connection_);
-  EXPECT_TRUE(ack_alarm->IsSet());
-
-  // Send data and ensure the ack is bundled.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(8);
-  size_t len = 10000;
-  std::unique_ptr<char[]> data_array(new char[len]);
-  memset(data_array.get(), '?', len);
-  struct iovec iov;
-  iov.iov_base = data_array.get();
-  iov.iov_len = len;
-  QuicIOVector iovector(&iov, 1, len);
-  QuicConsumedData consumed =
-      connection_.SendStreamData(kHeadersStreamId, iovector, 0, true, nullptr);
-  EXPECT_EQ(len, consumed.bytes_consumed);
-  EXPECT_TRUE(consumed.fin_consumed);
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-  EXPECT_FALSE(connection_.HasQueuedData());
-
-  // Parse the last packet and ensure it's one stream frame with a fin.
-  EXPECT_EQ(1u, writer_->frame_count());
-  EXPECT_EQ(1u, writer_->stream_frames().size());
-  EXPECT_EQ(kHeadersStreamId, writer_->stream_frames()[0]->stream_id);
-  EXPECT_TRUE(writer_->stream_frames()[0]->fin);
-  // Ensure the ack alarm was cancelled when the ack was sent.
-  EXPECT_FALSE(ack_alarm->IsSet());
-}
-
-TEST_P(QuicConnectionTest, OnCanWrite) {
-  // Visitor's OnCanWrite will send data, but will have more pending writes.
-  EXPECT_CALL(visitor_, OnCanWrite())
-      .WillOnce(DoAll(IgnoreResult(InvokeWithoutArgs(
-                          &connection_, &TestConnection::SendStreamData3)),
-                      IgnoreResult(InvokeWithoutArgs(
-                          &connection_, &TestConnection::SendStreamData5))));
-  {
-    InSequence seq;
-    EXPECT_CALL(visitor_, WillingAndAbleToWrite()).WillOnce(Return(true));
-    EXPECT_CALL(visitor_, WillingAndAbleToWrite())
-        .WillRepeatedly(Return(false));
-  }
-
-  EXPECT_CALL(*send_algorithm_, TimeUntilSend(_, _))
-      .WillRepeatedly(testing::Return(QuicTime::Delta::Zero()));
-
-  connection_.OnCanWrite();
-
-  // Parse the last packet and ensure it's the two stream frames from
-  // two different streams.
-  EXPECT_EQ(2u, writer_->frame_count());
-  EXPECT_EQ(2u, writer_->stream_frames().size());
-  EXPECT_EQ(kClientDataStreamId1, writer_->stream_frames()[0]->stream_id);
-  EXPECT_EQ(kClientDataStreamId2, writer_->stream_frames()[1]->stream_id);
-}
-
-TEST_P(QuicConnectionTest, RetransmitOnNack) {
-  QuicPacketNumber last_packet;
-  QuicByteCount second_packet_size;
-  SendStreamDataToPeer(3, "foo", 0, !kFin, &last_packet);  // Packet 1
-  second_packet_size =
-      SendStreamDataToPeer(3, "foos", 3, !kFin, &last_packet);  // Packet 2
-  SendStreamDataToPeer(3, "fooos", 7, !kFin, &last_packet);     // Packet 3
-
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  // Don't lose a packet on an ack, and nothing is retransmitted.
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  QuicAckFrame ack_one = InitAckFrame(1);
-  ProcessAckPacket(&ack_one);
-
-  // Lose a packet and ensure it triggers retransmission.
-  QuicAckFrame nack_two = InitAckFrame(3);
-  NackPacket(2, &nack_two);
-  SendAlgorithmInterface::CongestionVector lost_packets;
-  lost_packets.push_back(std::make_pair(2, kMaxPacketSize));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _))
-      .WillOnce(SetArgPointee<4>(lost_packets));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  EXPECT_CALL(*send_algorithm_,
-              OnPacketSent(_, _, _, second_packet_size - kQuicVersionSize, _))
-      .Times(1);
-  ProcessAckPacket(&nack_two);
-}
-
-TEST_P(QuicConnectionTest, DoNotSendQueuedPacketForResetStream) {
-  // Block the connection to queue the packet.
-  BlockOnNextWrite();
-
-  QuicStreamId stream_id = 2;
-  connection_.SendStreamDataWithString(stream_id, "foo", 0, !kFin, nullptr);
-
-  // Now that there is a queued packet, reset the stream.
-  connection_.SendRstStream(stream_id, QUIC_ERROR_PROCESSING_STREAM, 14);
-
-  // Unblock the connection and verify that only the RST_STREAM is sent.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-  writer_->SetWritable();
-  connection_.OnCanWrite();
-  EXPECT_EQ(1u, writer_->frame_count());
-  EXPECT_EQ(1u, writer_->rst_stream_frames().size());
-}
-
-TEST_P(QuicConnectionTest, SendQueuedPacketForQuicRstStreamNoError) {
-  // Block the connection to queue the packet.
-  BlockOnNextWrite();
-
-  QuicStreamId stream_id = 2;
-  connection_.SendStreamDataWithString(stream_id, "foo", 0, !kFin, nullptr);
-
-  // Now that there is a queued packet, reset the stream.
-  connection_.SendRstStream(stream_id, QUIC_STREAM_NO_ERROR, 14);
-
-  // Unblock the connection and verify that the RST_STREAM is sent and the data
-  // packet is sent.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(AtLeast(2));
-  writer_->SetWritable();
-  connection_.OnCanWrite();
-  EXPECT_EQ(1u, writer_->frame_count());
-  EXPECT_EQ(1u, writer_->rst_stream_frames().size());
-}
-
-TEST_P(QuicConnectionTest, DoNotRetransmitForResetStreamOnNack) {
-  QuicStreamId stream_id = 2;
-  QuicPacketNumber last_packet;
-  SendStreamDataToPeer(stream_id, "foo", 0, !kFin, &last_packet);
-  SendStreamDataToPeer(stream_id, "foos", 3, !kFin, &last_packet);
-  SendStreamDataToPeer(stream_id, "fooos", 7, !kFin, &last_packet);
-
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-  connection_.SendRstStream(stream_id, QUIC_ERROR_PROCESSING_STREAM, 14);
-
-  // Lose a packet and ensure it does not trigger retransmission.
-  QuicAckFrame nack_two = InitAckFrame(last_packet);
-  NackPacket(last_packet - 1, &nack_two);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(0);
-  ProcessAckPacket(&nack_two);
-}
-
-TEST_P(QuicConnectionTest, RetransmitForQuicRstStreamNoErrorOnNack) {
-  QuicStreamId stream_id = 2;
-  QuicPacketNumber last_packet;
-  SendStreamDataToPeer(stream_id, "foo", 0, !kFin, &last_packet);
-  SendStreamDataToPeer(stream_id, "foos", 3, !kFin, &last_packet);
-  SendStreamDataToPeer(stream_id, "fooos", 7, !kFin, &last_packet);
-
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-  connection_.SendRstStream(stream_id, QUIC_STREAM_NO_ERROR, 14);
-
-  // Lose a packet, ensure it triggers retransmission.
-  QuicAckFrame nack_two = InitAckFrame(last_packet);
-  NackPacket(last_packet - 1, &nack_two);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  SendAlgorithmInterface::CongestionVector lost_packets;
-  lost_packets.push_back(std::make_pair(last_packet - 1, kMaxPacketSize));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _))
-      .WillOnce(SetArgPointee<4>(lost_packets));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(AtLeast(1));
-  ProcessAckPacket(&nack_two);
-}
-
-TEST_P(QuicConnectionTest, DoNotRetransmitForResetStreamOnRTO) {
-  QuicStreamId stream_id = 2;
-  QuicPacketNumber last_packet;
-  SendStreamDataToPeer(stream_id, "foo", 0, !kFin, &last_packet);
-
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-  connection_.SendRstStream(stream_id, QUIC_ERROR_PROCESSING_STREAM, 14);
-
-  // Fire the RTO and verify that the RST_STREAM is resent, not stream data.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-  clock_.AdvanceTime(DefaultRetransmissionTime());
-  connection_.GetRetransmissionAlarm()->Fire();
-  EXPECT_EQ(1u, writer_->frame_count());
-  EXPECT_EQ(1u, writer_->rst_stream_frames().size());
-  EXPECT_EQ(stream_id, writer_->rst_stream_frames().front().stream_id);
-}
-
-TEST_P(QuicConnectionTest, RetransmitForQuicRstStreamNoErrorOnRTO) {
-  connection_.SetMaxTailLossProbes(kDefaultPathId, 0);
-
-  QuicStreamId stream_id = 2;
-  QuicPacketNumber last_packet;
-  SendStreamDataToPeer(stream_id, "foo", 0, !kFin, &last_packet);
-
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-  connection_.SendRstStream(stream_id, QUIC_STREAM_NO_ERROR, 14);
-
-  // Fire the RTO and verify that the RST_STREAM is resent, the stream data
-  // is sent.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(AtLeast(2));
-  clock_.AdvanceTime(DefaultRetransmissionTime());
-  connection_.GetRetransmissionAlarm()->Fire();
-  EXPECT_EQ(1u, writer_->frame_count());
-  ASSERT_EQ(1u, writer_->rst_stream_frames().size());
-  EXPECT_EQ(stream_id, writer_->rst_stream_frames().front().stream_id);
-}
-
-TEST_P(QuicConnectionTest, DoNotSendPendingRetransmissionForResetStream) {
-  QuicStreamId stream_id = 2;
-  QuicPacketNumber last_packet;
-  SendStreamDataToPeer(stream_id, "foo", 0, !kFin, &last_packet);
-  SendStreamDataToPeer(stream_id, "foos", 3, !kFin, &last_packet);
-  BlockOnNextWrite();
-  connection_.SendStreamDataWithString(stream_id, "fooos", 7, !kFin, nullptr);
-
-  // Lose a packet which will trigger a pending retransmission.
-  QuicAckFrame ack = InitAckFrame(last_packet);
-  NackPacket(last_packet - 1, &ack);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(0);
-  ProcessAckPacket(&ack);
-
-  connection_.SendRstStream(stream_id, QUIC_ERROR_PROCESSING_STREAM, 14);
-
-  // Unblock the connection and verify that the RST_STREAM is sent but not the
-  // second data packet nor a retransmit.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-  writer_->SetWritable();
-  connection_.OnCanWrite();
-  EXPECT_EQ(1u, writer_->frame_count());
-  EXPECT_EQ(1u, writer_->rst_stream_frames().size());
-  EXPECT_EQ(stream_id, writer_->rst_stream_frames().front().stream_id);
-}
-
-TEST_P(QuicConnectionTest, SendPendingRetransmissionForQuicRstStreamNoError) {
-  QuicStreamId stream_id = 2;
-  QuicPacketNumber last_packet;
-  SendStreamDataToPeer(stream_id, "foo", 0, !kFin, &last_packet);
-  SendStreamDataToPeer(stream_id, "foos", 3, !kFin, &last_packet);
-  BlockOnNextWrite();
-  connection_.SendStreamDataWithString(stream_id, "fooos", 7, !kFin, nullptr);
-
-  // Lose a packet which will trigger a pending retransmission.
-  QuicAckFrame ack = InitAckFrame(last_packet);
-  NackPacket(last_packet - 1, &ack);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  SendAlgorithmInterface::CongestionVector lost_packets;
-  lost_packets.push_back(std::make_pair(last_packet - 1, kMaxPacketSize));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _))
-      .WillOnce(SetArgPointee<4>(lost_packets));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(0);
-  ProcessAckPacket(&ack);
-
-  connection_.SendRstStream(stream_id, QUIC_STREAM_NO_ERROR, 14);
-
-  // Unblock the connection and verify that the RST_STREAM is sent and the
-  // second data packet or a retransmit is sent.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(AtLeast(2));
-  writer_->SetWritable();
-  connection_.OnCanWrite();
-  EXPECT_EQ(1u, writer_->frame_count());
-  EXPECT_EQ(0u, writer_->rst_stream_frames().size());
-}
-
-TEST_P(QuicConnectionTest, RetransmitAckedPacket) {
-  QuicPacketNumber last_packet;
-  SendStreamDataToPeer(1, "foo", 0, !kFin, &last_packet);    // Packet 1
-  SendStreamDataToPeer(1, "foos", 3, !kFin, &last_packet);   // Packet 2
-  SendStreamDataToPeer(1, "fooos", 7, !kFin, &last_packet);  // Packet 3
-
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  // Instigate a loss with an ack.
-  QuicAckFrame nack_two = InitAckFrame(3);
-  NackPacket(2, &nack_two);
-  // The first nack should trigger a fast retransmission, but we'll be
-  // write blocked, so the packet will be queued.
-  BlockOnNextWrite();
-
-  SendAlgorithmInterface::CongestionVector lost_packets;
-  lost_packets.push_back(std::make_pair(2, kMaxPacketSize));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _))
-      .WillOnce(SetArgPointee<4>(lost_packets));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&nack_two);
-  EXPECT_EQ(1u, connection_.NumQueuedPackets());
-
-  // Now, ack the previous transmission.
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _));
-  QuicAckFrame ack_all = InitAckFrame(3);
-  ProcessAckPacket(&ack_all);
-
-  // Unblock the socket and attempt to send the queued packets. We will always
-  // send the retransmission.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, 4, _, _)).Times(1);
-
-  writer_->SetWritable();
-  connection_.OnCanWrite();
-
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-  // We do not store retransmittable frames of this retransmission.
-  EXPECT_FALSE(QuicConnectionPeer::HasRetransmittableFrames(&connection_,
-                                                            kDefaultPathId, 4));
-}
-
-TEST_P(QuicConnectionTest, RetransmitNackedLargestObserved) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  QuicPacketNumber largest_observed;
-  QuicByteCount packet_size;
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillOnce(DoAll(SaveArg<2>(&largest_observed), SaveArg<3>(&packet_size),
-                      Return(true)));
-  connection_.SendStreamDataWithString(3, "foo", 0, !kFin, nullptr);
-
-  QuicAckFrame frame = InitAckFrame(1);
-  NackPacket(largest_observed, &frame);
-  // The first nack should retransmit the largest observed packet.
-  SendAlgorithmInterface::CongestionVector lost_packets;
-  lost_packets.push_back(std::make_pair(1, kMaxPacketSize));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _))
-      .WillOnce(SetArgPointee<4>(lost_packets));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  EXPECT_CALL(*send_algorithm_,
-              OnPacketSent(_, _, _, packet_size - kQuicVersionSize, _));
-  ProcessAckPacket(&frame);
-}
-
-TEST_P(QuicConnectionTest, QueueAfterTwoRTOs) {
-  connection_.SetMaxTailLossProbes(kDefaultPathId, 0);
-
-  for (int i = 0; i < 10; ++i) {
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-    connection_.SendStreamDataWithString(3, "foo", i * 3, !kFin, nullptr);
-  }
-
-  // Block the writer and ensure they're queued.
-  BlockOnNextWrite();
-  clock_.AdvanceTime(DefaultRetransmissionTime());
-  // Only one packet should be retransmitted.
-  connection_.GetRetransmissionAlarm()->Fire();
-  EXPECT_TRUE(connection_.HasQueuedData());
-
-  // Unblock the writer.
-  writer_->SetWritable();
-  clock_.AdvanceTime(QuicTime::Delta::FromMicroseconds(
-      2 * DefaultRetransmissionTime().ToMicroseconds()));
-  // Retransmit already retransmitted packets event though the packet number
-  // greater than the largest observed.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(2);
-  connection_.GetRetransmissionAlarm()->Fire();
-  connection_.OnCanWrite();
-}
-
-TEST_P(QuicConnectionTest, WriteBlockedBufferedThenSent) {
-  BlockOnNextWrite();
-  writer_->set_is_write_blocked_data_buffered(true);
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-  connection_.SendStreamDataWithString(1, "foo", 0, !kFin, nullptr);
-  EXPECT_TRUE(connection_.GetRetransmissionAlarm()->IsSet());
-
-  writer_->SetWritable();
-  connection_.OnCanWrite();
-  EXPECT_TRUE(connection_.GetRetransmissionAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, WriteBlockedThenSent) {
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(0);
-  BlockOnNextWrite();
-  connection_.SendStreamDataWithString(1, "foo", 0, !kFin, nullptr);
-  EXPECT_FALSE(connection_.GetRetransmissionAlarm()->IsSet());
-  EXPECT_EQ(1u, connection_.NumQueuedPackets());
-
-  // The second packet should also be queued, in order to ensure packets are
-  // never sent out of order.
-  writer_->SetWritable();
-  connection_.SendStreamDataWithString(1, "foo", 0, !kFin, nullptr);
-  EXPECT_EQ(2u, connection_.NumQueuedPackets());
-
-  // Now both are sent in order when we unblock.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(2);
-  connection_.OnCanWrite();
-  EXPECT_TRUE(connection_.GetRetransmissionAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, RetransmitWriteBlockedAckedOriginalThenSent) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  connection_.SendStreamDataWithString(3, "foo", 0, !kFin, nullptr);
-  EXPECT_TRUE(connection_.GetRetransmissionAlarm()->IsSet());
-
-  BlockOnNextWrite();
-  writer_->set_is_write_blocked_data_buffered(true);
-  // Simulate the retransmission alarm firing.
-  clock_.AdvanceTime(DefaultRetransmissionTime());
-  connection_.GetRetransmissionAlarm()->Fire();
-
-  // Ack the sent packet before the callback returns, which happens in
-  // rare circumstances with write blocked sockets.
-  QuicAckFrame ack = InitAckFrame(1);
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&ack);
-
-  writer_->SetWritable();
-  connection_.OnCanWrite();
-  // There is now a pending packet, but with no retransmittable frames.
-  EXPECT_TRUE(connection_.GetRetransmissionAlarm()->IsSet());
-  EXPECT_FALSE(QuicConnectionPeer::HasRetransmittableFrames(&connection_,
-                                                            ack.path_id, 2));
-}
-
-TEST_P(QuicConnectionTest, AlarmsWhenWriteBlocked) {
-  // Block the connection.
-  BlockOnNextWrite();
-  connection_.SendStreamDataWithString(3, "foo", 0, !kFin, nullptr);
-  EXPECT_EQ(1u, writer_->packets_write_attempts());
-  EXPECT_TRUE(writer_->IsWriteBlocked());
-
-  // Set the send and resumption alarms. Fire the alarms and ensure they don't
-  // attempt to write.
-  connection_.GetResumeWritesAlarm()->Set(clock_.ApproximateNow());
-  connection_.GetSendAlarm()->Set(clock_.ApproximateNow());
-  connection_.GetResumeWritesAlarm()->Fire();
-  connection_.GetSendAlarm()->Fire();
-  EXPECT_TRUE(writer_->IsWriteBlocked());
-  EXPECT_EQ(1u, writer_->packets_write_attempts());
-}
-
-TEST_P(QuicConnectionTest, NoLimitPacketsPerNack) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  int offset = 0;
-  // Send packets 1 to 15.
-  for (int i = 0; i < 15; ++i) {
-    SendStreamDataToPeer(1, "foo", offset, !kFin, nullptr);
-    offset += 3;
-  }
-
-  // Ack 15, nack 1-14.
-
-  QuicAckFrame nack = InitAckFrame(15);
-  for (int i = 1; i < 15; ++i) {
-    NackPacket(i, &nack);
-  }
-
-  // 14 packets have been NACK'd and lost.
-  SendAlgorithmInterface::CongestionVector lost_packets;
-  for (int i = 1; i < 15; ++i) {
-    lost_packets.push_back(std::make_pair(i, kMaxPacketSize));
-  }
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _))
-      .WillOnce(SetArgPointee<4>(lost_packets));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(14);
-  ProcessAckPacket(&nack);
-}
-
-// Test sending multiple acks from the connection to the session.
-TEST_P(QuicConnectionTest, MultipleAcks) {
-  QuicPacketNumber last_packet;
-  SendStreamDataToPeer(1, "foo", 0, !kFin, &last_packet);  // Packet 1
-  EXPECT_EQ(1u, last_packet);
-  SendStreamDataToPeer(3, "foo", 0, !kFin, &last_packet);  // Packet 2
-  EXPECT_EQ(2u, last_packet);
-  SendAckPacketToPeer();                                   // Packet 3
-  SendStreamDataToPeer(5, "foo", 0, !kFin, &last_packet);  // Packet 4
-  EXPECT_EQ(4u, last_packet);
-  SendStreamDataToPeer(1, "foo", 3, !kFin, &last_packet);  // Packet 5
-  EXPECT_EQ(5u, last_packet);
-  SendStreamDataToPeer(3, "foo", 3, !kFin, &last_packet);  // Packet 6
-  EXPECT_EQ(6u, last_packet);
-
-  // Client will ack packets 1, 2, [!3], 4, 5.
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  QuicAckFrame frame1 = InitAckFrame(5);
-  NackPacket(3, &frame1);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  ProcessAckPacket(&frame1);
-
-  // Now the client implicitly acks 3, and explicitly acks 6.
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  QuicAckFrame frame2 = InitAckFrame(6);
-  ProcessAckPacket(&frame2);
-}
-
-TEST_P(QuicConnectionTest, DontLatchUnackedPacket) {
-  SendStreamDataToPeer(1, "foo", 0, !kFin, nullptr);  // Packet 1;
-  // From now on, we send acks, so the send algorithm won't mark them pending.
-  ON_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillByDefault(Return(false));
-  SendAckPacketToPeer();  // Packet 2
-
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  QuicAckFrame frame = InitAckFrame(1);
-  ProcessAckPacket(&frame);
-
-  // Verify that our internal state has least-unacked as 2, because we're still
-  // waiting for a potential ack for 2.
-
-  EXPECT_EQ(2u, stop_waiting()->least_unacked);
-
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  frame = InitAckFrame(2);
-  ProcessAckPacket(&frame);
-  EXPECT_EQ(3u, stop_waiting()->least_unacked);
-
-  // When we send an ack, we make sure our least-unacked makes sense.  In this
-  // case since we're not waiting on an ack for 2 and all packets are acked, we
-  // set it to 3.
-  SendAckPacketToPeer();  // Packet 3
-  // Least_unacked remains at 3 until another ack is received.
-  EXPECT_EQ(3u, stop_waiting()->least_unacked);
-  // Check that the outgoing ack had its packet number as least_unacked.
-  EXPECT_EQ(3u, least_unacked());
-
-  // Ack the ack, which updates the rtt and raises the least unacked.
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  frame = InitAckFrame(3);
-  ProcessAckPacket(&frame);
-
-  ON_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillByDefault(Return(true));
-  SendStreamDataToPeer(1, "bar", 3, false, nullptr);  // Packet 4
-  EXPECT_EQ(4u, stop_waiting()->least_unacked);
-  ON_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillByDefault(Return(false));
-  SendAckPacketToPeer();  // Packet 5
-  EXPECT_EQ(4u, least_unacked());
-
-  // Send two data packets at the end, and ensure if the last one is acked,
-  // the least unacked is raised above the ack packets.
-  ON_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillByDefault(Return(true));
-  SendStreamDataToPeer(1, "bar", 6, false, nullptr);  // Packet 6
-  SendStreamDataToPeer(1, "bar", 9, false, nullptr);  // Packet 7
-
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  frame = InitAckFrame(7);
-  NackPacket(5, &frame);
-  NackPacket(6, &frame);
-  ProcessAckPacket(&frame);
-
-  EXPECT_EQ(6u, stop_waiting()->least_unacked);
-}
-
-TEST_P(QuicConnectionTest, TLP) {
-  connection_.SetMaxTailLossProbes(kDefaultPathId, 1);
-
-  SendStreamDataToPeer(3, "foo", 0, !kFin, nullptr);
-  EXPECT_EQ(1u, stop_waiting()->least_unacked);
-  QuicTime retransmission_time =
-      connection_.GetRetransmissionAlarm()->deadline();
-  EXPECT_NE(QuicTime::Zero(), retransmission_time);
-
-  EXPECT_EQ(1u, writer_->header().packet_number);
-  // Simulate the retransmission alarm firing and sending a tlp,
-  // so send algorithm's OnRetransmissionTimeout is not called.
-  clock_.AdvanceTime(retransmission_time - clock_.Now());
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, 2u, _, _));
-  connection_.GetRetransmissionAlarm()->Fire();
-  EXPECT_EQ(2u, writer_->header().packet_number);
-  // We do not raise the high water mark yet.
-  EXPECT_EQ(1u, stop_waiting()->least_unacked);
-}
-
-TEST_P(QuicConnectionTest, RTO) {
-  connection_.SetMaxTailLossProbes(kDefaultPathId, 0);
-
-  QuicTime default_retransmission_time =
-      clock_.ApproximateNow() + DefaultRetransmissionTime();
-  SendStreamDataToPeer(3, "foo", 0, !kFin, nullptr);
-  EXPECT_EQ(1u, stop_waiting()->least_unacked);
-
-  EXPECT_EQ(1u, writer_->header().packet_number);
-  EXPECT_EQ(default_retransmission_time,
-            connection_.GetRetransmissionAlarm()->deadline());
-  // Simulate the retransmission alarm firing.
-  clock_.AdvanceTime(DefaultRetransmissionTime());
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, 2u, _, _));
-  connection_.GetRetransmissionAlarm()->Fire();
-  EXPECT_EQ(2u, writer_->header().packet_number);
-  // We do not raise the high water mark yet.
-  EXPECT_EQ(1u, stop_waiting()->least_unacked);
-}
-
-TEST_P(QuicConnectionTest, RTOWithSameEncryptionLevel) {
-  connection_.SetMaxTailLossProbes(kDefaultPathId, 0);
-
-  QuicTime default_retransmission_time =
-      clock_.ApproximateNow() + DefaultRetransmissionTime();
-  use_tagging_decrypter();
-
-  // A TaggingEncrypter puts kTagSize copies of the given byte (0x01 here) at
-  // the end of the packet. We can test this to check which encrypter was used.
-  connection_.SetEncrypter(ENCRYPTION_NONE, new TaggingEncrypter(0x01));
-  SendStreamDataToPeer(3, "foo", 0, !kFin, nullptr);
-  EXPECT_EQ(0x01010101u, writer_->final_bytes_of_last_packet());
-
-  connection_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(0x02));
-  connection_.SetDefaultEncryptionLevel(ENCRYPTION_INITIAL);
-  SendStreamDataToPeer(3, "foo", 0, !kFin, nullptr);
-  EXPECT_EQ(0x02020202u, writer_->final_bytes_of_last_packet());
-
-  EXPECT_EQ(default_retransmission_time,
-            connection_.GetRetransmissionAlarm()->deadline());
-  {
-    InSequence s;
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, 3, _, _));
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, 4, _, _));
-  }
-
-  // Simulate the retransmission alarm firing.
-  clock_.AdvanceTime(DefaultRetransmissionTime());
-  connection_.GetRetransmissionAlarm()->Fire();
-
-  // Packet should have been sent with ENCRYPTION_NONE.
-  EXPECT_EQ(0x01010101u, writer_->final_bytes_of_previous_packet());
-
-  // Packet should have been sent with ENCRYPTION_INITIAL.
-  EXPECT_EQ(0x02020202u, writer_->final_bytes_of_last_packet());
-}
-
-TEST_P(QuicConnectionTest, SendHandshakeMessages) {
-  use_tagging_decrypter();
-  // A TaggingEncrypter puts kTagSize copies of the given byte (0x01 here) at
-  // the end of the packet. We can test this to check which encrypter was used.
-  connection_.SetEncrypter(ENCRYPTION_NONE, new TaggingEncrypter(0x01));
-
-  // Attempt to send a handshake message and have the socket block.
-  EXPECT_CALL(*send_algorithm_, TimeUntilSend(_, _))
-      .WillRepeatedly(testing::Return(QuicTime::Delta::Zero()));
-  BlockOnNextWrite();
-  connection_.SendStreamDataWithString(1, "foo", 0, !kFin, nullptr);
-  // The packet should be serialized, but not queued.
-  EXPECT_EQ(1u, connection_.NumQueuedPackets());
-
-  // Switch to the new encrypter.
-  connection_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(0x02));
-  connection_.SetDefaultEncryptionLevel(ENCRYPTION_INITIAL);
-
-  // Now become writeable and flush the packets.
-  writer_->SetWritable();
-  EXPECT_CALL(visitor_, OnCanWrite());
-  connection_.OnCanWrite();
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-
-  // Verify that the handshake packet went out at the null encryption.
-  EXPECT_EQ(0x01010101u, writer_->final_bytes_of_last_packet());
-}
-
-TEST_P(QuicConnectionTest,
-       DropRetransmitsForNullEncryptedPacketAfterForwardSecure) {
-  use_tagging_decrypter();
-  connection_.SetEncrypter(ENCRYPTION_NONE, new TaggingEncrypter(0x01));
-  QuicPacketNumber packet_number;
-  SendStreamDataToPeer(3, "foo", 0, !kFin, &packet_number);
-
-  // Simulate the retransmission alarm firing and the socket blocking.
-  BlockOnNextWrite();
-  clock_.AdvanceTime(DefaultRetransmissionTime());
-  connection_.GetRetransmissionAlarm()->Fire();
-
-  // Go forward secure.
-  connection_.SetEncrypter(ENCRYPTION_FORWARD_SECURE,
-                           new TaggingEncrypter(0x02));
-  connection_.SetDefaultEncryptionLevel(ENCRYPTION_FORWARD_SECURE);
-  connection_.NeuterUnencryptedPackets();
-
-  EXPECT_EQ(QuicTime::Zero(), connection_.GetRetransmissionAlarm()->deadline());
-  // Unblock the socket and ensure that no packets are sent.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(0);
-  writer_->SetWritable();
-  connection_.OnCanWrite();
-}
-
-TEST_P(QuicConnectionTest, RetransmitPacketsWithInitialEncryption) {
-  use_tagging_decrypter();
-  connection_.SetEncrypter(ENCRYPTION_NONE, new TaggingEncrypter(0x01));
-  connection_.SetDefaultEncryptionLevel(ENCRYPTION_NONE);
-
-  SendStreamDataToPeer(1, "foo", 0, !kFin, nullptr);
-
-  connection_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(0x02));
-  connection_.SetDefaultEncryptionLevel(ENCRYPTION_INITIAL);
-
-  SendStreamDataToPeer(2, "bar", 0, !kFin, nullptr);
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-
-  connection_.RetransmitUnackedPackets(ALL_INITIAL_RETRANSMISSION);
-}
-
-TEST_P(QuicConnectionTest, DelayForwardSecureEncryptionUntilClientIsReady) {
-  FLAGS_quic_remove_obsolete_forward_secure = false;
-  // A TaggingEncrypter puts kTagSize copies of the given byte (0x02 here) at
-  // the end of the packet. We can test this to check which encrypter was used.
-  use_tagging_decrypter();
-  connection_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(0x02));
-  connection_.SetDefaultEncryptionLevel(ENCRYPTION_INITIAL);
-  SendAckPacketToPeer();
-  EXPECT_EQ(0x02020202u, writer_->final_bytes_of_last_packet());
-
-  // Set a forward-secure encrypter but do not make it the default, and verify
-  // that it is not yet used.
-  connection_.SetEncrypter(ENCRYPTION_FORWARD_SECURE,
-                           new TaggingEncrypter(0x03));
-  SendAckPacketToPeer();
-  EXPECT_EQ(0x02020202u, writer_->final_bytes_of_last_packet());
-
-  // Now simulate receipt of a forward-secure packet and verify that the
-  // forward-secure encrypter is now used.
-  connection_.OnDecryptedPacket(ENCRYPTION_FORWARD_SECURE);
-  SendAckPacketToPeer();
-  EXPECT_EQ(0x03030303u, writer_->final_bytes_of_last_packet());
-}
-
-TEST_P(QuicConnectionTest, DelayForwardSecureEncryptionUntilManyPacketSent) {
-  FLAGS_quic_remove_obsolete_forward_secure = false;
-  // Set a congestion window of 10 packets.
-  QuicPacketCount congestion_window = 10;
-  EXPECT_CALL(*send_algorithm_, GetCongestionWindow())
-      .WillRepeatedly(Return(congestion_window * kDefaultMaxPacketSize));
-
-  // A TaggingEncrypter puts kTagSize copies of the given byte (0x02 here) at
-  // the end of the packet. We can test this to check which encrypter was used.
-  use_tagging_decrypter();
-  connection_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(0x02));
-  connection_.SetDefaultEncryptionLevel(ENCRYPTION_INITIAL);
-  SendAckPacketToPeer();
-  EXPECT_EQ(0x02020202u, writer_->final_bytes_of_last_packet());
-
-  // Set a forward-secure encrypter but do not make it the default, and
-  // verify that it is not yet used.
-  connection_.SetEncrypter(ENCRYPTION_FORWARD_SECURE,
-                           new TaggingEncrypter(0x03));
-  SendAckPacketToPeer();
-  EXPECT_EQ(0x02020202u, writer_->final_bytes_of_last_packet());
-
-  // Now send a packet "Far enough" after the encrypter was set and verify that
-  // the forward-secure encrypter is now used.
-  for (uint64_t i = 0; i < 3 * congestion_window - 1; ++i) {
-    EXPECT_EQ(0x02020202u, writer_->final_bytes_of_last_packet());
-    SendAckPacketToPeer();
-  }
-  EXPECT_EQ(0x03030303u, writer_->final_bytes_of_last_packet());
-}
-
-TEST_P(QuicConnectionTest, BufferNonDecryptablePackets) {
-  // SetFromConfig is always called after construction from InitializeSession.
-  EXPECT_CALL(*send_algorithm_, SetFromConfig(_, _));
-  QuicConfig config;
-  connection_.SetFromConfig(config);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  use_tagging_decrypter();
-
-  const uint8_t tag = 0x07;
-  framer_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(tag));
-
-  // Process an encrypted packet which can not yet be decrypted which should
-  // result in the packet being buffered.
-  ProcessDataPacketAtLevel(kDefaultPathId, 1, kEntropyFlag, !kHasStopWaiting,
-                           ENCRYPTION_INITIAL);
-
-  // Transition to the new encryption state and process another encrypted packet
-  // which should result in the original packet being processed.
-  connection_.SetDecrypter(ENCRYPTION_INITIAL, new StrictTaggingDecrypter(tag));
-  connection_.SetDefaultEncryptionLevel(ENCRYPTION_INITIAL);
-  connection_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(tag));
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(2);
-  ProcessDataPacketAtLevel(kDefaultPathId, 2, kEntropyFlag, !kHasStopWaiting,
-                           ENCRYPTION_INITIAL);
-
-  // Finally, process a third packet and note that we do not reprocess the
-  // buffered packet.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, 3, kEntropyFlag, !kHasStopWaiting,
-                           ENCRYPTION_INITIAL);
-}
-
-TEST_P(QuicConnectionTest, Buffer100NonDecryptablePackets) {
-  // SetFromConfig is always called after construction from InitializeSession.
-  EXPECT_CALL(*send_algorithm_, SetFromConfig(_, _));
-  QuicConfig config;
-  config.set_max_undecryptable_packets(100);
-  connection_.SetFromConfig(config);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  use_tagging_decrypter();
-
-  const uint8_t tag = 0x07;
-  framer_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(tag));
-
-  // Process an encrypted packet which can not yet be decrypted which should
-  // result in the packet being buffered.
-  for (QuicPacketNumber i = 1; i <= 100; ++i) {
-    ProcessDataPacketAtLevel(kDefaultPathId, i, kEntropyFlag, !kHasStopWaiting,
-                             ENCRYPTION_INITIAL);
-  }
-
-  // Transition to the new encryption state and process another encrypted packet
-  // which should result in the original packets being processed.
-  connection_.SetDecrypter(ENCRYPTION_INITIAL, new StrictTaggingDecrypter(tag));
-  connection_.SetDefaultEncryptionLevel(ENCRYPTION_INITIAL);
-  connection_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(tag));
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(101);
-  ProcessDataPacketAtLevel(kDefaultPathId, 101, kEntropyFlag, !kHasStopWaiting,
-                           ENCRYPTION_INITIAL);
-
-  // Finally, process a third packet and note that we do not reprocess the
-  // buffered packet.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, 102, kEntropyFlag, !kHasStopWaiting,
-                           ENCRYPTION_INITIAL);
-}
-
-TEST_P(QuicConnectionTest, TestRetransmitOrder) {
-  connection_.SetMaxTailLossProbes(kDefaultPathId, 0);
-
-  QuicByteCount first_packet_size;
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillOnce(DoAll(SaveArg<3>(&first_packet_size), Return(true)));
-
-  connection_.SendStreamDataWithString(3, "first_packet", 0, !kFin, nullptr);
-  QuicByteCount second_packet_size;
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillOnce(DoAll(SaveArg<3>(&second_packet_size), Return(true)));
-  connection_.SendStreamDataWithString(3, "second_packet", 12, !kFin, nullptr);
-  EXPECT_NE(first_packet_size, second_packet_size);
-  // Advance the clock by huge time to make sure packets will be retransmitted.
-  clock_.AdvanceTime(QuicTime::Delta::FromSeconds(10));
-  {
-    InSequence s;
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, first_packet_size, _));
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, second_packet_size, _));
-  }
-  connection_.GetRetransmissionAlarm()->Fire();
-
-  // Advance again and expect the packets to be sent again in the same order.
-  clock_.AdvanceTime(QuicTime::Delta::FromSeconds(20));
-  {
-    InSequence s;
-    EXPECT_CALL(visitor_, OnPathDegrading());
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, first_packet_size, _));
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, second_packet_size, _));
-  }
-  connection_.GetRetransmissionAlarm()->Fire();
-}
-
-TEST_P(QuicConnectionTest, SetRTOAfterWritingToSocket) {
-  BlockOnNextWrite();
-  connection_.SendStreamDataWithString(1, "foo", 0, !kFin, nullptr);
-  // Make sure that RTO is not started when the packet is queued.
-  EXPECT_FALSE(connection_.GetRetransmissionAlarm()->IsSet());
-
-  // Test that RTO is started once we write to the socket.
-  writer_->SetWritable();
-  connection_.OnCanWrite();
-  EXPECT_TRUE(connection_.GetRetransmissionAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, DelayRTOWithAckReceipt) {
-  connection_.SetMaxTailLossProbes(kDefaultPathId, 0);
-
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(2);
-  connection_.SendStreamDataWithString(2, "foo", 0, !kFin, nullptr);
-  connection_.SendStreamDataWithString(3, "bar", 0, !kFin, nullptr);
-  QuicAlarm* retransmission_alarm = connection_.GetRetransmissionAlarm();
-  EXPECT_TRUE(retransmission_alarm->IsSet());
-  EXPECT_EQ(clock_.Now() + DefaultRetransmissionTime(),
-            retransmission_alarm->deadline());
-
-  // Advance the time right before the RTO, then receive an ack for the first
-  // packet to delay the RTO.
-  clock_.AdvanceTime(DefaultRetransmissionTime());
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  QuicAckFrame ack = InitAckFrame(1);
-  ProcessAckPacket(&ack);
-  EXPECT_TRUE(retransmission_alarm->IsSet());
-  EXPECT_GT(retransmission_alarm->deadline(), clock_.Now());
-
-  // Move forward past the original RTO and ensure the RTO is still pending.
-  clock_.AdvanceTime(2 * DefaultRetransmissionTime());
-
-  // Ensure the second packet gets retransmitted when it finally fires.
-  EXPECT_TRUE(retransmission_alarm->IsSet());
-  EXPECT_LT(retransmission_alarm->deadline(), clock_.ApproximateNow());
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  // Manually cancel the alarm to simulate a real test.
-  connection_.GetRetransmissionAlarm()->Fire();
-
-  // The new retransmitted packet number should set the RTO to a larger value
-  // than previously.
-  EXPECT_TRUE(retransmission_alarm->IsSet());
-  QuicTime next_rto_time = retransmission_alarm->deadline();
-  QuicTime expected_rto_time =
-      connection_.sent_packet_manager().GetRetransmissionTime();
-  EXPECT_EQ(next_rto_time, expected_rto_time);
-}
-
-TEST_P(QuicConnectionTest, TestQueued) {
-  connection_.SetMaxTailLossProbes(kDefaultPathId, 0);
-
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-  BlockOnNextWrite();
-  connection_.SendStreamDataWithString(1, "foo", 0, !kFin, nullptr);
-  EXPECT_EQ(1u, connection_.NumQueuedPackets());
-
-  // Unblock the writes and actually send.
-  writer_->SetWritable();
-  connection_.OnCanWrite();
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-}
-
-TEST_P(QuicConnectionTest, InitialTimeout) {
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(AnyNumber());
-  EXPECT_FALSE(connection_.GetTimeoutAlarm()->IsSet());
-
-  // SetFromConfig sets the initial timeouts before negotiation.
-  EXPECT_CALL(*send_algorithm_, SetFromConfig(_, _));
-  QuicConfig config;
-  connection_.SetFromConfig(config);
-  // Subtract a second from the idle timeout on the client side.
-  QuicTime default_timeout =
-      clock_.ApproximateNow() +
-      QuicTime::Delta::FromSeconds(kInitialIdleTimeoutSecs - 1);
-  EXPECT_EQ(default_timeout, connection_.GetTimeoutAlarm()->deadline());
-
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_NETWORK_IDLE_TIMEOUT, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  // Simulate the timeout alarm firing.
-  clock_.AdvanceTime(QuicTime::Delta::FromSeconds(kInitialIdleTimeoutSecs - 1));
-  connection_.GetTimeoutAlarm()->Fire();
-
-  EXPECT_FALSE(connection_.GetTimeoutAlarm()->IsSet());
-  EXPECT_FALSE(connection_.connected());
-
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_FALSE(connection_.GetPingAlarm()->IsSet());
-  EXPECT_FALSE(connection_.GetResumeWritesAlarm()->IsSet());
-  EXPECT_FALSE(connection_.GetRetransmissionAlarm()->IsSet());
-  EXPECT_FALSE(connection_.GetSendAlarm()->IsSet());
-  EXPECT_FALSE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, HandshakeTimeout) {
-  // Use a shorter handshake timeout than idle timeout for this test.
-  const QuicTime::Delta timeout = QuicTime::Delta::FromSeconds(5);
-  connection_.SetNetworkTimeouts(timeout, timeout);
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(AnyNumber());
-
-  QuicTime handshake_timeout =
-      clock_.ApproximateNow() + timeout - QuicTime::Delta::FromSeconds(1);
-  EXPECT_EQ(handshake_timeout, connection_.GetTimeoutAlarm()->deadline());
-  EXPECT_TRUE(connection_.connected());
-
-  // Send and ack new data 3 seconds later to lengthen the idle timeout.
-  SendStreamDataToPeer(kHeadersStreamId, "GET /", 0, kFin, nullptr);
-  clock_.AdvanceTime(QuicTime::Delta::FromSeconds(3));
-  QuicAckFrame frame = InitAckFrame(1);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&frame);
-
-  // Fire early to verify it wouldn't timeout yet.
-  connection_.GetTimeoutAlarm()->Fire();
-  EXPECT_TRUE(connection_.GetTimeoutAlarm()->IsSet());
-  EXPECT_TRUE(connection_.connected());
-
-  clock_.AdvanceTime(timeout - QuicTime::Delta::FromSeconds(2));
-
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_HANDSHAKE_TIMEOUT, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  // Simulate the timeout alarm firing.
-  connection_.GetTimeoutAlarm()->Fire();
-
-  EXPECT_FALSE(connection_.GetTimeoutAlarm()->IsSet());
-  EXPECT_FALSE(connection_.connected());
-
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_FALSE(connection_.GetPingAlarm()->IsSet());
-  EXPECT_FALSE(connection_.GetResumeWritesAlarm()->IsSet());
-  EXPECT_FALSE(connection_.GetRetransmissionAlarm()->IsSet());
-  EXPECT_FALSE(connection_.GetSendAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, PingAfterSend) {
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_CALL(visitor_, HasOpenDynamicStreams()).WillRepeatedly(Return(true));
-  EXPECT_FALSE(connection_.GetPingAlarm()->IsSet());
-
-  // Advance to 5ms, and send a packet to the peer, which will set
-  // the ping alarm.
-  clock_.AdvanceTime(QuicTime::Delta::FromMilliseconds(5));
-  EXPECT_FALSE(connection_.GetRetransmissionAlarm()->IsSet());
-  SendStreamDataToPeer(kHeadersStreamId, "GET /", 0, kFin, nullptr);
-  EXPECT_TRUE(connection_.GetPingAlarm()->IsSet());
-  EXPECT_EQ(clock_.ApproximateNow() + QuicTime::Delta::FromSeconds(15),
-            connection_.GetPingAlarm()->deadline());
-
-  // Now recevie and ACK of the previous packet, which will move the
-  // ping alarm forward.
-  clock_.AdvanceTime(QuicTime::Delta::FromMilliseconds(5));
-  QuicAckFrame frame = InitAckFrame(1);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&frame);
-  EXPECT_TRUE(connection_.GetPingAlarm()->IsSet());
-  // The ping timer is set slightly less than 15 seconds in the future, because
-  // of the 1s ping timer alarm granularity.
-  EXPECT_EQ(clock_.ApproximateNow() + QuicTime::Delta::FromSeconds(15) -
-                QuicTime::Delta::FromMilliseconds(5),
-            connection_.GetPingAlarm()->deadline());
-
-  writer_->Reset();
-  clock_.AdvanceTime(QuicTime::Delta::FromSeconds(15));
-  connection_.GetPingAlarm()->Fire();
-  EXPECT_EQ(1u, writer_->frame_count());
-  ASSERT_EQ(1u, writer_->ping_frames().size());
-  writer_->Reset();
-
-  EXPECT_CALL(visitor_, HasOpenDynamicStreams()).WillRepeatedly(Return(false));
-  clock_.AdvanceTime(QuicTime::Delta::FromMilliseconds(5));
-  SendAckPacketToPeer();
-
-  EXPECT_FALSE(connection_.GetPingAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, ReducedPingTimeout) {
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_CALL(visitor_, HasOpenDynamicStreams()).WillRepeatedly(Return(true));
-  EXPECT_FALSE(connection_.GetPingAlarm()->IsSet());
-
-  // Use a reduced ping timeout for this connection.
-  connection_.set_ping_timeout(QuicTime::Delta::FromSeconds(10));
-
-  // Advance to 5ms, and send a packet to the peer, which will set
-  // the ping alarm.
-  clock_.AdvanceTime(QuicTime::Delta::FromMilliseconds(5));
-  EXPECT_FALSE(connection_.GetRetransmissionAlarm()->IsSet());
-  SendStreamDataToPeer(kHeadersStreamId, "GET /", 0, kFin, nullptr);
-  EXPECT_TRUE(connection_.GetPingAlarm()->IsSet());
-  EXPECT_EQ(clock_.ApproximateNow() + QuicTime::Delta::FromSeconds(10),
-            connection_.GetPingAlarm()->deadline());
-
-  // Now recevie and ACK of the previous packet, which will move the
-  // ping alarm forward.
-  clock_.AdvanceTime(QuicTime::Delta::FromMilliseconds(5));
-  QuicAckFrame frame = InitAckFrame(1);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&frame);
-  EXPECT_TRUE(connection_.GetPingAlarm()->IsSet());
-  // The ping timer is set slightly less than 10 seconds in the future, because
-  // of the 1s ping timer alarm granularity.
-  EXPECT_EQ(clock_.ApproximateNow() + QuicTime::Delta::FromSeconds(10) -
-                QuicTime::Delta::FromMilliseconds(5),
-            connection_.GetPingAlarm()->deadline());
-
-  writer_->Reset();
-  clock_.AdvanceTime(QuicTime::Delta::FromSeconds(10));
-  connection_.GetPingAlarm()->Fire();
-  EXPECT_EQ(1u, writer_->frame_count());
-  ASSERT_EQ(1u, writer_->ping_frames().size());
-  writer_->Reset();
-
-  EXPECT_CALL(visitor_, HasOpenDynamicStreams()).WillRepeatedly(Return(false));
-  clock_.AdvanceTime(QuicTime::Delta::FromMilliseconds(5));
-  SendAckPacketToPeer();
-
-  EXPECT_FALSE(connection_.GetPingAlarm()->IsSet());
-}
-
-// Tests whether sending an MTU discovery packet to peer successfully causes the
-// maximum packet size to increase.
-TEST_P(QuicConnectionTest, SendMtuDiscoveryPacket) {
-  EXPECT_TRUE(connection_.connected());
-
-  // Send an MTU probe.
-  const size_t new_mtu = kDefaultMaxPacketSize + 100;
-  QuicByteCount mtu_probe_size;
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillOnce(DoAll(SaveArg<3>(&mtu_probe_size), Return(true)));
-  connection_.SendMtuDiscoveryPacket(new_mtu);
-  EXPECT_EQ(new_mtu, mtu_probe_size);
-  EXPECT_EQ(1u, creator_->packet_number());
-
-  // Send more than MTU worth of data.  No acknowledgement was received so far,
-  // so the MTU should be at its old value.
-  const string data(kDefaultMaxPacketSize + 1, '.');
-  QuicByteCount size_before_mtu_change;
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillOnce(DoAll(SaveArg<3>(&size_before_mtu_change), Return(true)))
-      .WillOnce(Return(true));
-  connection_.SendStreamDataWithString(3, data, 0, kFin, nullptr);
-  EXPECT_EQ(3u, creator_->packet_number());
-  EXPECT_EQ(kDefaultMaxPacketSize, size_before_mtu_change);
-
-  // Acknowledge all packets so far.
-  QuicAckFrame probe_ack = InitAckFrame(3);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&probe_ack);
-  EXPECT_EQ(new_mtu, connection_.max_packet_length());
-
-  // Send the same data again.  Check that it fits into a single packet now.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-  connection_.SendStreamDataWithString(3, data, 0, kFin, nullptr);
-  EXPECT_EQ(4u, creator_->packet_number());
-}
-
-// Tests whether MTU discovery does not happen when it is not explicitly enabled
-// by the connection options.
-TEST_P(QuicConnectionTest, MtuDiscoveryDisabled) {
-  EXPECT_TRUE(connection_.connected());
-
-  const QuicPacketCount number_of_packets = kPacketsBetweenMtuProbesBase * 2;
-  for (QuicPacketCount i = 0; i < number_of_packets; i++) {
-    SendStreamDataToPeer(3, ".", i, /*fin=*/false, nullptr);
-    EXPECT_FALSE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-    EXPECT_EQ(0u, connection_.mtu_probe_count());
-  }
-}
-
-// Tests whether MTU discovery works when the probe gets acknowledged on the
-// first try.
-TEST_P(QuicConnectionTest, MtuDiscoveryEnabled) {
-  EXPECT_TRUE(connection_.connected());
-
-  connection_.EnablePathMtuDiscovery(send_algorithm_);
-
-  // Send enough packets so that the next one triggers path MTU discovery.
-  for (QuicPacketCount i = 0; i < kPacketsBetweenMtuProbesBase - 1; i++) {
-    SendStreamDataToPeer(3, ".", i, /*fin=*/false, nullptr);
-    ASSERT_FALSE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-  }
-
-  // Trigger the probe.
-  SendStreamDataToPeer(3, "!", kPacketsBetweenMtuProbesBase,
-                       /*fin=*/false, nullptr);
-  ASSERT_TRUE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-  QuicByteCount probe_size;
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillOnce(DoAll(SaveArg<3>(&probe_size), Return(true)));
-  connection_.GetMtuDiscoveryAlarm()->Fire();
-  EXPECT_EQ(kMtuDiscoveryTargetPacketSizeHigh, probe_size);
-
-  const QuicPacketCount probe_packet_number = kPacketsBetweenMtuProbesBase + 1;
-  ASSERT_EQ(probe_packet_number, creator_->packet_number());
-
-  // Acknowledge all packets sent so far.
-  QuicAckFrame probe_ack = InitAckFrame(probe_packet_number);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&probe_ack);
-  EXPECT_EQ(kMtuDiscoveryTargetPacketSizeHigh, connection_.max_packet_length());
-  EXPECT_EQ(0u, connection_.GetBytesInFlight(kDefaultPathId));
-
-  // Send more packets, and ensure that none of them sets the alarm.
-  for (QuicPacketCount i = 0; i < 4 * kPacketsBetweenMtuProbesBase; i++) {
-    SendStreamDataToPeer(3, ".", i, /*fin=*/false, nullptr);
-    ASSERT_FALSE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-  }
-
-  EXPECT_EQ(1u, connection_.mtu_probe_count());
-}
-
-// Tests whether MTU discovery works correctly when the probes never get
-// acknowledged.
-TEST_P(QuicConnectionTest, MtuDiscoveryFailed) {
-  EXPECT_TRUE(connection_.connected());
-
-  connection_.EnablePathMtuDiscovery(send_algorithm_);
-
-  const QuicTime::Delta rtt = QuicTime::Delta::FromMilliseconds(100);
-
-  EXPECT_EQ(kPacketsBetweenMtuProbesBase,
-            QuicConnectionPeer::GetPacketsBetweenMtuProbes(&connection_));
-  // Lower the number of probes between packets in order to make the test go
-  // much faster.
-  const QuicPacketCount packets_between_probes_base = 10;
-  QuicConnectionPeer::SetPacketsBetweenMtuProbes(&connection_,
-                                                 packets_between_probes_base);
-  QuicConnectionPeer::SetNextMtuProbeAt(&connection_,
-                                        packets_between_probes_base);
-
-  // This tests sends more packets than strictly necessary to make sure that if
-  // the connection was to send more discovery packets than needed, those would
-  // get caught as well.
-  const QuicPacketCount number_of_packets =
-      packets_between_probes_base * (1 << (kMtuDiscoveryAttempts + 1));
-  vector<QuicPacketNumber> mtu_discovery_packets;
-  // Called by the first ack.
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  // Called on many acks.
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _))
-      .Times(AnyNumber());
-  for (QuicPacketCount i = 0; i < number_of_packets; i++) {
-    SendStreamDataToPeer(3, "!", i, /*fin=*/false, nullptr);
-    clock_.AdvanceTime(rtt);
-
-    // Receive an ACK, which marks all data packets as received, and all MTU
-    // discovery packets as missing.
-    QuicAckFrame ack = InitAckFrame(creator_->packet_number());
-    for (QuicPacketNumber& packet : mtu_discovery_packets) {
-      NackPacket(packet, &ack);
-    }
-    ProcessAckPacket(&ack);
-
-    // Trigger MTU probe if it would be scheduled now.
-    if (!connection_.GetMtuDiscoveryAlarm()->IsSet()) {
-      continue;
-    }
-
-    // Fire the alarm.  The alarm should cause a packet to be sent.
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-        .WillOnce(Return(true));
-    connection_.GetMtuDiscoveryAlarm()->Fire();
-    // Record the packet number of the MTU discovery packet in order to
-    // mark it as NACK'd.
-    mtu_discovery_packets.push_back(creator_->packet_number());
-  }
-
-  // Ensure the number of packets between probes grows exponentially by checking
-  // it against the closed-form expression for the packet number.
-  ASSERT_EQ(kMtuDiscoveryAttempts, mtu_discovery_packets.size());
-  for (QuicPacketNumber i = 0; i < kMtuDiscoveryAttempts; i++) {
-    // 2^0 + 2^1 + 2^2 + ... + 2^n = 2^(n + 1) - 1
-    const QuicPacketCount packets_between_probes =
-        packets_between_probes_base * ((1 << (i + 1)) - 1);
-    EXPECT_EQ(packets_between_probes + (i + 1), mtu_discovery_packets[i]);
-  }
-
-  EXPECT_FALSE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-  EXPECT_EQ(kDefaultMaxPacketSize, connection_.max_packet_length());
-  EXPECT_EQ(kMtuDiscoveryAttempts, connection_.mtu_probe_count());
-}
-
-// Tests whether MTU discovery works when the writer has a limit on how large a
-// packet can be.
-TEST_P(QuicConnectionTest, MtuDiscoveryWriterLimited) {
-  EXPECT_TRUE(connection_.connected());
-
-  const QuicByteCount mtu_limit = kMtuDiscoveryTargetPacketSizeHigh - 1;
-  writer_->set_max_packet_size(mtu_limit);
-  connection_.EnablePathMtuDiscovery(send_algorithm_);
-
-  // Send enough packets so that the next one triggers path MTU discovery.
-  for (QuicPacketCount i = 0; i < kPacketsBetweenMtuProbesBase - 1; i++) {
-    SendStreamDataToPeer(3, ".", i, /*fin=*/false, nullptr);
-    ASSERT_FALSE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-  }
-
-  // Trigger the probe.
-  SendStreamDataToPeer(3, "!", kPacketsBetweenMtuProbesBase,
-                       /*fin=*/false, nullptr);
-  ASSERT_TRUE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-  QuicByteCount probe_size;
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillOnce(DoAll(SaveArg<3>(&probe_size), Return(true)));
-  connection_.GetMtuDiscoveryAlarm()->Fire();
-  EXPECT_EQ(mtu_limit, probe_size);
-
-  const QuicPacketCount probe_sequence_number =
-      kPacketsBetweenMtuProbesBase + 1;
-  ASSERT_EQ(probe_sequence_number, creator_->packet_number());
-
-  // Acknowledge all packets sent so far.
-  QuicAckFrame probe_ack = InitAckFrame(probe_sequence_number);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&probe_ack);
-  EXPECT_EQ(mtu_limit, connection_.max_packet_length());
-  EXPECT_EQ(0u, connection_.GetBytesInFlight(kDefaultPathId));
-
-  // Send more packets, and ensure that none of them sets the alarm.
-  for (QuicPacketCount i = 0; i < 4 * kPacketsBetweenMtuProbesBase; i++) {
-    SendStreamDataToPeer(3, ".", i, /*fin=*/false, nullptr);
-    ASSERT_FALSE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-  }
-
-  EXPECT_EQ(1u, connection_.mtu_probe_count());
-}
-
-// Tests whether MTU discovery works when the writer returns an error despite
-// advertising higher packet length.
-TEST_P(QuicConnectionTest, MtuDiscoveryWriterFailed) {
-  FLAGS_graceful_emsgsize_on_mtu_probe = true;
-  EXPECT_TRUE(connection_.connected());
-
-  const QuicByteCount mtu_limit = kMtuDiscoveryTargetPacketSizeHigh - 1;
-  const QuicByteCount initial_mtu = connection_.max_packet_length();
-  EXPECT_LT(initial_mtu, mtu_limit);
-  writer_->set_max_packet_size(mtu_limit);
-  connection_.EnablePathMtuDiscovery(send_algorithm_);
-
-  // Send enough packets so that the next one triggers path MTU discovery.
-  for (QuicPacketCount i = 0; i < kPacketsBetweenMtuProbesBase - 1; i++) {
-    SendStreamDataToPeer(3, ".", i, /*fin=*/false, nullptr);
-    ASSERT_FALSE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-  }
-
-  // Trigger the probe.
-  SendStreamDataToPeer(3, "!", kPacketsBetweenMtuProbesBase,
-                       /*fin=*/false, nullptr);
-  ASSERT_TRUE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-  writer_->SimulateNextPacketTooLarge();
-  connection_.GetMtuDiscoveryAlarm()->Fire();
-  ASSERT_TRUE(connection_.connected());
-
-  // Send more data.
-  QuicPacketNumber probe_number = creator_->packet_number();
-  QuicPacketCount extra_packets = kPacketsBetweenMtuProbesBase * 3;
-  for (QuicPacketCount i = 0; i < extra_packets; i++) {
-    connection_.EnsureWritableAndSendStreamData5();
-    ASSERT_FALSE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-  }
-
-  // Acknowledge all packets sent so far, except for the lost probe.
-  QuicAckFrame probe_ack = InitAckFrame(creator_->packet_number());
-  NackPacket(probe_number, &probe_ack);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&probe_ack);
-  EXPECT_EQ(initial_mtu, connection_.max_packet_length());
-
-  // Send more packets, and ensure that none of them sets the alarm.
-  for (QuicPacketCount i = 0; i < 4 * kPacketsBetweenMtuProbesBase; i++) {
-    connection_.EnsureWritableAndSendStreamData5();
-    ASSERT_FALSE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-  }
-
-  EXPECT_EQ(initial_mtu, connection_.max_packet_length());
-  EXPECT_EQ(1u, connection_.mtu_probe_count());
-}
-
-TEST_P(QuicConnectionTest, NoMtuDiscoveryAfterConnectionClosed) {
-  EXPECT_TRUE(connection_.connected());
-
-  connection_.EnablePathMtuDiscovery(send_algorithm_);
-
-  // Send enough packets so that the next one triggers path MTU discovery.
-  for (QuicPacketCount i = 0; i < kPacketsBetweenMtuProbesBase - 1; i++) {
-    SendStreamDataToPeer(3, ".", i, /*fin=*/false, nullptr);
-    ASSERT_FALSE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-  }
-
-  SendStreamDataToPeer(3, "!", kPacketsBetweenMtuProbesBase,
-                       /*fin=*/false, nullptr);
-  EXPECT_TRUE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-
-  EXPECT_CALL(visitor_, OnConnectionClosed(_, _, _));
-  connection_.CloseConnection(QUIC_PEER_GOING_AWAY, "no reason",
-                              ConnectionCloseBehavior::SILENT_CLOSE);
-  EXPECT_FALSE(connection_.GetMtuDiscoveryAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, TimeoutAfterSend) {
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_CALL(*send_algorithm_, SetFromConfig(_, _));
-  QuicConfig config;
-  connection_.SetFromConfig(config);
-  EXPECT_FALSE(QuicConnectionPeer::IsSilentCloseEnabled(&connection_));
-
-  const QuicTime::Delta initial_idle_timeout =
-      QuicTime::Delta::FromSeconds(kInitialIdleTimeoutSecs - 1);
-  const QuicTime::Delta five_ms = QuicTime::Delta::FromMilliseconds(5);
-  QuicTime default_timeout = clock_.ApproximateNow() + initial_idle_timeout;
-
-  // When we send a packet, the timeout will change to 5ms +
-  // kInitialIdleTimeoutSecs.
-  clock_.AdvanceTime(five_ms);
-  SendStreamDataToPeer(kClientDataStreamId1, "foo", 0, kFin, nullptr);
-  EXPECT_EQ(default_timeout, connection_.GetTimeoutAlarm()->deadline());
-
-  // Now send more data. This will not move the timeout becase
-  // no data has been recieved since the previous write.
-  clock_.AdvanceTime(five_ms);
-  SendStreamDataToPeer(kClientDataStreamId1, "foo", 0, kFin, nullptr);
-  EXPECT_EQ(default_timeout, connection_.GetTimeoutAlarm()->deadline());
-
-  // The original alarm will fire.  We should not time out because we had a
-  // network event at t=5ms.  The alarm will reregister.
-  clock_.AdvanceTime(initial_idle_timeout - five_ms - five_ms);
-  EXPECT_EQ(default_timeout, clock_.ApproximateNow());
-  connection_.GetTimeoutAlarm()->Fire();
-  EXPECT_TRUE(connection_.GetTimeoutAlarm()->IsSet());
-  EXPECT_TRUE(connection_.connected());
-  if (FLAGS_quic_better_last_send_for_timeout) {
-    EXPECT_EQ(default_timeout + five_ms,
-              connection_.GetTimeoutAlarm()->deadline());
-  } else {
-    EXPECT_EQ(default_timeout + five_ms + five_ms,
-              connection_.GetTimeoutAlarm()->deadline());
-  }
-
-  // This time, we should time out.
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_NETWORK_IDLE_TIMEOUT, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  clock_.AdvanceTime(five_ms);
-  EXPECT_EQ(default_timeout + five_ms, clock_.ApproximateNow());
-  connection_.GetTimeoutAlarm()->Fire();
-  EXPECT_FALSE(connection_.GetTimeoutAlarm()->IsSet());
-  EXPECT_FALSE(connection_.connected());
-}
-
-TEST_P(QuicConnectionTest, TimeoutAfterRetransmission) {
-  FLAGS_quic_better_last_send_for_timeout = true;
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_CALL(*send_algorithm_, SetFromConfig(_, _));
-  QuicConfig config;
-  connection_.SetFromConfig(config);
-  EXPECT_FALSE(QuicConnectionPeer::IsSilentCloseEnabled(&connection_));
-
-  const QuicTime start_time = clock_.Now();
-  const QuicTime::Delta initial_idle_timeout =
-      QuicTime::Delta::FromSeconds(kInitialIdleTimeoutSecs - 1);
-  QuicTime default_timeout = clock_.Now() + initial_idle_timeout;
-
-  connection_.SetMaxTailLossProbes(kDefaultPathId, 0);
-  const QuicTime default_retransmission_time =
-      start_time + DefaultRetransmissionTime();
-
-  ASSERT_LT(default_retransmission_time, default_timeout);
-
-  // When we send a packet, the timeout will change to 5 ms +
-  // kInitialIdleTimeoutSecs (but it will not reschedule the alarm).
-  const QuicTime::Delta five_ms = QuicTime::Delta::FromMilliseconds(5);
-  const QuicTime send_time = start_time + five_ms;
-  clock_.AdvanceTime(five_ms);
-  ASSERT_EQ(send_time, clock_.Now());
-  SendStreamDataToPeer(kClientDataStreamId1, "foo", 0, kFin, nullptr);
-  EXPECT_EQ(default_timeout, connection_.GetTimeoutAlarm()->deadline());
-
-  // Move forward 5 ms and receive a packet, which will move the timeout
-  // forward 5 ms more (but will not reschedule the alarm).
-  const QuicTime receive_time = send_time + five_ms;
-  clock_.AdvanceTime(receive_time - clock_.Now());
-  ASSERT_EQ(receive_time, clock_.Now());
-  ProcessPacket(kDefaultPathId, 1);
-
-  // Now move forward to the retransmission time and retransmit the
-  // packet, which should move the timeout forward again (but will not
-  // reschedule the alarm).
-  EXPECT_EQ(default_retransmission_time + five_ms,
-            connection_.GetRetransmissionAlarm()->deadline());
-  // Simulate the retransmission alarm firing.
-  const QuicTime rto_time = send_time + DefaultRetransmissionTime();
-  const QuicTime final_timeout = rto_time + initial_idle_timeout;
-  clock_.AdvanceTime(rto_time - clock_.Now());
-  ASSERT_EQ(rto_time, clock_.Now());
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, 2u, _, _));
-  connection_.GetRetransmissionAlarm()->Fire();
-
-  // Advance to the original timeout and fire the alarm. The connection should
-  // timeout, and the alarm should be registered based on the time of the
-  // retransmission.
-  clock_.AdvanceTime(default_timeout - clock_.Now());
-  ASSERT_EQ(default_timeout.ToDebuggingValue(),
-            clock_.Now().ToDebuggingValue());
-  EXPECT_EQ(default_timeout, clock_.Now());
-  connection_.GetTimeoutAlarm()->Fire();
-  EXPECT_TRUE(connection_.GetTimeoutAlarm()->IsSet());
-  EXPECT_TRUE(connection_.connected());
-  ASSERT_EQ(final_timeout.ToDebuggingValue(),
-            connection_.GetTimeoutAlarm()->deadline().ToDebuggingValue());
-
-  // This time, we should time out.
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_NETWORK_IDLE_TIMEOUT, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  clock_.AdvanceTime(final_timeout - clock_.Now());
-  EXPECT_EQ(connection_.GetTimeoutAlarm()->deadline(), clock_.Now());
-  EXPECT_EQ(final_timeout, clock_.Now());
-  connection_.GetTimeoutAlarm()->Fire();
-  EXPECT_FALSE(connection_.GetTimeoutAlarm()->IsSet());
-  EXPECT_FALSE(connection_.connected());
-}
-
-TEST_P(QuicConnectionTest, NewTimeoutAfterSendSilentClose) {
-  // Same test as above, but complete a handshake which enables silent close,
-  // causing no connection close packet to be sent.
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_CALL(*send_algorithm_, SetFromConfig(_, _));
-  QuicConfig config;
-
-  // Create a handshake message that also enables silent close.
-  CryptoHandshakeMessage msg;
-  string error_details;
-  QuicConfig client_config;
-  client_config.SetInitialStreamFlowControlWindowToSend(
-      kInitialStreamFlowControlWindowForTest);
-  client_config.SetInitialSessionFlowControlWindowToSend(
-      kInitialSessionFlowControlWindowForTest);
-  client_config.SetIdleConnectionStateLifetime(
-      QuicTime::Delta::FromSeconds(kDefaultIdleTimeoutSecs),
-      QuicTime::Delta::FromSeconds(kDefaultIdleTimeoutSecs));
-  client_config.ToHandshakeMessage(&msg);
-  const QuicErrorCode error =
-      config.ProcessPeerHello(msg, CLIENT, &error_details);
-  EXPECT_EQ(QUIC_NO_ERROR, error);
-
-  connection_.SetFromConfig(config);
-  EXPECT_TRUE(QuicConnectionPeer::IsSilentCloseEnabled(&connection_));
-
-  const QuicTime::Delta default_idle_timeout =
-      QuicTime::Delta::FromSeconds(kDefaultIdleTimeoutSecs - 1);
-  const QuicTime::Delta five_ms = QuicTime::Delta::FromMilliseconds(5);
-  QuicTime default_timeout = clock_.ApproximateNow() + default_idle_timeout;
-
-  // When we send a packet, the timeout will change to 5ms +
-  // kInitialIdleTimeoutSecs.
-  clock_.AdvanceTime(five_ms);
-  SendStreamDataToPeer(kClientDataStreamId1, "foo", 0, kFin, nullptr);
-  EXPECT_EQ(default_timeout, connection_.GetTimeoutAlarm()->deadline());
-
-  // Now send more data. This will not move the timeout becase
-  // no data has been recieved since the previous write.
-  clock_.AdvanceTime(five_ms);
-  SendStreamDataToPeer(kClientDataStreamId1, "foo", 0, kFin, nullptr);
-  EXPECT_EQ(default_timeout, connection_.GetTimeoutAlarm()->deadline());
-
-  // The original alarm will fire.  We should not time out because we had a
-  // network event at t=5ms.  The alarm will reregister.
-  clock_.AdvanceTime(default_idle_timeout - five_ms - five_ms);
-  EXPECT_EQ(default_timeout, clock_.ApproximateNow());
-  connection_.GetTimeoutAlarm()->Fire();
-  EXPECT_TRUE(connection_.GetTimeoutAlarm()->IsSet());
-  EXPECT_TRUE(connection_.connected());
-  if (FLAGS_quic_better_last_send_for_timeout) {
-    EXPECT_EQ(default_timeout + five_ms,
-              connection_.GetTimeoutAlarm()->deadline());
-  } else {
-    EXPECT_EQ(default_timeout + five_ms + five_ms,
-              connection_.GetTimeoutAlarm()->deadline());
-  }
-
-  // This time, we should time out.
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_NETWORK_IDLE_TIMEOUT, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  clock_.AdvanceTime(five_ms);
-  EXPECT_EQ(default_timeout + five_ms, clock_.ApproximateNow());
-  connection_.GetTimeoutAlarm()->Fire();
-  EXPECT_FALSE(connection_.GetTimeoutAlarm()->IsSet());
-  EXPECT_FALSE(connection_.connected());
-}
-
-TEST_P(QuicConnectionTest, TimeoutAfterReceive) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_CALL(*send_algorithm_, SetFromConfig(_, _));
-  QuicConfig config;
-  connection_.SetFromConfig(config);
-  EXPECT_FALSE(QuicConnectionPeer::IsSilentCloseEnabled(&connection_));
-
-  const QuicTime::Delta initial_idle_timeout =
-      QuicTime::Delta::FromSeconds(kInitialIdleTimeoutSecs - 1);
-  const QuicTime::Delta five_ms = QuicTime::Delta::FromMilliseconds(5);
-  QuicTime default_timeout = clock_.ApproximateNow() + initial_idle_timeout;
-
-  connection_.SendStreamDataWithString(kClientDataStreamId1, "foo", 0, !kFin,
-                                       nullptr);
-  connection_.SendStreamDataWithString(kClientDataStreamId1, "foo", 3, !kFin,
-                                       nullptr);
-
-  EXPECT_EQ(default_timeout, connection_.GetTimeoutAlarm()->deadline());
-  clock_.AdvanceTime(five_ms);
-
-  // When we receive a packet, the timeout will change to 5ms +
-  // kInitialIdleTimeoutSecs.
-  QuicAckFrame ack = InitAckFrame(2);
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&ack);
-
-  // The original alarm will fire.  We should not time out because we had a
-  // network event at t=5ms.  The alarm will reregister.
-  clock_.AdvanceTime(initial_idle_timeout - five_ms);
-  EXPECT_EQ(default_timeout, clock_.ApproximateNow());
-  connection_.GetTimeoutAlarm()->Fire();
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_TRUE(connection_.GetTimeoutAlarm()->IsSet());
-  EXPECT_EQ(default_timeout + five_ms,
-            connection_.GetTimeoutAlarm()->deadline());
-
-  // This time, we should time out.
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_NETWORK_IDLE_TIMEOUT, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  clock_.AdvanceTime(five_ms);
-  EXPECT_EQ(default_timeout + five_ms, clock_.ApproximateNow());
-  connection_.GetTimeoutAlarm()->Fire();
-  EXPECT_FALSE(connection_.GetTimeoutAlarm()->IsSet());
-  EXPECT_FALSE(connection_.connected());
-}
-
-TEST_P(QuicConnectionTest, TimeoutAfterReceiveNotSendWhenUnacked) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_CALL(*send_algorithm_, SetFromConfig(_, _));
-  QuicConfig config;
-  connection_.SetFromConfig(config);
-  EXPECT_FALSE(QuicConnectionPeer::IsSilentCloseEnabled(&connection_));
-
-  const QuicTime::Delta initial_idle_timeout =
-      QuicTime::Delta::FromSeconds(kInitialIdleTimeoutSecs - 1);
-  connection_.SetNetworkTimeouts(
-      QuicTime::Delta::Infinite(),
-      initial_idle_timeout + QuicTime::Delta::FromSeconds(1));
-  const QuicTime::Delta five_ms = QuicTime::Delta::FromMilliseconds(5);
-  QuicTime default_timeout = clock_.ApproximateNow() + initial_idle_timeout;
-
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  connection_.SendStreamDataWithString(kClientDataStreamId1, "foo", 0, !kFin,
-                                       nullptr);
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  connection_.SendStreamDataWithString(kClientDataStreamId1, "foo", 3, !kFin,
-                                       nullptr);
-
-  EXPECT_EQ(default_timeout, connection_.GetTimeoutAlarm()->deadline());
-
-  clock_.AdvanceTime(five_ms);
-
-  // When we receive a packet, the timeout will change to 5ms +
-  // kInitialIdleTimeoutSecs.
-  QuicAckFrame ack = InitAckFrame(2);
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&ack);
-
-  // The original alarm will fire.  We should not time out because we had a
-  // network event at t=5ms.  The alarm will reregister.
-  clock_.AdvanceTime(initial_idle_timeout - five_ms);
-  EXPECT_EQ(default_timeout, clock_.ApproximateNow());
-  connection_.GetTimeoutAlarm()->Fire();
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_TRUE(connection_.GetTimeoutAlarm()->IsSet());
-  EXPECT_EQ(default_timeout + five_ms,
-            connection_.GetTimeoutAlarm()->deadline());
-
-  // Now, send packets while advancing the time and verify that the connection
-  // eventually times out.
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_NETWORK_IDLE_TIMEOUT, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(AnyNumber());
-  for (int i = 0; i < 100 && connection_.connected(); ++i) {
-    VLOG(1) << "sending data packet";
-    connection_.SendStreamDataWithString(kClientDataStreamId1, "foo", 0, !kFin,
-                                         nullptr);
-    connection_.GetTimeoutAlarm()->Fire();
-    clock_.AdvanceTime(QuicTime::Delta::FromSeconds(1));
-  }
-  EXPECT_FALSE(connection_.connected());
-  EXPECT_FALSE(connection_.GetTimeoutAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, TimeoutAfter5RTOs) {
-  connection_.SetMaxTailLossProbes(kDefaultPathId, 2);
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_CALL(*send_algorithm_, SetFromConfig(_, _));
-  QuicConfig config;
-  QuicTagVector connection_options;
-  connection_options.push_back(k5RTO);
-  config.SetConnectionOptionsToSend(connection_options);
-  connection_.SetFromConfig(config);
-
-  // Send stream data.
-  SendStreamDataToPeer(kClientDataStreamId1, "foo", 0, kFin, nullptr);
-
-  EXPECT_CALL(visitor_, OnPathDegrading());
-  // Fire the retransmission alarm 6 times, twice for TLP and 4 times for RTO.
-  for (int i = 0; i < 6; ++i) {
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-    connection_.GetRetransmissionAlarm()->Fire();
-    EXPECT_TRUE(connection_.GetTimeoutAlarm()->IsSet());
-    EXPECT_TRUE(connection_.connected());
-  }
-
-  EXPECT_EQ(2u, connection_.sent_packet_manager().GetConsecutiveTlpCount());
-  EXPECT_EQ(4u, connection_.sent_packet_manager().GetConsecutiveRtoCount());
-  // This time, we should time out.
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_TOO_MANY_RTOS, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  connection_.GetRetransmissionAlarm()->Fire();
-  EXPECT_FALSE(connection_.GetTimeoutAlarm()->IsSet());
-  EXPECT_FALSE(connection_.connected());
-}
-
-TEST_P(QuicConnectionTest, SendScheduler) {
-  // Test that if we send a packet without delay, it is not queued.
-  QuicPacket* packet =
-      ConstructDataPacket(kDefaultPathId, 1, !kEntropyFlag, !kHasStopWaiting);
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  connection_.SendPacket(ENCRYPTION_NONE, kDefaultPathId, 1, packet,
-                         kTestEntropyHash, HAS_RETRANSMITTABLE_DATA, false,
-                         false);
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-}
-
-TEST_P(QuicConnectionTest, FailToSendFirstPacket) {
-  // Test that the connection does not crash when it fails to send the first
-  // packet at which point self_address_ might be uninitialized.
-  EXPECT_CALL(visitor_, OnConnectionClosed(_, _, _)).Times(1);
-  QuicPacket* packet =
-      ConstructDataPacket(kDefaultPathId, 1, !kEntropyFlag, !kHasStopWaiting);
-  writer_->SetShouldWriteFail();
-  connection_.SendPacket(ENCRYPTION_NONE, kDefaultPathId, 1, packet,
-                         kTestEntropyHash, HAS_RETRANSMITTABLE_DATA, false,
-                         false);
-}
-
-TEST_P(QuicConnectionTest, SendSchedulerEAGAIN) {
-  QuicPacket* packet =
-      ConstructDataPacket(kDefaultPathId, 1, !kEntropyFlag, !kHasStopWaiting);
-  BlockOnNextWrite();
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, 1, _, _)).Times(0);
-  connection_.SendPacket(ENCRYPTION_NONE, kDefaultPathId, 1, packet,
-                         kTestEntropyHash, HAS_RETRANSMITTABLE_DATA, false,
-                         false);
-  EXPECT_EQ(1u, connection_.NumQueuedPackets());
-}
-
-TEST_P(QuicConnectionTest, TestQueueLimitsOnSendStreamData) {
-  // All packets carry version info till version is negotiated.
-  size_t payload_length;
-  size_t length = GetPacketLengthForOneStream(
-      connection_.version(), kIncludeVersion, !kIncludePathId,
-      !kIncludeDiversificationNonce, PACKET_8BYTE_CONNECTION_ID,
-      PACKET_1BYTE_PACKET_NUMBER, &payload_length);
-  connection_.SetMaxPacketLength(length);
-
-  // Queue the first packet.
-  EXPECT_CALL(*send_algorithm_, TimeUntilSend(_, _))
-      .WillOnce(testing::Return(QuicTime::Delta::FromMicroseconds(10)));
-  const string payload(payload_length, 'a');
-  EXPECT_EQ(0u,
-            connection_.SendStreamDataWithString(3, payload, 0, !kFin, nullptr)
-                .bytes_consumed);
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-}
-
-TEST_P(QuicConnectionTest, LoopThroughSendingPackets) {
-  // All packets carry version info till version is negotiated.
-  size_t payload_length;
-  // GetPacketLengthForOneStream() assumes a stream offset of 0 in determining
-  // packet length. The size of the offset field in a stream frame is 0 for
-  // offset 0, and 2 for non-zero offsets up through 16K. Increase
-  // max_packet_length by 2 so that subsequent packets containing subsequent
-  // stream frames with non-zero offets will fit within the packet length.
-  size_t length =
-      2 + GetPacketLengthForOneStream(
-              connection_.version(), kIncludeVersion, !kIncludePathId,
-              !kIncludeDiversificationNonce, PACKET_8BYTE_CONNECTION_ID,
-              PACKET_1BYTE_PACKET_NUMBER, &payload_length);
-  connection_.SetMaxPacketLength(length);
-
-  // Queue the first packet.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(7);
-  // The first stream frame will have 2 fewer overhead bytes than the other six.
-  const string payload(payload_length * 7 + 2, 'a');
-  EXPECT_EQ(payload.size(),
-            connection_.SendStreamDataWithString(1, payload, 0, !kFin, nullptr)
-                .bytes_consumed);
-}
-
-TEST_P(QuicConnectionTest, LoopThroughSendingPacketsWithTruncation) {
-  // Set up a larger payload than will fit in one packet.
-  const string payload(connection_.max_packet_length(), 'a');
-  EXPECT_CALL(*send_algorithm_, SetFromConfig(_, _)).Times(AnyNumber());
-
-  // Now send some packets with no truncation.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(2);
-  EXPECT_EQ(payload.size(),
-            connection_.SendStreamDataWithString(3, payload, 0, !kFin, nullptr)
-                .bytes_consumed);
-  // Track the size of the second packet here.  The overhead will be the largest
-  // we see in this test, due to the non-truncated connection id.
-  size_t non_truncated_packet_size = writer_->last_packet_size();
-
-  // Change to a 0 byte connection id.
-  QuicConfig config;
-  QuicConfigPeer::SetReceivedBytesForConnectionId(&config, 0);
-  connection_.SetFromConfig(config);
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(2);
-  EXPECT_EQ(payload.size(),
-            connection_.SendStreamDataWithString(3, payload, 0, !kFin, nullptr)
-                .bytes_consumed);
-  // Just like above, we save 8 bytes on payload, and 8 on truncation.
-  EXPECT_EQ(non_truncated_packet_size, writer_->last_packet_size() + 8 * 2);
-}
-
-TEST_P(QuicConnectionTest, SendDelayedAck) {
-  QuicTime ack_time = clock_.ApproximateNow() + DefaultDelayedAckTime();
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  const uint8_t tag = 0x07;
-  connection_.SetDecrypter(ENCRYPTION_INITIAL, new StrictTaggingDecrypter(tag));
-  framer_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(tag));
-  // Process a packet from the non-crypto stream.
-  frame1_.stream_id = 3;
-
-  // The same as ProcessPacket(1) except that ENCRYPTION_INITIAL is used
-  // instead of ENCRYPTION_NONE.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, 1, !kEntropyFlag, !kHasStopWaiting,
-                           ENCRYPTION_INITIAL);
-
-  // Check if delayed ack timer is running for the expected interval.
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_EQ(ack_time, connection_.GetAckAlarm()->deadline());
-  // Simulate delayed ack alarm firing.
-  connection_.GetAckAlarm()->Fire();
-  // Check that ack is sent and that delayed ack alarm is reset.
-  EXPECT_EQ(2u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, SendDelayedAckDecimation) {
-  QuicConnectionPeer::SetAckMode(&connection_, QuicConnection::ACK_DECIMATION);
-
-  const size_t kMinRttMs = 40;
-  RttStats* rtt_stats = const_cast<RttStats*>(manager_->GetRttStats());
-  rtt_stats->UpdateRtt(QuicTime::Delta::FromMilliseconds(kMinRttMs),
-                       QuicTime::Delta::Zero(), QuicTime::Zero());
-  // The ack time should be based on min_rtt/4, since it's less than the
-  // default delayed ack time.
-  QuicTime ack_time = clock_.ApproximateNow() +
-                      QuicTime::Delta::FromMilliseconds(kMinRttMs / 4);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  const uint8_t tag = 0x07;
-  connection_.SetDecrypter(ENCRYPTION_INITIAL, new StrictTaggingDecrypter(tag));
-  framer_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(tag));
-  // Process a packet from the non-crypto stream.
-  frame1_.stream_id = 3;
-
-  // Process all the initial packets in order so there aren't missing packets.
-  QuicPacketNumber kFirstDecimatedPacket = 101;
-  for (unsigned int i = 0; i < kFirstDecimatedPacket - 1; ++i) {
-    EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-    ProcessDataPacketAtLevel(kDefaultPathId, 1 + i, !kEntropyFlag,
-                             !kHasStopWaiting, ENCRYPTION_INITIAL);
-  }
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  // The same as ProcessPacket(1) except that ENCRYPTION_INITIAL is used
-  // instead of ENCRYPTION_NONE.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket, !kEntropyFlag,
-                           !kHasStopWaiting, ENCRYPTION_INITIAL);
-
-  // Check if delayed ack timer is running for the expected interval.
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_EQ(ack_time, connection_.GetAckAlarm()->deadline());
-
-  // The 10th received packet causes an ack to be sent.
-  for (int i = 0; i < 9; ++i) {
-    EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-    EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-    ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket + 1 + i,
-                             !kEntropyFlag, !kHasStopWaiting,
-                             ENCRYPTION_INITIAL);
-  }
-  // Check that ack is sent and that delayed ack alarm is reset.
-  EXPECT_EQ(2u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, SendDelayedAckDecimationEighthRtt) {
-  QuicConnectionPeer::SetAckMode(&connection_, QuicConnection::ACK_DECIMATION);
-  QuicConnectionPeer::SetAckDecimationDelay(&connection_, 0.125);
-
-  const size_t kMinRttMs = 40;
-  RttStats* rtt_stats = const_cast<RttStats*>(manager_->GetRttStats());
-  rtt_stats->UpdateRtt(QuicTime::Delta::FromMilliseconds(kMinRttMs),
-                       QuicTime::Delta::Zero(), QuicTime::Zero());
-  // The ack time should be based on min_rtt/8, since it's less than the
-  // default delayed ack time.
-  QuicTime ack_time = clock_.ApproximateNow() +
-                      QuicTime::Delta::FromMilliseconds(kMinRttMs / 8);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  const uint8_t tag = 0x07;
-  connection_.SetDecrypter(ENCRYPTION_INITIAL, new StrictTaggingDecrypter(tag));
-  framer_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(tag));
-  // Process a packet from the non-crypto stream.
-  frame1_.stream_id = 3;
-
-  // Process all the initial packets in order so there aren't missing packets.
-  QuicPacketNumber kFirstDecimatedPacket = 101;
-  for (unsigned int i = 0; i < kFirstDecimatedPacket - 1; ++i) {
-    EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-    ProcessDataPacketAtLevel(kDefaultPathId, 1 + i, !kEntropyFlag,
-                             !kHasStopWaiting, ENCRYPTION_INITIAL);
-  }
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  // The same as ProcessPacket(1) except that ENCRYPTION_INITIAL is used
-  // instead of ENCRYPTION_NONE.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket, !kEntropyFlag,
-                           !kHasStopWaiting, ENCRYPTION_INITIAL);
-
-  // Check if delayed ack timer is running for the expected interval.
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_EQ(ack_time, connection_.GetAckAlarm()->deadline());
-
-  // The 10th received packet causes an ack to be sent.
-  for (int i = 0; i < 9; ++i) {
-    EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-    EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-    ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket + 1 + i,
-                             !kEntropyFlag, !kHasStopWaiting,
-                             ENCRYPTION_INITIAL);
-  }
-  // Check that ack is sent and that delayed ack alarm is reset.
-  EXPECT_EQ(2u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, SendDelayedAckDecimationWithReordering) {
-  QuicConnectionPeer::SetAckMode(
-      &connection_, QuicConnection::ACK_DECIMATION_WITH_REORDERING);
-
-  const size_t kMinRttMs = 40;
-  RttStats* rtt_stats = const_cast<RttStats*>(manager_->GetRttStats());
-  rtt_stats->UpdateRtt(QuicTime::Delta::FromMilliseconds(kMinRttMs),
-                       QuicTime::Delta::Zero(), QuicTime::Zero());
-  // The ack time should be based on min_rtt/4, since it's less than the
-  // default delayed ack time.
-  QuicTime ack_time = clock_.ApproximateNow() +
-                      QuicTime::Delta::FromMilliseconds(kMinRttMs / 4);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  const uint8_t tag = 0x07;
-  connection_.SetDecrypter(ENCRYPTION_INITIAL, new StrictTaggingDecrypter(tag));
-  framer_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(tag));
-  // Process a packet from the non-crypto stream.
-  frame1_.stream_id = 3;
-
-  // Process all the initial packets in order so there aren't missing packets.
-  QuicPacketNumber kFirstDecimatedPacket = 101;
-  for (unsigned int i = 0; i < kFirstDecimatedPacket - 1; ++i) {
-    EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-    ProcessDataPacketAtLevel(kDefaultPathId, 1 + i, !kEntropyFlag,
-                             !kHasStopWaiting, ENCRYPTION_INITIAL);
-  }
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  // The same as ProcessPacket(1) except that ENCRYPTION_INITIAL is used
-  // instead of ENCRYPTION_NONE.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket, !kEntropyFlag,
-                           !kHasStopWaiting, ENCRYPTION_INITIAL);
-
-  // Check if delayed ack timer is running for the expected interval.
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_EQ(ack_time, connection_.GetAckAlarm()->deadline());
-
-  // Process packet 10 first and ensure the alarm is one eighth min_rtt.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket + 9,
-                           !kEntropyFlag, !kHasStopWaiting, ENCRYPTION_INITIAL);
-  ack_time = clock_.ApproximateNow() + QuicTime::Delta::FromMilliseconds(5);
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_EQ(ack_time, connection_.GetAckAlarm()->deadline());
-
-  // The 10th received packet causes an ack to be sent.
-  for (int i = 0; i < 8; ++i) {
-    EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-    EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-    ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket + 1 + i,
-                             !kEntropyFlag, !kHasStopWaiting,
-                             ENCRYPTION_INITIAL);
-  }
-  // Check that ack is sent and that delayed ack alarm is reset.
-  EXPECT_EQ(2u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, SendDelayedAckDecimationWithLargeReordering) {
-  QuicConnectionPeer::SetAckMode(
-      &connection_, QuicConnection::ACK_DECIMATION_WITH_REORDERING);
-
-  const size_t kMinRttMs = 40;
-  RttStats* rtt_stats = const_cast<RttStats*>(manager_->GetRttStats());
-  rtt_stats->UpdateRtt(QuicTime::Delta::FromMilliseconds(kMinRttMs),
-                       QuicTime::Delta::Zero(), QuicTime::Zero());
-  // The ack time should be based on min_rtt/4, since it's less than the
-  // default delayed ack time.
-  QuicTime ack_time = clock_.ApproximateNow() +
-                      QuicTime::Delta::FromMilliseconds(kMinRttMs / 4);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  const uint8_t tag = 0x07;
-  connection_.SetDecrypter(ENCRYPTION_INITIAL, new StrictTaggingDecrypter(tag));
-  framer_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(tag));
-  // Process a packet from the non-crypto stream.
-  frame1_.stream_id = 3;
-
-  // Process all the initial packets in order so there aren't missing packets.
-  QuicPacketNumber kFirstDecimatedPacket = 101;
-  for (unsigned int i = 0; i < kFirstDecimatedPacket - 1; ++i) {
-    EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-    ProcessDataPacketAtLevel(kDefaultPathId, 1 + i, !kEntropyFlag,
-                             !kHasStopWaiting, ENCRYPTION_INITIAL);
-  }
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  // The same as ProcessPacket(1) except that ENCRYPTION_INITIAL is used
-  // instead of ENCRYPTION_NONE.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket, !kEntropyFlag,
-                           !kHasStopWaiting, ENCRYPTION_INITIAL);
-
-  // Check if delayed ack timer is running for the expected interval.
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_EQ(ack_time, connection_.GetAckAlarm()->deadline());
-
-  // Process packet 10 first and ensure the alarm is one eighth min_rtt.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket + 19,
-                           !kEntropyFlag, !kHasStopWaiting, ENCRYPTION_INITIAL);
-  ack_time = clock_.ApproximateNow() + QuicTime::Delta::FromMilliseconds(5);
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_EQ(ack_time, connection_.GetAckAlarm()->deadline());
-
-  // The 10th received packet causes an ack to be sent.
-  for (int i = 0; i < 8; ++i) {
-    EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-    EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-    ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket + 1 + i,
-                             !kEntropyFlag, !kHasStopWaiting,
-                             ENCRYPTION_INITIAL);
-  }
-  // Check that ack is sent and that delayed ack alarm is reset.
-  EXPECT_EQ(2u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-
-  // The next packet received in order will cause an immediate ack,
-  // because it fills a hole.
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket + 10,
-                           !kEntropyFlag, !kHasStopWaiting, ENCRYPTION_INITIAL);
-  // Check that ack is sent and that delayed ack alarm is reset.
-  EXPECT_EQ(2u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, SendDelayedAckDecimationWithReorderingEighthRtt) {
-  QuicConnectionPeer::SetAckMode(
-      &connection_, QuicConnection::ACK_DECIMATION_WITH_REORDERING);
-  QuicConnectionPeer::SetAckDecimationDelay(&connection_, 0.125);
-
-  const size_t kMinRttMs = 40;
-  RttStats* rtt_stats = const_cast<RttStats*>(manager_->GetRttStats());
-  rtt_stats->UpdateRtt(QuicTime::Delta::FromMilliseconds(kMinRttMs),
-                       QuicTime::Delta::Zero(), QuicTime::Zero());
-  // The ack time should be based on min_rtt/8, since it's less than the
-  // default delayed ack time.
-  QuicTime ack_time = clock_.ApproximateNow() +
-                      QuicTime::Delta::FromMilliseconds(kMinRttMs / 8);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  const uint8_t tag = 0x07;
-  connection_.SetDecrypter(ENCRYPTION_INITIAL, new StrictTaggingDecrypter(tag));
-  framer_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(tag));
-  // Process a packet from the non-crypto stream.
-  frame1_.stream_id = 3;
-
-  // Process all the initial packets in order so there aren't missing packets.
-  QuicPacketNumber kFirstDecimatedPacket = 101;
-  for (unsigned int i = 0; i < kFirstDecimatedPacket - 1; ++i) {
-    EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-    ProcessDataPacketAtLevel(kDefaultPathId, 1 + i, !kEntropyFlag,
-                             !kHasStopWaiting, ENCRYPTION_INITIAL);
-  }
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  // The same as ProcessPacket(1) except that ENCRYPTION_INITIAL is used
-  // instead of ENCRYPTION_NONE.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket, !kEntropyFlag,
-                           !kHasStopWaiting, ENCRYPTION_INITIAL);
-
-  // Check if delayed ack timer is running for the expected interval.
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_EQ(ack_time, connection_.GetAckAlarm()->deadline());
-
-  // Process packet 10 first and ensure the alarm is one eighth min_rtt.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket + 9,
-                           !kEntropyFlag, !kHasStopWaiting, ENCRYPTION_INITIAL);
-  ack_time = clock_.ApproximateNow() + QuicTime::Delta::FromMilliseconds(5);
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_EQ(ack_time, connection_.GetAckAlarm()->deadline());
-
-  // The 10th received packet causes an ack to be sent.
-  for (int i = 0; i < 8; ++i) {
-    EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-    EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-    ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket + 1 + i,
-                             !kEntropyFlag, !kHasStopWaiting,
-                             ENCRYPTION_INITIAL);
-  }
-  // Check that ack is sent and that delayed ack alarm is reset.
-  EXPECT_EQ(2u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest,
-       SendDelayedAckDecimationWithLargeReorderingEighthRtt) {
-  QuicConnectionPeer::SetAckMode(
-      &connection_, QuicConnection::ACK_DECIMATION_WITH_REORDERING);
-  QuicConnectionPeer::SetAckDecimationDelay(&connection_, 0.125);
-
-  const size_t kMinRttMs = 40;
-  RttStats* rtt_stats = const_cast<RttStats*>(manager_->GetRttStats());
-  rtt_stats->UpdateRtt(QuicTime::Delta::FromMilliseconds(kMinRttMs),
-                       QuicTime::Delta::Zero(), QuicTime::Zero());
-  // The ack time should be based on min_rtt/8, since it's less than the
-  // default delayed ack time.
-  QuicTime ack_time = clock_.ApproximateNow() +
-                      QuicTime::Delta::FromMilliseconds(kMinRttMs / 8);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  const uint8_t tag = 0x07;
-  connection_.SetDecrypter(ENCRYPTION_INITIAL, new StrictTaggingDecrypter(tag));
-  framer_.SetEncrypter(ENCRYPTION_INITIAL, new TaggingEncrypter(tag));
-  // Process a packet from the non-crypto stream.
-  frame1_.stream_id = 3;
-
-  // Process all the initial packets in order so there aren't missing packets.
-  QuicPacketNumber kFirstDecimatedPacket = 101;
-  for (unsigned int i = 0; i < kFirstDecimatedPacket - 1; ++i) {
-    EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-    ProcessDataPacketAtLevel(kDefaultPathId, 1 + i, !kEntropyFlag,
-                             !kHasStopWaiting, ENCRYPTION_INITIAL);
-  }
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  // The same as ProcessPacket(1) except that ENCRYPTION_INITIAL is used
-  // instead of ENCRYPTION_NONE.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket, !kEntropyFlag,
-                           !kHasStopWaiting, ENCRYPTION_INITIAL);
-
-  // Check if delayed ack timer is running for the expected interval.
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_EQ(ack_time, connection_.GetAckAlarm()->deadline());
-
-  // Process packet 10 first and ensure the alarm is one eighth min_rtt.
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket + 19,
-                           !kEntropyFlag, !kHasStopWaiting, ENCRYPTION_INITIAL);
-  ack_time = clock_.ApproximateNow() + QuicTime::Delta::FromMilliseconds(5);
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_EQ(ack_time, connection_.GetAckAlarm()->deadline());
-
-  // The 10th received packet causes an ack to be sent.
-  for (int i = 0; i < 8; ++i) {
-    EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-    EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-    ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket + 1 + i,
-                             !kEntropyFlag, !kHasStopWaiting,
-                             ENCRYPTION_INITIAL);
-  }
-  // Check that ack is sent and that delayed ack alarm is reset.
-  EXPECT_EQ(2u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-
-  // The next packet received in order will cause an immediate ack,
-  // because it fills a hole.
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  ProcessDataPacketAtLevel(kDefaultPathId, kFirstDecimatedPacket + 10,
-                           !kEntropyFlag, !kHasStopWaiting, ENCRYPTION_INITIAL);
-  // Check that ack is sent and that delayed ack alarm is reset.
-  EXPECT_EQ(2u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, SendDelayedAckOnHandshakeConfirmed) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  ProcessPacket(kDefaultPathId, 1);
-  // Check that ack is sent and that delayed ack alarm is set.
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  QuicTime ack_time = clock_.ApproximateNow() + DefaultDelayedAckTime();
-  EXPECT_EQ(ack_time, connection_.GetAckAlarm()->deadline());
-
-  // Completing the handshake as the server does nothing.
-  QuicConnectionPeer::SetPerspective(&connection_, Perspective::IS_SERVER);
-  connection_.OnHandshakeComplete();
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_EQ(ack_time, connection_.GetAckAlarm()->deadline());
-
-  // Complete the handshake as the client decreases the delayed ack time to 0ms.
-  QuicConnectionPeer::SetPerspective(&connection_, Perspective::IS_CLIENT);
-  connection_.OnHandshakeComplete();
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_EQ(clock_.ApproximateNow(), connection_.GetAckAlarm()->deadline());
-}
-
-TEST_P(QuicConnectionTest, SendDelayedAckOnSecondPacket) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  ProcessPacket(kDefaultPathId, 1);
-  ProcessPacket(kDefaultPathId, 2);
-  // Check that ack is sent and that delayed ack alarm is reset.
-  EXPECT_EQ(2u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, NoAckOnOldNacks) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  // Drop one packet, triggering a sequence of acks.
-  ProcessPacket(kDefaultPathId, 2);
-  size_t frames_per_ack = 2;
-  EXPECT_EQ(frames_per_ack, writer_->frame_count());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  writer_->Reset();
-  ProcessPacket(kDefaultPathId, 3);
-  EXPECT_EQ(frames_per_ack, writer_->frame_count());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  writer_->Reset();
-  ProcessPacket(kDefaultPathId, 4);
-  EXPECT_EQ(frames_per_ack, writer_->frame_count());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  writer_->Reset();
-  ProcessPacket(kDefaultPathId, 5);
-  EXPECT_EQ(frames_per_ack, writer_->frame_count());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  writer_->Reset();
-  // Now only set the timer on the 6th packet, instead of sending another ack.
-  ProcessPacket(kDefaultPathId, 6);
-  EXPECT_EQ(0u, writer_->frame_count());
-  EXPECT_TRUE(connection_.GetAckAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, SendDelayedAckOnOutgoingPacket) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  ProcessPacket(kDefaultPathId, 1);
-  connection_.SendStreamDataWithString(kClientDataStreamId1, "foo", 0, !kFin,
-                                       nullptr);
-  // Check that ack is bundled with outgoing data and that delayed ack
-  // alarm is reset.
-  EXPECT_EQ(3u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, SendDelayedAckOnOutgoingCryptoPacket) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  ProcessPacket(kDefaultPathId, 1);
-  connection_.SendStreamDataWithString(kCryptoStreamId, "foo", 0, !kFin,
-                                       nullptr);
-  // Check that ack is bundled with outgoing crypto data.
-  EXPECT_EQ(3u, writer_->frame_count());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, BlockAndBufferOnFirstCHLOPacketOfTwo) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  ProcessPacket(kDefaultPathId, 1);
-  BlockOnNextWrite();
-  writer_->set_is_write_blocked_data_buffered(true);
-  connection_.SendStreamDataWithString(kCryptoStreamId, "foo", 0, !kFin,
-                                       nullptr);
-  EXPECT_TRUE(writer_->IsWriteBlocked());
-  EXPECT_FALSE(connection_.HasQueuedData());
-  connection_.SendStreamDataWithString(kCryptoStreamId, "bar", 3, !kFin,
-                                       nullptr);
-  EXPECT_TRUE(writer_->IsWriteBlocked());
-  EXPECT_TRUE(connection_.HasQueuedData());
-}
-
-TEST_P(QuicConnectionTest, BundleAckForSecondCHLO) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  EXPECT_CALL(visitor_, OnCanWrite())
-      .WillOnce(IgnoreResult(InvokeWithoutArgs(
-          &connection_, &TestConnection::SendCryptoStreamData)));
-  // Process a packet from the crypto stream, which is frame1_'s default.
-  // Receiving the CHLO as packet 2 first will cause the connection to
-  // immediately send an ack, due to the packet gap.
-  ProcessPacket(kDefaultPathId, 2);
-  // Check that ack is sent and that delayed ack alarm is reset.
-  EXPECT_EQ(3u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_EQ(1u, writer_->stream_frames().size());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, BundleAckWithDataOnIncomingAck) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  connection_.SendStreamDataWithString(kClientDataStreamId1, "foo", 0, !kFin,
-                                       nullptr);
-  connection_.SendStreamDataWithString(kClientDataStreamId1, "foo", 3, !kFin,
-                                       nullptr);
-  // Ack the second packet, which will retransmit the first packet.
-  QuicAckFrame ack = InitAckFrame(2);
-  NackPacket(1, &ack);
-  SendAlgorithmInterface::CongestionVector lost_packets;
-  lost_packets.push_back(std::make_pair(1, kMaxPacketSize));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _))
-      .WillOnce(SetArgPointee<4>(lost_packets));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&ack);
-  EXPECT_EQ(1u, writer_->frame_count());
-  EXPECT_EQ(1u, writer_->stream_frames().size());
-  writer_->Reset();
-
-  // Now ack the retransmission, which will both raise the high water mark
-  // and see if there is more data to send.
-  ack = InitAckFrame(3);
-  NackPacket(1, &ack);
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&ack);
-
-  // Check that no packet is sent and the ack alarm isn't set.
-  EXPECT_EQ(0u, writer_->frame_count());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-  writer_->Reset();
-
-  // Send the same ack, but send both data and an ack together.
-  ack = InitAckFrame(3);
-  NackPacket(1, &ack);
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _));
-  EXPECT_CALL(visitor_, OnCanWrite())
-      .WillOnce(IgnoreResult(InvokeWithoutArgs(
-          &connection_, &TestConnection::EnsureWritableAndSendStreamData5)));
-  ProcessAckPacket(&ack);
-
-  // Check that ack is bundled with outgoing data and the delayed ack
-  // alarm is reset.
-  EXPECT_EQ(3u, writer_->frame_count());
-  EXPECT_FALSE(writer_->stop_waiting_frames().empty());
-  EXPECT_FALSE(writer_->ack_frames().empty());
-  EXPECT_EQ(1u, writer_->stream_frames().size());
-  EXPECT_FALSE(connection_.GetAckAlarm()->IsSet());
-}
-
-TEST_P(QuicConnectionTest, NoAckSentForClose) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  ProcessPacket(kDefaultPathId, 1);
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_PEER_GOING_AWAY, _,
-                                           ConnectionCloseSource::FROM_PEER));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(0);
-  ProcessClosePacket(kDefaultPathId, 2);
-}
-
-TEST_P(QuicConnectionTest, SendWhenDisconnected) {
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_PEER_GOING_AWAY, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  connection_.CloseConnection(QUIC_PEER_GOING_AWAY, "no reason",
-                              ConnectionCloseBehavior::SILENT_CLOSE);
-  EXPECT_FALSE(connection_.connected());
-  EXPECT_FALSE(connection_.CanWriteStreamData());
-  QuicPacket* packet =
-      ConstructDataPacket(kDefaultPathId, 1, !kEntropyFlag, !kHasStopWaiting);
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, 1, _, _)).Times(0);
-  connection_.SendPacket(ENCRYPTION_NONE, kDefaultPathId, 1, packet,
-                         kTestEntropyHash, HAS_RETRANSMITTABLE_DATA, false,
-                         false);
-}
-
-TEST_P(QuicConnectionTest, PublicReset) {
-  QuicPublicResetPacket header;
-  header.public_header.connection_id = connection_id_;
-  header.public_header.reset_flag = true;
-  header.public_header.version_flag = false;
-  header.rejected_packet_number = 10101;
-  std::unique_ptr<QuicEncryptedPacket> packet(
-      framer_.BuildPublicResetPacket(header));
-  std::unique_ptr<QuicReceivedPacket> received(
-      ConstructReceivedPacket(*packet, QuicTime::Zero()));
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_PUBLIC_RESET, _,
-                                           ConnectionCloseSource::FROM_PEER));
-  connection_.ProcessUdpPacket(kSelfAddress, kPeerAddress, *received);
-}
-
-TEST_P(QuicConnectionTest, GoAway) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  QuicGoAwayFrame goaway;
-  goaway.last_good_stream_id = 1;
-  goaway.error_code = QUIC_PEER_GOING_AWAY;
-  goaway.reason_phrase = "Going away.";
-  EXPECT_CALL(visitor_, OnGoAway(_));
-  ProcessGoAwayPacket(&goaway);
-}
-
-TEST_P(QuicConnectionTest, WindowUpdate) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  QuicWindowUpdateFrame window_update;
-  window_update.stream_id = 3;
-  window_update.byte_offset = 1234;
-  EXPECT_CALL(visitor_, OnWindowUpdateFrame(_));
-  ProcessFramePacket(QuicFrame(&window_update));
-}
-
-TEST_P(QuicConnectionTest, Blocked) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  QuicBlockedFrame blocked;
-  blocked.stream_id = 3;
-  EXPECT_CALL(visitor_, OnBlockedFrame(_));
-  ProcessFramePacket(QuicFrame(&blocked));
-}
-
-TEST_P(QuicConnectionTest, PathClose) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  QuicPathCloseFrame path_close = QuicPathCloseFrame(1);
-  ProcessPathClosePacket(&path_close);
-  EXPECT_TRUE(QuicFramerPeer::IsPathClosed(
-      QuicConnectionPeer::GetFramer(&connection_), 1));
-}
-
-TEST_P(QuicConnectionTest, ZeroBytePacket) {
-  // Don't close the connection for zero byte packets.
-  EXPECT_CALL(visitor_, OnConnectionClosed(_, _, _)).Times(0);
-  QuicReceivedPacket encrypted(nullptr, 0, QuicTime::Zero());
-  connection_.ProcessUdpPacket(kSelfAddress, kPeerAddress, encrypted);
-}
-
-TEST_P(QuicConnectionTest, MissingPacketsBeforeLeastUnacked) {
-  // Set the packet number of the ack packet to be least unacked (4).
-  QuicPacketCreatorPeer::SetPacketNumber(&peer_creator_, 3);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  QuicStopWaitingFrame frame = InitStopWaitingFrame(4);
-  ProcessStopWaitingPacket(&frame);
-  if (outgoing_ack()->missing) {
-    EXPECT_TRUE(outgoing_ack()->packets.Empty());
-  } else {
-    EXPECT_FALSE(outgoing_ack()->packets.Empty());
-  }
-}
-
-TEST_P(QuicConnectionTest, ReceivedEntropyHashCalculation) {
-  if (GetParam().version > QUIC_VERSION_33) {
-    return;
-  }
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(AtLeast(1));
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  ProcessDataPacket(kDefaultPathId, 1, kEntropyFlag);
-  ProcessDataPacket(kDefaultPathId, 4, kEntropyFlag);
-  ProcessDataPacket(kDefaultPathId, 3, !kEntropyFlag);
-  ProcessDataPacket(kDefaultPathId, 7, kEntropyFlag);
-  EXPECT_EQ(146u, outgoing_ack()->entropy_hash);
-}
-
-TEST_P(QuicConnectionTest, UpdateEntropyForReceivedPackets) {
-  if (GetParam().version > QUIC_VERSION_33) {
-    return;
-  }
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(AtLeast(1));
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  ProcessDataPacket(kDefaultPathId, 1, kEntropyFlag);
-  ProcessDataPacket(kDefaultPathId, 5, kEntropyFlag);
-  ProcessDataPacket(kDefaultPathId, 4, !kEntropyFlag);
-  EXPECT_EQ(34u, outgoing_ack()->entropy_hash);
-  // Make 4th packet my least unacked, and update entropy for 2, 3 packets.
-  QuicPacketCreatorPeer::SetPacketNumber(&peer_creator_, 5);
-  QuicPacketEntropyHash six_packet_entropy_hash = 0;
-  QuicPacketEntropyHash random_entropy_hash = 129u;
-  QuicStopWaitingFrame frame = InitStopWaitingFrame(4);
-  frame.entropy_hash = random_entropy_hash;
-  if (ProcessStopWaitingPacket(&frame)) {
-    six_packet_entropy_hash = 1 << 6;
-  }
-
-  EXPECT_EQ((random_entropy_hash + (1 << 5) + six_packet_entropy_hash),
-            outgoing_ack()->entropy_hash);
-}
-
-TEST_P(QuicConnectionTest, UpdateEntropyHashUptoCurrentPacket) {
-  if (GetParam().version > QUIC_VERSION_33) {
-    return;
-  }
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(AtLeast(1));
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  ProcessDataPacket(kDefaultPathId, 1, kEntropyFlag);
-  ProcessDataPacket(kDefaultPathId, 5, !kEntropyFlag);
-  ProcessDataPacket(kDefaultPathId, 22, kEntropyFlag);
-  EXPECT_EQ(66u, outgoing_ack()->entropy_hash);
-  QuicPacketCreatorPeer::SetPacketNumber(&peer_creator_, 22);
-  QuicPacketEntropyHash random_entropy_hash = 85u;
-  // Current packet is the least unacked packet.
-  QuicPacketEntropyHash ack_entropy_hash;
-  QuicStopWaitingFrame frame = InitStopWaitingFrame(23);
-  frame.entropy_hash = random_entropy_hash;
-  ack_entropy_hash = ProcessStopWaitingPacket(&frame);
-  EXPECT_EQ((random_entropy_hash + ack_entropy_hash),
-            outgoing_ack()->entropy_hash);
-  ProcessDataPacket(kDefaultPathId, 25, kEntropyFlag);
-  EXPECT_EQ((random_entropy_hash + ack_entropy_hash + (1 << (25 % 8))),
-            outgoing_ack()->entropy_hash);
-}
-
-TEST_P(QuicConnectionTest, EntropyCalculationForTruncatedAck) {
-  if (GetParam().version > QUIC_VERSION_33) {
-    return;
-  }
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(AtLeast(1));
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  QuicPacketEntropyHash entropy[51];
-  entropy[0] = 0;
-  for (int i = 1; i < 51; ++i) {
-    bool should_send = i % 10 != 1;
-    bool entropy_flag = (i & (i - 1)) != 0;
-    if (!should_send) {
-      entropy[i] = entropy[i - 1];
-      continue;
-    }
-    if (entropy_flag) {
-      entropy[i] = entropy[i - 1] ^ (1 << (i % 8));
-    } else {
-      entropy[i] = entropy[i - 1];
-    }
-    ProcessDataPacket(kDefaultPathId, i, entropy_flag);
-  }
-  for (int i = 1; i < 50; ++i) {
-    EXPECT_EQ(entropy[i],
-              QuicConnectionPeer::ReceivedEntropyHash(&connection_, i));
-  }
-}
-
-TEST_P(QuicConnectionTest, ServerSendsVersionNegotiationPacket) {
-  connection_.SetSupportedVersions(AllSupportedVersions());
-  set_perspective(Perspective::IS_SERVER);
-  peer_framer_.set_version_for_tests(QUIC_VERSION_UNSUPPORTED);
-
-  QuicPacketHeader header;
-  header.public_header.connection_id = connection_id_;
-  header.public_header.version_flag = true;
-  header.path_id = kDefaultPathId;
-  header.packet_number = 12;
-
-  QuicFrames frames;
-  frames.push_back(QuicFrame(&frame1_));
-  std::unique_ptr<QuicPacket> packet(ConstructPacket(header, frames));
-  char buffer[kMaxPacketSize];
-  size_t encrypted_length = framer_.EncryptPayload(
-      ENCRYPTION_NONE, kDefaultPathId, 12, *packet, buffer, kMaxPacketSize);
-
-  framer_.set_version(version());
-  connection_.ProcessUdpPacket(
-      kSelfAddress, kPeerAddress,
-      QuicReceivedPacket(buffer, encrypted_length, QuicTime::Zero(), false));
-  EXPECT_TRUE(writer_->version_negotiation_packet() != nullptr);
-
-  size_t num_versions = arraysize(kSupportedQuicVersions);
-  ASSERT_EQ(num_versions,
-            writer_->version_negotiation_packet()->versions.size());
-
-  // We expect all versions in kSupportedQuicVersions to be
-  // included in the packet.
-  for (size_t i = 0; i < num_versions; ++i) {
-    EXPECT_EQ(kSupportedQuicVersions[i],
-              writer_->version_negotiation_packet()->versions[i]);
-  }
-}
-
-TEST_P(QuicConnectionTest, ServerSendsVersionNegotiationPacketSocketBlocked) {
-  connection_.SetSupportedVersions(AllSupportedVersions());
-  set_perspective(Perspective::IS_SERVER);
-  peer_framer_.set_version_for_tests(QUIC_VERSION_UNSUPPORTED);
-
-  QuicPacketHeader header;
-  header.public_header.connection_id = connection_id_;
-  header.public_header.version_flag = true;
-  header.packet_number = 12;
-
-  QuicFrames frames;
-  frames.push_back(QuicFrame(&frame1_));
-  std::unique_ptr<QuicPacket> packet(ConstructPacket(header, frames));
-  char buffer[kMaxPacketSize];
-  size_t encrypted_length = framer_.EncryptPayload(
-      ENCRYPTION_NONE, kDefaultPathId, 12, *packet, buffer, kMaxPacketSize);
-
-  framer_.set_version(version());
-  BlockOnNextWrite();
-  connection_.ProcessUdpPacket(
-      kSelfAddress, kPeerAddress,
-      QuicReceivedPacket(buffer, encrypted_length, QuicTime::Zero(), false));
-  EXPECT_EQ(0u, writer_->last_packet_size());
-  EXPECT_TRUE(connection_.HasQueuedData());
-
-  writer_->SetWritable();
-  connection_.OnCanWrite();
-  EXPECT_TRUE(writer_->version_negotiation_packet() != nullptr);
-
-  size_t num_versions = arraysize(kSupportedQuicVersions);
-  ASSERT_EQ(num_versions,
-            writer_->version_negotiation_packet()->versions.size());
-
-  // We expect all versions in kSupportedQuicVersions to be
-  // included in the packet.
-  for (size_t i = 0; i < num_versions; ++i) {
-    EXPECT_EQ(kSupportedQuicVersions[i],
-              writer_->version_negotiation_packet()->versions[i]);
-  }
-}
-
-TEST_P(QuicConnectionTest,
-       ServerSendsVersionNegotiationPacketSocketBlockedDataBuffered) {
-  connection_.SetSupportedVersions(AllSupportedVersions());
-  set_perspective(Perspective::IS_SERVER);
-  peer_framer_.set_version_for_tests(QUIC_VERSION_UNSUPPORTED);
-
-  QuicPacketHeader header;
-  header.public_header.connection_id = connection_id_;
-  header.public_header.version_flag = true;
-  header.packet_number = 12;
-
-  QuicFrames frames;
-  frames.push_back(QuicFrame(&frame1_));
-  std::unique_ptr<QuicPacket> packet(ConstructPacket(header, frames));
-  char buffer[kMaxPacketSize];
-  size_t encryped_length = framer_.EncryptPayload(
-      ENCRYPTION_NONE, kDefaultPathId, 12, *packet, buffer, kMaxPacketSize);
-
-  framer_.set_version(version());
-  set_perspective(Perspective::IS_SERVER);
-  BlockOnNextWrite();
-  writer_->set_is_write_blocked_data_buffered(true);
-  connection_.ProcessUdpPacket(
-      kSelfAddress, kPeerAddress,
-      QuicReceivedPacket(buffer, encryped_length, QuicTime::Zero(), false));
-  EXPECT_EQ(0u, writer_->last_packet_size());
-  EXPECT_FALSE(connection_.HasQueuedData());
-}
-
-TEST_P(QuicConnectionTest, ClientHandlesVersionNegotiation) {
-  // Start out with some unsupported version.
-  QuicConnectionPeer::GetFramer(&connection_)
-      ->set_version_for_tests(QUIC_VERSION_UNSUPPORTED);
-
-  // Send a version negotiation packet.
-  std::unique_ptr<QuicEncryptedPacket> encrypted(
-      framer_.BuildVersionNegotiationPacket(connection_id_,
-                                            AllSupportedVersions()));
-  std::unique_ptr<QuicReceivedPacket> received(
-      ConstructReceivedPacket(*encrypted, QuicTime::Zero()));
-  connection_.ProcessUdpPacket(kSelfAddress, kPeerAddress, *received);
-
-  // Now force another packet.  The connection should transition into
-  // NEGOTIATED_VERSION state and tell the packet creator to StopSendingVersion.
-  QuicPacketHeader header;
-  header.public_header.connection_id = connection_id_;
-  header.path_id = kDefaultPathId;
-  header.packet_number = 12;
-  header.public_header.version_flag = false;
-  QuicFrames frames;
-  frames.push_back(QuicFrame(&frame1_));
-  std::unique_ptr<QuicPacket> packet(ConstructPacket(header, frames));
-  char buffer[kMaxPacketSize];
-  size_t encrypted_length = framer_.EncryptPayload(
-      ENCRYPTION_NONE, kDefaultPathId, 12, *packet, buffer, kMaxPacketSize);
-  ASSERT_NE(0u, encrypted_length);
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  connection_.ProcessUdpPacket(
-      kSelfAddress, kPeerAddress,
-      QuicReceivedPacket(buffer, encrypted_length, QuicTime::Zero(), false));
-
-  ASSERT_FALSE(QuicPacketCreatorPeer::SendVersionInPacket(creator_));
-}
-
-TEST_P(QuicConnectionTest, BadVersionNegotiation) {
-  // Send a version negotiation packet with the version the client started with.
-  // It should be rejected.
-  EXPECT_CALL(visitor_,
-              OnConnectionClosed(QUIC_INVALID_VERSION_NEGOTIATION_PACKET, _,
-                                 ConnectionCloseSource::FROM_SELF));
-  std::unique_ptr<QuicEncryptedPacket> encrypted(
-      framer_.BuildVersionNegotiationPacket(connection_id_,
-                                            AllSupportedVersions()));
-  std::unique_ptr<QuicReceivedPacket> received(
-      ConstructReceivedPacket(*encrypted, QuicTime::Zero()));
-  connection_.ProcessUdpPacket(kSelfAddress, kPeerAddress, *received);
-}
-
-TEST_P(QuicConnectionTest, CheckSendStats) {
-  connection_.SetMaxTailLossProbes(kDefaultPathId, 0);
-
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  connection_.SendStreamDataWithString(3, "first", 0, !kFin, nullptr);
-  size_t first_packet_size = writer_->last_packet_size();
-
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  connection_.SendStreamDataWithString(5, "second", 0, !kFin, nullptr);
-  size_t second_packet_size = writer_->last_packet_size();
-
-  // 2 retransmissions due to rto, 1 due to explicit nack.
-  EXPECT_CALL(*send_algorithm_, OnRetransmissionTimeout(true));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(3);
-
-  // Retransmit due to RTO.
-  clock_.AdvanceTime(QuicTime::Delta::FromSeconds(10));
-  connection_.GetRetransmissionAlarm()->Fire();
-
-  // Retransmit due to explicit nacks.
-  QuicAckFrame nack_three = InitAckFrame(4);
-  NackPacket(3, &nack_three);
-  NackPacket(1, &nack_three);
-  SendAlgorithmInterface::CongestionVector lost_packets;
-  lost_packets.push_back(std::make_pair(1, kMaxPacketSize));
-  lost_packets.push_back(std::make_pair(3, kMaxPacketSize));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _))
-      .WillOnce(SetArgPointee<4>(lost_packets));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  EXPECT_CALL(visitor_, OnCanWrite());
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  ProcessAckPacket(&nack_three);
-
-  EXPECT_CALL(*send_algorithm_, BandwidthEstimate())
-      .WillOnce(Return(QuicBandwidth::Zero()));
-
-  const QuicConnectionStats& stats = connection_.GetStats();
-  EXPECT_EQ(3 * first_packet_size + 2 * second_packet_size - kQuicVersionSize,
-            stats.bytes_sent);
-  EXPECT_EQ(5u, stats.packets_sent);
-  EXPECT_EQ(2 * first_packet_size + second_packet_size - kQuicVersionSize,
-            stats.bytes_retransmitted);
-  EXPECT_EQ(3u, stats.packets_retransmitted);
-  EXPECT_EQ(1u, stats.rto_count);
-  EXPECT_EQ(kDefaultMaxPacketSize, stats.max_packet_size);
-}
-
-TEST_P(QuicConnectionTest, ProcessFramesIfPacketClosedConnection) {
-  // Construct a packet with stream frame and connection close frame.
-  QuicPacketHeader header;
-  header.public_header.connection_id = connection_id_;
-  header.packet_number = 1;
-  header.public_header.version_flag = false;
-
-  QuicConnectionCloseFrame qccf;
-  qccf.error_code = QUIC_PEER_GOING_AWAY;
-
-  QuicFrames frames;
-  frames.push_back(QuicFrame(&frame1_));
-  frames.push_back(QuicFrame(&qccf));
-  std::unique_ptr<QuicPacket> packet(ConstructPacket(header, frames));
-  EXPECT_TRUE(nullptr != packet.get());
-  char buffer[kMaxPacketSize];
-  size_t encrypted_length = framer_.EncryptPayload(
-      ENCRYPTION_NONE, kDefaultPathId, 1, *packet, buffer, kMaxPacketSize);
-
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_PEER_GOING_AWAY, _,
-                                           ConnectionCloseSource::FROM_PEER));
-  EXPECT_CALL(visitor_, OnStreamFrame(_)).Times(1);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  connection_.ProcessUdpPacket(
-      kSelfAddress, kPeerAddress,
-      QuicReceivedPacket(buffer, encrypted_length, QuicTime::Zero(), false));
-}
-
-TEST_P(QuicConnectionTest, SelectMutualVersion) {
-  connection_.SetSupportedVersions(AllSupportedVersions());
-  // Set the connection to speak the lowest quic version.
-  connection_.set_version(QuicVersionMin());
-  EXPECT_EQ(QuicVersionMin(), connection_.version());
-
-  // Pass in available versions which includes a higher mutually supported
-  // version.  The higher mutually supported version should be selected.
-  QuicVersionVector supported_versions;
-  for (size_t i = 0; i < arraysize(kSupportedQuicVersions); ++i) {
-    supported_versions.push_back(kSupportedQuicVersions[i]);
-  }
-  EXPECT_TRUE(connection_.SelectMutualVersion(supported_versions));
-  EXPECT_EQ(QuicVersionMax(), connection_.version());
-
-  // Expect that the lowest version is selected.
-  // Ensure the lowest supported version is less than the max, unless they're
-  // the same.
-  EXPECT_LE(QuicVersionMin(), QuicVersionMax());
-  QuicVersionVector lowest_version_vector;
-  lowest_version_vector.push_back(QuicVersionMin());
-  EXPECT_TRUE(connection_.SelectMutualVersion(lowest_version_vector));
-  EXPECT_EQ(QuicVersionMin(), connection_.version());
-
-  // Shouldn't be able to find a mutually supported version.
-  QuicVersionVector unsupported_version;
-  unsupported_version.push_back(QUIC_VERSION_UNSUPPORTED);
-  EXPECT_FALSE(connection_.SelectMutualVersion(unsupported_version));
-}
-
-TEST_P(QuicConnectionTest, ConnectionCloseWhenWritable) {
-  EXPECT_FALSE(writer_->IsWriteBlocked());
-
-  // Send a packet.
-  connection_.SendStreamDataWithString(1, "foo", 0, !kFin, nullptr);
-  EXPECT_EQ(0u, connection_.NumQueuedPackets());
-  EXPECT_EQ(1u, writer_->packets_write_attempts());
-
-  TriggerConnectionClose();
-  EXPECT_EQ(2u, writer_->packets_write_attempts());
-}
-
-TEST_P(QuicConnectionTest, ConnectionCloseGettingWriteBlocked) {
-  BlockOnNextWrite();
-  TriggerConnectionClose();
-  EXPECT_EQ(1u, writer_->packets_write_attempts());
-  EXPECT_TRUE(writer_->IsWriteBlocked());
-}
-
-TEST_P(QuicConnectionTest, ConnectionCloseWhenWriteBlocked) {
-  BlockOnNextWrite();
-  connection_.SendStreamDataWithString(1, "foo", 0, !kFin, nullptr);
-  EXPECT_EQ(1u, connection_.NumQueuedPackets());
-  EXPECT_EQ(1u, writer_->packets_write_attempts());
-  EXPECT_TRUE(writer_->IsWriteBlocked());
-  TriggerConnectionClose();
-  EXPECT_EQ(1u, writer_->packets_write_attempts());
-}
-
-TEST_P(QuicConnectionTest, AckNotifierTriggerCallback) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  // Create a listener which we expect to be called.
-  scoped_refptr<MockAckListener> listener(new MockAckListener);
-  EXPECT_CALL(*listener, OnPacketAcked(_, _)).Times(1);
-
-  // Send some data, which will register the listener to be notified.
-  connection_.SendStreamDataWithString(1, "foo", 0, !kFin, listener.get());
-
-  // Process an ACK from the server which should trigger the callback.
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  QuicAckFrame frame = InitAckFrame(1);
-  ProcessAckPacket(&frame);
-}
-
-TEST_P(QuicConnectionTest, AckNotifierFailToTriggerCallback) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  // Create a listener which we don't expect to be called.
-  scoped_refptr<MockAckListener> listener(new MockAckListener);
-  EXPECT_CALL(*listener, OnPacketAcked(_, _)).Times(0);
-
-  // Send some data, which will register the listener to be notified. This will
-  // not be ACKed and so the listener should never be called.
-  connection_.SendStreamDataWithString(1, "foo", 0, !kFin, listener.get());
-
-  // Send some other data which we will ACK.
-  connection_.SendStreamDataWithString(1, "foo", 0, !kFin, nullptr);
-  connection_.SendStreamDataWithString(1, "bar", 0, !kFin, nullptr);
-
-  // Now we receive ACK for packets 2 and 3, but importantly missing packet 1
-  // which we registered to be notified about.
-  QuicAckFrame frame = InitAckFrame(3);
-  NackPacket(1, &frame);
-  SendAlgorithmInterface::CongestionVector lost_packets;
-  lost_packets.push_back(std::make_pair(1, kMaxPacketSize));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _))
-      .WillOnce(SetArgPointee<4>(lost_packets));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  ProcessAckPacket(&frame);
-}
-
-TEST_P(QuicConnectionTest, AckNotifierCallbackAfterRetransmission) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  // Create a listener which we expect to be called.
-  scoped_refptr<MockAckListener> listener(new MockAckListener);
-  EXPECT_CALL(*listener, OnPacketRetransmitted(3)).Times(1);
-  EXPECT_CALL(*listener, OnPacketAcked(3, _)).Times(1);
-
-  // Send four packets, and register to be notified on ACK of packet 2.
-  connection_.SendStreamDataWithString(3, "foo", 0, !kFin, nullptr);
-  connection_.SendStreamDataWithString(3, "bar", 0, !kFin, listener.get());
-  connection_.SendStreamDataWithString(3, "baz", 0, !kFin, nullptr);
-  connection_.SendStreamDataWithString(3, "qux", 0, !kFin, nullptr);
-
-  // Now we receive ACK for packets 1, 3, and 4 and lose 2.
-  QuicAckFrame frame = InitAckFrame(4);
-  NackPacket(2, &frame);
-  SendAlgorithmInterface::CongestionVector lost_packets;
-  lost_packets.push_back(std::make_pair(2, kMaxPacketSize));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _))
-      .WillOnce(SetArgPointee<4>(lost_packets));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  ProcessAckPacket(&frame);
-
-  // Now we get an ACK for packet 5 (retransmitted packet 2), which should
-  // trigger the callback.
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  QuicAckFrame second_ack_frame = InitAckFrame(5);
-  ProcessAckPacket(&second_ack_frame);
-}
-
-// AckNotifierCallback is triggered by the ack of a packet that timed
-// out and was retransmitted, even though the retransmission has a
-// different packet number.
-TEST_P(QuicConnectionTest, AckNotifierCallbackForAckAfterRTO) {
-  connection_.SetMaxTailLossProbes(kDefaultPathId, 0);
-
-  // Create a listener which we expect to be called.
-  scoped_refptr<MockAckListener> listener(new StrictMock<MockAckListener>);
-
-  QuicTime default_retransmission_time =
-      clock_.ApproximateNow() + DefaultRetransmissionTime();
-  connection_.SendStreamDataWithString(3, "foo", 0, !kFin, listener.get());
-  EXPECT_EQ(1u, stop_waiting()->least_unacked);
-
-  EXPECT_EQ(1u, writer_->header().packet_number);
-  EXPECT_EQ(default_retransmission_time,
-            connection_.GetRetransmissionAlarm()->deadline());
-  // Simulate the retransmission alarm firing.
-  clock_.AdvanceTime(DefaultRetransmissionTime());
-  EXPECT_CALL(*listener, OnPacketRetransmitted(3));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, 2u, _, _));
-  connection_.GetRetransmissionAlarm()->Fire();
-  EXPECT_EQ(2u, writer_->header().packet_number);
-  // We do not raise the high water mark yet.
-  EXPECT_EQ(1u, stop_waiting()->least_unacked);
-
-  // Ack the original packet, which will revert the RTO.
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  EXPECT_CALL(*listener, OnPacketAcked(3, _));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  QuicAckFrame ack_frame = InitAckFrame(1);
-  ProcessAckPacket(&ack_frame);
-
-  // listener is not notified again when the retransmit is acked.
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  QuicAckFrame second_ack_frame = InitAckFrame(2);
-  ProcessAckPacket(&second_ack_frame);
-}
-
-// AckNotifierCallback is triggered by the ack of a packet that was
-// previously nacked, even though the retransmission has a different
-// packet number.
-TEST_P(QuicConnectionTest, AckNotifierCallbackForAckOfNackedPacket) {
-  // Create a listener which we expect to be called.
-  scoped_refptr<MockAckListener> listener(new StrictMock<MockAckListener>);
-
-  // Send four packets, and register to be notified on ACK of packet 2.
-  connection_.SendStreamDataWithString(3, "foo", 0, !kFin, nullptr);
-  connection_.SendStreamDataWithString(3, "bar", 0, !kFin, listener.get());
-  connection_.SendStreamDataWithString(3, "baz", 0, !kFin, nullptr);
-  connection_.SendStreamDataWithString(3, "qux", 0, !kFin, nullptr);
-
-  // Now we receive ACK for packets 1, 3, and 4 and lose 2.
-  QuicAckFrame frame = InitAckFrame(4);
-  NackPacket(2, &frame);
-  EXPECT_CALL(*listener, OnPacketRetransmitted(_));
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  SendAlgorithmInterface::CongestionVector lost_packets;
-  lost_packets.push_back(std::make_pair(2, kMaxPacketSize));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _))
-      .WillOnce(SetArgPointee<4>(lost_packets));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _));
-  ProcessAckPacket(&frame);
-
-  // Now we get an ACK for packet 2, which was previously nacked.
-  EXPECT_CALL(*listener, OnPacketAcked(3, _));
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _));
-  QuicAckFrame second_ack_frame = InitAckFrame(4);
-  ProcessAckPacket(&second_ack_frame);
-
-  // Verify that the listener is not notified again when the
-  // retransmit is acked.
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  QuicAckFrame third_ack_frame = InitAckFrame(5);
-  ProcessAckPacket(&third_ack_frame);
-}
-
-TEST_P(QuicConnectionTest, OnPacketHeaderDebugVisitor) {
-  QuicPacketHeader header;
-
-  MockQuicConnectionDebugVisitor debug_visitor;
-  connection_.set_debug_visitor(&debug_visitor);
-  EXPECT_CALL(debug_visitor, OnPacketHeader(Ref(header))).Times(1);
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_)).Times(1);
-  EXPECT_CALL(debug_visitor, OnSuccessfulVersionNegotiation(_)).Times(1);
-  connection_.OnPacketHeader(header);
-}
-
-TEST_P(QuicConnectionTest, Pacing) {
-  // static_cast here does not work if using multipath_sent_packet_manager.
-  FLAGS_quic_enable_multipath = false;
-  TestConnection server(connection_id_, kSelfAddress, helper_.get(),
-                        alarm_factory_.get(), writer_.get(),
-                        Perspective::IS_SERVER, version());
-  TestConnection client(connection_id_, kPeerAddress, helper_.get(),
-                        alarm_factory_.get(), writer_.get(),
-                        Perspective::IS_CLIENT, version());
-  EXPECT_FALSE(QuicSentPacketManagerPeer::UsingPacing(
-      static_cast<const QuicSentPacketManager*>(
-          &client.sent_packet_manager())));
-  EXPECT_FALSE(QuicSentPacketManagerPeer::UsingPacing(
-      static_cast<const QuicSentPacketManager*>(
-          &server.sent_packet_manager())));
-}
-
-TEST_P(QuicConnectionTest, WindowUpdateInstigateAcks) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  // Send a WINDOW_UPDATE frame.
-  QuicWindowUpdateFrame window_update;
-  window_update.stream_id = 3;
-  window_update.byte_offset = 1234;
-  EXPECT_CALL(visitor_, OnWindowUpdateFrame(_));
-  ProcessFramePacket(QuicFrame(&window_update));
-
-  // Ensure that this has caused the ACK alarm to be set.
-  QuicAlarm* ack_alarm = QuicConnectionPeer::GetAckAlarm(&connection_);
-  EXPECT_TRUE(ack_alarm->IsSet());
-}
-
-TEST_P(QuicConnectionTest, BlockedFrameInstigateAcks) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  // Send a BLOCKED frame.
-  QuicBlockedFrame blocked;
-  blocked.stream_id = 3;
-  EXPECT_CALL(visitor_, OnBlockedFrame(_));
-  ProcessFramePacket(QuicFrame(&blocked));
-
-  // Ensure that this has caused the ACK alarm to be set.
-  QuicAlarm* ack_alarm = QuicConnectionPeer::GetAckAlarm(&connection_);
-  EXPECT_TRUE(ack_alarm->IsSet());
-}
-
-TEST_P(QuicConnectionTest, NoDataNoFin) {
-  // Make sure that a call to SendStreamWithData, with no data and no FIN, does
-  // not result in a QuicAckNotifier being used-after-free (fail under ASAN).
-  // Regression test for b/18594622
-  scoped_refptr<MockAckListener> listener(new MockAckListener);
-  EXPECT_QUIC_BUG(
-      connection_.SendStreamDataWithString(3, "", 0, !kFin, listener.get()),
-      "Attempt to send empty stream frame");
-}
-
-TEST_P(QuicConnectionTest, DoNotSendGoAwayTwice) {
-  EXPECT_FALSE(connection_.goaway_sent());
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-  connection_.SendGoAway(QUIC_PEER_GOING_AWAY, kHeadersStreamId, "Going Away.");
-  EXPECT_TRUE(connection_.goaway_sent());
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(0);
-  connection_.SendGoAway(QUIC_PEER_GOING_AWAY, kHeadersStreamId, "Going Away.");
-}
-
-TEST_P(QuicConnectionTest, ReevaluateTimeUntilSendOnAck) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  connection_.SendStreamDataWithString(kClientDataStreamId1, "foo", 0, !kFin,
-                                       nullptr);
-
-  // Evaluate CanWrite, and have it return a non-Zero value.
-  EXPECT_CALL(*send_algorithm_, TimeUntilSend(_, _))
-      .WillRepeatedly(Return(QuicTime::Delta::FromMilliseconds(1)));
-  connection_.OnCanWrite();
-  EXPECT_TRUE(connection_.GetSendAlarm()->IsSet());
-  EXPECT_EQ(clock_.Now() + QuicTime::Delta::FromMilliseconds(1),
-            connection_.GetSendAlarm()->deadline());
-
-  // Process an ack and the send alarm will be set to the  new 2ms delay.
-  QuicAckFrame ack = InitAckFrame(1);
-  EXPECT_CALL(*loss_algorithm_, DetectLosses(_, _, _, _, _));
-  EXPECT_CALL(*send_algorithm_, OnCongestionEvent(true, _, _, _));
-  EXPECT_CALL(*send_algorithm_, TimeUntilSend(_, _))
-      .WillRepeatedly(Return(QuicTime::Delta::FromMilliseconds(2)));
-  ProcessAckPacket(&ack);
-  EXPECT_EQ(1u, writer_->frame_count());
-  EXPECT_EQ(1u, writer_->stream_frames().size());
-  EXPECT_TRUE(connection_.GetSendAlarm()->IsSet());
-  EXPECT_EQ(clock_.Now() + QuicTime::Delta::FromMilliseconds(2),
-            connection_.GetSendAlarm()->deadline());
-  writer_->Reset();
-}
-
-TEST_P(QuicConnectionTest, SendAcksImmediately) {
-  CongestionBlockWrites();
-  SendAckPacketToPeer();
-}
-
-TEST_P(QuicConnectionTest, SendPingImmediately) {
-  MockQuicConnectionDebugVisitor debug_visitor;
-  connection_.set_debug_visitor(&debug_visitor);
-
-  CongestionBlockWrites();
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(1);
-  EXPECT_CALL(debug_visitor, OnPacketSent(_, _, _, _, _)).Times(1);
-  EXPECT_CALL(debug_visitor, OnPingSent()).Times(1);
-  connection_.SendPing();
-  EXPECT_FALSE(connection_.HasQueuedData());
-}
-
-TEST_P(QuicConnectionTest, SendingUnencryptedStreamDataFails) {
-  FLAGS_quic_never_write_unencrypted_data = true;
-  EXPECT_CALL(visitor_,
-              OnConnectionClosed(QUIC_ATTEMPT_TO_SEND_UNENCRYPTED_STREAM_DATA,
-                                 _, ConnectionCloseSource::FROM_SELF));
-  EXPECT_QUIC_BUG(connection_.SendStreamDataWithString(3, "", 0, kFin, nullptr),
-                  "Cannot send stream data without encryption.");
-  EXPECT_FALSE(connection_.connected());
-}
-
-TEST_P(QuicConnectionTest, EnableMultipathNegotiation) {
-  // Test multipath negotiation during crypto handshake. Multipath is enabled
-  // when both endpoints enable multipath.
-  FLAGS_quic_enable_multipath = true;
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_FALSE(QuicConnectionPeer::IsMultipathEnabled(&connection_));
-  EXPECT_CALL(*send_algorithm_, SetFromConfig(_, _));
-  QuicConfig config;
-  // Enable multipath on server side.
-  config.SetMultipathEnabled(true);
-
-  // Create a handshake message enables multipath.
-  CryptoHandshakeMessage msg;
-  string error_details;
-  QuicConfig client_config;
-  // Enable multipath on client side.
-  client_config.SetMultipathEnabled(true);
-  client_config.ToHandshakeMessage(&msg);
-  const QuicErrorCode error =
-      config.ProcessPeerHello(msg, CLIENT, &error_details);
-  EXPECT_EQ(QUIC_NO_ERROR, error);
-
-  connection_.SetFromConfig(config);
-  EXPECT_TRUE(QuicConnectionPeer::IsMultipathEnabled(&connection_));
-}
-
-TEST_P(QuicConnectionTest, ClosePath) {
-  QuicPathId kTestPathId = 1;
-  connection_.SendPathClose(kTestPathId);
-  EXPECT_TRUE(QuicFramerPeer::IsPathClosed(
-      QuicConnectionPeer::GetFramer(&connection_), kTestPathId));
-}
-
-TEST_P(QuicConnectionTest, BadMultipathFlag) {
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_BAD_MULTIPATH_FLAG, _,
-                                           ConnectionCloseSource::FROM_SELF));
-
-  // Receieve a packet with multipath flag on when multipath is not enabled.
-  EXPECT_TRUE(connection_.connected());
-  EXPECT_FALSE(QuicConnectionPeer::IsMultipathEnabled(&connection_));
-  peer_creator_.SetCurrentPath(/*path_id=*/1u, 1u, 10u);
-  QuicStreamFrame stream_frame(1u, false, 0u, StringPiece());
-  EXPECT_QUIC_BUG(
-      ProcessFramePacket(QuicFrame(&stream_frame)),
-      "Received a packet with multipath flag but multipath is not enabled.");
-  EXPECT_FALSE(connection_.connected());
-}
-
-TEST_P(QuicConnectionTest, OnPathDegrading) {
-  QuicByteCount packet_size;
-  const size_t kMinTimeoutsBeforePathDegrading = 2;
-
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-      .WillOnce(DoAll(SaveArg<3>(&packet_size), Return(true)));
-  connection_.SendStreamDataWithString(3, "packet", 0, !kFin, nullptr);
-  size_t num_timeouts = kMinTimeoutsBeforePathDegrading +
-                        QuicSentPacketManagerPeer::GetMaxTailLossProbes(
-                            QuicConnectionPeer::GetSentPacketManager(
-                                &connection_, kDefaultPathId));
-  for (size_t i = 1; i < num_timeouts; ++i) {
-    clock_.AdvanceTime(QuicTime::Delta::FromSeconds(10 * i));
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, packet_size, _));
-    connection_.GetRetransmissionAlarm()->Fire();
-  }
-  // Next RTO should cause OnPathDegrading to be called before the
-  // retransmission is sent out.
-  clock_.AdvanceTime(
-      QuicTime::Delta::FromSeconds(kMinTimeoutsBeforePathDegrading * 10));
-  {
-    InSequence s;
-    EXPECT_CALL(visitor_, OnPathDegrading());
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, packet_size, _));
-  }
-  connection_.GetRetransmissionAlarm()->Fire();
-}
-
-TEST_P(QuicConnectionTest, MultipleCallsToCloseConnection) {
-  // Verifies that multiple calls to CloseConnection do not
-  // result in multiple attempts to close the connection - it will be marked as
-  // disconnected after the first call.
-  EXPECT_CALL(visitor_, OnConnectionClosed(_, _, _)).Times(1);
-  connection_.CloseConnection(QUIC_NO_ERROR, "no reason",
-                              ConnectionCloseBehavior::SILENT_CLOSE);
-  connection_.CloseConnection(QUIC_NO_ERROR, "no reason",
-                              ConnectionCloseBehavior::SILENT_CLOSE);
-}
-
-TEST_P(QuicConnectionTest, ServerReceivesChloOnNonCryptoStream) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  set_perspective(Perspective::IS_SERVER);
-  QuicPacketCreatorPeer::SetSendVersionInPacket(creator_, false);
-
-  CryptoHandshakeMessage message;
-  CryptoFramer framer;
-  message.set_tag(kCHLO);
-  std::unique_ptr<QuicData> data(framer.ConstructHandshakeMessage(message));
-  frame1_.stream_id = 10;
-  frame1_.data_buffer = data->data();
-  frame1_.data_length = data->length();
-
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_MAYBE_CORRUPTED_MEMORY, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  ProcessFramePacket(QuicFrame(&frame1_));
-}
-
-TEST_P(QuicConnectionTest, ClientReceivesRejOnNonCryptoStream) {
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-
-  CryptoHandshakeMessage message;
-  CryptoFramer framer;
-  message.set_tag(kREJ);
-  std::unique_ptr<QuicData> data(framer.ConstructHandshakeMessage(message));
-  frame1_.stream_id = 10;
-  frame1_.data_buffer = data->data();
-  frame1_.data_length = data->length();
-
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_MAYBE_CORRUPTED_MEMORY, _,
-                                           ConnectionCloseSource::FROM_SELF));
-  ProcessFramePacket(QuicFrame(&frame1_));
-}
-
-TEST_P(QuicConnectionTest, CloseConnectionOnPacketTooLarge) {
-  FLAGS_quic_close_connection_on_packet_too_large = true;
-  SimulateNextPacketTooLarge();
-  // Although the data packet cannot be written, the send packet manager is
-  // informed. Also a connection close packet is sent.
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(2);
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_PACKET_WRITE_ERROR, _,
-                                           ConnectionCloseSource::FROM_SELF))
-      .Times(1);
-  connection_.SendStreamDataWithString(3, "foo", 0, !kFin, nullptr);
-}
-
-TEST_P(QuicConnectionTest, AlwaysGetPacketTooLarge) {
-  // Test even we always get packet too large, we do not infinitely try to send
-  // close packet.
-  FLAGS_quic_close_connection_on_packet_too_large = true;
-  AlwaysGetPacketTooLarge();
-  EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _)).Times(2);
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_PACKET_WRITE_ERROR, _,
-                                           ConnectionCloseSource::FROM_SELF))
-      .Times(1);
-  connection_.SendStreamDataWithString(3, "foo", 0, !kFin, nullptr);
-}
-
-// Verify that if connection has no outstanding data, it notifies the send
-// algorithm after the write.
-TEST_P(QuicConnectionTest, SendDataAndBecomeApplicationLimited) {
-  FLAGS_quic_enable_app_limited_check = true;
-
-  EXPECT_CALL(*send_algorithm_, OnApplicationLimited(_)).Times(1);
-  {
-    InSequence seq;
-    EXPECT_CALL(visitor_, WillingAndAbleToWrite()).WillRepeatedly(Return(true));
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-        .WillOnce(Return(true));
-    EXPECT_CALL(visitor_, WillingAndAbleToWrite())
-        .WillRepeatedly(Return(false));
-  }
-
-  connection_.SendStreamData3();
-}
-
-// Verify that the connection does not become app-limited if there is
-// outstanding data to send after the write.
-TEST_P(QuicConnectionTest, NotBecomeApplicationLimitedIfMoreDataAvailable) {
-  FLAGS_quic_enable_app_limited_check = true;
-
-  EXPECT_CALL(*send_algorithm_, OnApplicationLimited(_)).Times(0);
-  {
-    InSequence seq;
-    EXPECT_CALL(*send_algorithm_, OnPacketSent(_, _, _, _, _))
-        .WillOnce(Return(true));
-    EXPECT_CALL(visitor_, WillingAndAbleToWrite()).WillRepeatedly(Return(true));
-  }
-
-  connection_.SendStreamData3();
-}
-
-// Verify that the connection does not become app-limited after blocked write
-// even if there is outstanding data to send after the write.
-TEST_P(QuicConnectionTest, NotBecomeApplicationLimitedDueToWriteBlock) {
-  FLAGS_quic_enable_app_limited_check = true;
-
-  EXPECT_CALL(*send_algorithm_, OnApplicationLimited(_)).Times(0);
-  EXPECT_CALL(visitor_, WillingAndAbleToWrite()).WillRepeatedly(Return(true));
-  BlockOnNextWrite();
-
-  connection_.SendStreamData3();
-}
-
-TEST_P(QuicConnectionTest, ForceSendingAckOnPacketTooLarge) {
-  FLAGS_quic_do_not_send_ack_on_emsgsize = false;
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  // Send an ack by simulating delayed ack alarm firing.
-  ProcessPacket(kDefaultPathId, 1);
-  QuicAlarm* ack_alarm = QuicConnectionPeer::GetAckAlarm(&connection_);
-  EXPECT_TRUE(ack_alarm->IsSet());
-  connection_.GetAckAlarm()->Fire();
-  // Simulate data packet causes write error.
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_PACKET_WRITE_ERROR, _, _));
-  SimulateNextPacketTooLarge();
-  connection_.SendStreamDataWithString(3, "foo", 0, !kFin, nullptr);
-  EXPECT_EQ(3u, writer_->frame_count());
-  EXPECT_FALSE(writer_->connection_close_frames().empty());
-  // Ack frame is bundled.
-  EXPECT_FALSE(writer_->ack_frames().empty());
-}
-
-TEST_P(QuicConnectionTest, DonotForceSendingAckOnPacketTooLarge) {
-  FLAGS_quic_do_not_send_ack_on_emsgsize = true;
-  EXPECT_CALL(visitor_, OnSuccessfulVersionNegotiation(_));
-  // Send an ack by simulating delayed ack alarm firing.
-  ProcessPacket(kDefaultPathId, 1);
-  QuicAlarm* ack_alarm = QuicConnectionPeer::GetAckAlarm(&connection_);
-  EXPECT_TRUE(ack_alarm->IsSet());
-  connection_.GetAckAlarm()->Fire();
-  // Simulate data packet causes write error.
-  EXPECT_CALL(visitor_, OnConnectionClosed(QUIC_PACKET_WRITE_ERROR, _, _));
-  SimulateNextPacketTooLarge();
-  connection_.SendStreamDataWithString(3, "foo", 0, !kFin, nullptr);
-  EXPECT_EQ(1u, writer_->frame_count());
-  EXPECT_FALSE(writer_->connection_close_frames().empty());
-  // Ack frame is not bundled in connection close packet.
-  EXPECT_TRUE(writer_->ack_frames().empty());
-}
-
-}  // namespace
-}  // namespace test
-}  // namespace net
diff --git a/src/net/quic/core/quic_crypto_stream.cc b/src/net/quic/core/quic_crypto_stream.cc
index 9c4488f..f3af4e9 100644
--- a/src/net/quic/core/quic_crypto_stream.cc
+++ b/src/net/quic/core/quic_crypto_stream.cc
@@ -54,7 +54,7 @@ void QuicCryptoStream::OnError(CryptoFramer* framer) {
 
 void QuicCryptoStream::OnHandshakeMessage(
     const CryptoHandshakeMessage& message) {
-  DVLOG(1) << ENDPOINT << "Received " << message.DebugString();
+  VLOG(0) << ENDPOINT << "Received " << message.DebugString();
   session()->OnCryptoHandshakeMessageReceived(message);
 }
 
diff --git a/src/net/quic/core/quic_flags.cc.orig b/src/net/quic/core/quic_flags.cc.orig
deleted file mode 100644
index 49b8c7a..0000000
--- a/src/net/quic/core/quic_flags.cc.orig
+++ /dev/null
@@ -1,167 +0,0 @@
-// Copyright 2014 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "net/quic/core/quic_flags.h"
-
-// If true, it will return as soon as an error is detected while validating
-// CHLO.
-bool FLAGS_use_early_return_when_verifying_chlo = true;
-
-// If true, QUIC BBR congestion control may be enabled via Finch and/or via QUIC
-// connection options.
-bool FLAGS_quic_allow_bbr = false;
-
-// Time period for which a given connection_id should live in the time-wait
-// state.
-int64_t FLAGS_quic_time_wait_list_seconds = 200;
-
-// Currently, this number is quite conservative.  The max QPS limit for an
-// individual server silo is currently set to 1000 qps, though the actual max
-// that we see in the wild is closer to 450 qps.  Regardless, this means that
-// the longest time-wait list we should see is 200 seconds * 1000 qps = 200000.
-// Of course, there are usually many queries per QUIC connection, so we allow a
-// factor of 3 leeway.
-//
-// Maximum number of connections on the time-wait list. A negative value implies
-// no configured limit.
-int64_t FLAGS_quic_time_wait_list_max_connections = 600000;
-
-// Enables server-side support for QUIC stateless rejects.
-bool FLAGS_enable_quic_stateless_reject_support = true;
-
-// This flag is not in use, just to keep consistency for shared code.
-bool FLAGS_quic_always_log_bugs_for_tests = true;
-
-// If true, multipath is enabled for the connection.
-bool FLAGS_quic_enable_multipath = false;
-
-// If true, require handshake confirmation for QUIC connections, functionally
-// disabling 0-rtt handshakes.
-// TODO(rtenneti): Enable this flag after CryptoServerTest's are fixed.
-bool FLAGS_quic_require_handshake_confirmation = false;
-
-// If true, Cubic's epoch is shifted when the sender is application-limited.
-bool FLAGS_shift_quic_cubic_epoch_when_app_limited = true;
-
-// If true, QUIC will measure head of line (HOL) blocking due between
-// streams due to packet losses on the headers stream.  The
-// measurements will be surfaced via UMA histogram
-// Net.QuicSession.HeadersHOLBlockedTime.
-bool FLAGS_quic_measure_headers_hol_blocking_time = true;
-
-// If true, disable pacing in QUIC.
-bool FLAGS_quic_disable_pacing_for_perf_tests = false;
-
-// If true, Close the connection instead of writing unencrypted stream data.
-bool FLAGS_quic_never_write_unencrypted_data = true;
-
-// If true, QUIC connections can do bandwidth resumption with an initial window
-// of < 10 packets.
-bool FLAGS_quic_no_lower_bw_resumption_limit = true;
-
-// Use largest acked in the most recent ack instead of largest acked ever in
-// loss recovery.
-bool FLAGS_quic_loss_recovery_use_largest_acked = true;
-
-// Only set one alarm for sending at once, either the send alarm or
-// retransmission alarm.  Disabled because it breaks QUIC time loss detection.
-bool FLAGS_quic_only_one_sending_alarm = false;
-
-// If true, QUIC public reset packets will have the \"pre-v33\" public header
-// flags.
-bool FLAGS_quic_use_old_public_reset_packets = true;
-
-// Adds a RATE connection option to do rate based sending.
-bool FLAGS_quic_rate_based_sending = true;
-
-// If true, QUIC will use cheap stateless rejects without creating a full
-// connection.
-bool FLAGS_quic_use_cheap_stateless_rejects = false;
-
-// If true, QUIC respect HTTP2 SETTINGS frame rather than always close the
-// connection.
-bool FLAGS_quic_respect_http2_settings_frame = true;
-
-// Do not use a QuicAckListener in order to confirm a larger Path MTU.
-bool FLAGS_quic_no_mtu_discovery_ack_listener = true;
-
-// If true, enables QUIC_VERSION_35.
-bool FLAGS_quic_enable_version_35 = true;
-
-// If true, re-enables QUIC_VERSION_36.
-bool FLAGS_quic_enable_version_36 = true;
-
-// If true, enables QUIC_VERSION_36.
-bool FLAGS_quic_enable_version_36_v2 = false;
-
-// If true, requires support for X509 certificates in QUIC CHLO PDMDs.
-bool FLAGS_quic_require_x509 = true;
-
-// If true, deprecate safeguards for b/26023400.
-bool FLAGS_quic_deprecate_kfixd = true;
-
-// If true, use async codepaths to invoke ProofSource::GetProof.
-bool FLAGS_enable_async_get_proof = false;
-
-// If true, neuter null encrypted packets before sending the next handshake
-// message.
-bool FLAGS_quic_neuter_unencrypted_when_sending = true;
-
-// If true, QuicAlarm::Update will call a faster UpdateImpl implementation
-// instead of canceling and reregistering the alarm.
-bool FLAGS_quic_change_alarms_efficiently = false;
-
-// If true, requires handshake confirmations for all QUIC handshakes with
-// versions less than 33.
-bool FLAGS_quic_require_handshake_confirmation_pre33 = false;
-
-// If true, use the interval form of iteration over a PacketNumberQueue instead
-// of iterating over the individual numbers.
-bool FLAGS_quic_use_packet_number_queue_intervals = true;
-
-// If true, fix a bug with which QuicStreamSequencerBuffer can\'t release block
-// memory in time.
-bool FLAGS_quic_sequencer_buffer_retire_block_in_time = true;
-
-// Remove obsolete code to force QUIC to go forward secure, now that the server
-// immediately goes forward secure.
-bool FLAGS_quic_remove_obsolete_forward_secure = false;
-
-// If true, close QUIC connection explicitly on write error due to packet being
-// too large.
-bool FLAGS_quic_close_connection_on_packet_too_large = true;
-
-// Use GetLeastUnacked when updating the packet number length, instead of
-// GetLeastPacketAwaitedByPeer.
-bool FLAGS_quic_least_unacked_packet_number_length = true;
-
-// If true, close the write side of a QUIC spdy stream when all queued bytes
-// have been written and a FIN has been sent.
-bool FLAGS_quic_close_stream_after_writing_queued_data = false;
-
-// If true, close connection with QUIC_TOO_MANY_FRAME_GAPS error when number of
-// gaps in QuicStreamSequenceBuffer exceeds allowed limit.
-bool FLAGS_quic_limit_frame_gaps_in_buffer = false;
-
-// If true, v33 QUIC client uses 1 bit to specify 8-byte connection id in public
-// flag.
-bool FLAGS_quic_remove_v33_hacks = true;
-
-// If true, use the CHLO packet size, not message size when determining how
-// large a REJ can be.
-bool FLAGS_quic_use_chlo_packet_size = false;
-
-// If true, defer creation of new connection till its CHLO arrives.
-bool FLAGS_quic_buffer_packet_till_chlo = false;
-
-// If true, the connection will check whether it is application-limited, and
-// notify the congestion controller about it.
-bool FLAGS_quic_enable_app_limited_check = true;
-
-// Deprecate QuicPacketCreator::next_packet_number_length_ because it's no
-// longer necessary.
-bool FLAGS_quic_simple_packet_number_length_2 = true;
-
-// If true, disables QUIC version less than 32.
-bool FLAGS_quic_disable_pre_32 = true;
diff --git a/src/net/quic/core/quic_flags.h.orig b/src/net/quic/core/quic_flags.h.orig
deleted file mode 100644
index 9b862f6..0000000
--- a/src/net/quic/core/quic_flags.h.orig
+++ /dev/null
@@ -1,56 +0,0 @@
-// Copyright 2014 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NET_QUIC_QUIC_FLAGS_H_
-#define NET_QUIC_QUIC_FLAGS_H_
-
-#include <stdint.h>
-
-#include "net/base/net_export.h"
-
-NET_EXPORT_PRIVATE extern bool FLAGS_use_early_return_when_verifying_chlo;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_allow_bbr;
-NET_EXPORT_PRIVATE extern int64_t FLAGS_quic_time_wait_list_seconds;
-NET_EXPORT_PRIVATE extern int64_t FLAGS_quic_time_wait_list_max_connections;
-NET_EXPORT_PRIVATE extern bool FLAGS_enable_quic_stateless_reject_support;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_always_log_bugs_for_tests;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_enable_multipath;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_require_handshake_confirmation;
-NET_EXPORT_PRIVATE extern bool FLAGS_shift_quic_cubic_epoch_when_app_limited;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_measure_headers_hol_blocking_time;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_disable_pacing_for_perf_tests;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_never_write_unencrypted_data;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_no_lower_bw_resumption_limit;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_loss_recovery_use_largest_acked;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_only_one_sending_alarm;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_use_old_public_reset_packets;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_rate_based_sending;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_use_cheap_stateless_rejects;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_respect_http2_settings_frame;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_no_mtu_discovery_ack_listener;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_enable_version_35;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_enable_version_36;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_enable_version_36_v2;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_require_x509;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_deprecate_kfixd;
-NET_EXPORT_PRIVATE extern bool FLAGS_enable_async_get_proof;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_neuter_unencrypted_when_sending;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_change_alarms_efficiently;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_require_handshake_confirmation_pre33;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_use_packet_number_queue_intervals;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_sequencer_buffer_retire_block_in_time;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_remove_obsolete_forward_secure;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_close_connection_on_packet_too_large;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_least_unacked_packet_number_length;
-NET_EXPORT_PRIVATE extern bool
-    FLAGS_quic_close_stream_after_writing_queued_data;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_limit_frame_gaps_in_buffer;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_remove_v33_hacks;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_use_chlo_packet_size;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_buffer_packet_till_chlo;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_enable_app_limited_check;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_simple_packet_number_length_2;
-NET_EXPORT_PRIVATE extern bool FLAGS_quic_disable_pre_32;
-
-#endif  // NET_QUIC_QUIC_FLAGS_H_
diff --git a/src/net/quic/core/quic_flow_controller.cc b/src/net/quic/core/quic_flow_controller.cc
index 12c0368..58836b8 100644
--- a/src/net/quic/core/quic_flow_controller.cc
+++ b/src/net/quic/core/quic_flow_controller.cc
@@ -43,7 +43,9 @@ QuicFlowController::QuicFlowController(QuicConnection* connection,
            << receive_window_offset_
            << ", max receive window to: " << receive_window_size_
            << ", max receive window limit to: " << receive_window_size_limit_
-           << ", setting send window offset to: " << send_window_offset_;
+           << ", setting send window offset to: " << send_window_offset_
+           << "should auto tune" << should_auto_tune_receive_window
+           ;
 }
 
 void QuicFlowController::AddBytesConsumed(QuicByteCount bytes_consumed) {
@@ -147,13 +149,13 @@ void QuicFlowController::MaybeIncreaseMaxWindowSize() {
       std::min(receive_window_size_, receive_window_size_limit_);
 
   if (receive_window_size_ > old_window) {
-    DVLOG(1) << ENDPOINT << "New max window increase for stream " << id_
+    VLOG(1) << ENDPOINT << "New max window increase for stream " << id_
              << " after " << since_last.ToMicroseconds() << " us, and RTT is "
              << rtt.ToMicroseconds()
              << "us. max wndw: " << receive_window_size_;
   } else {
     // TODO(ckrasic) - add a varz to track this (?).
-    DVLOG(1) << ENDPOINT << "Max window at limit for stream " << id_
+    VLOG(1) << ENDPOINT << "Max window at limit for stream " << id_
              << " after " << since_last.ToMicroseconds() << " us, and RTT is "
              << rtt.ToMicroseconds()
              << "us. Limit size: " << receive_window_size_;
@@ -184,7 +186,7 @@ void QuicFlowController::MaybeSendWindowUpdate() {
   // Update our receive window.
   receive_window_offset_ += (receive_window_size_ - available_window);
 
-  DVLOG(1) << ENDPOINT << "Sending WindowUpdate frame for stream " << id_
+  VLOG(1) << ENDPOINT << "Sending WindowUpdate frame for stream " << id_
            << ", consumed bytes: " << bytes_consumed_
            << ", available window: " << available_window
            << ", and threshold: " << threshold
diff --git a/src/net/quic/core/quic_sent_packet_manager.cc b/src/net/quic/core/quic_sent_packet_manager.cc
index 022ce3e..2db2044 100644
--- a/src/net/quic/core/quic_sent_packet_manager.cc
+++ b/src/net/quic/core/quic_sent_packet_manager.cc
@@ -111,6 +111,7 @@ void QuicSentPacketManager::SetFromConfig(const QuicConfig& config) {
   const bool enable_client_connection_options =
       FLAGS_quic_client_connection_options;
   if (enable_client_connection_options) {
+    VLOG(0) << "has connection options0:" << config.HasClientRequestedIndependentOption(kTBBR, perspective_);
     if (FLAGS_quic_allow_new_bbr &&
         config.HasClientRequestedIndependentOption(kTBBR, perspective_)) {
       SetSendAlgorithm(kBBR);
@@ -125,6 +126,7 @@ void QuicSentPacketManager::SetFromConfig(const QuicConfig& config) {
                                                           perspective_)) {
       SetSendAlgorithm(kCubic);
     }
+    VLOG(0) << "has connection options2";
   } else {
     if (FLAGS_quic_allow_new_bbr && config.HasReceivedConnectionOptions() &&
         ContainsQuicTag(config.ReceivedConnectionOptions(), kTBBR)) {
@@ -237,6 +239,7 @@ void QuicSentPacketManager::OnIncomingAck(const QuicAckFrame& ack_frame,
   bool rtt_updated = MaybeUpdateRTT(ack_frame, ack_receive_time);
   DCHECK_GE(ack_frame.largest_observed, unacked_packets_.largest_observed());
   unacked_packets_.IncreaseLargestObserved(ack_frame.largest_observed);
+  VLOG(0) << "Increase:" << ack_frame.largest_observed; 
 
   HandleAckForSentPackets(ack_frame);
   InvokeLossDetection(ack_receive_time);
diff --git a/src/net/quic/core/quic_stream.cc b/src/net/quic/core/quic_stream.cc
index 651a990..8027d82 100644
--- a/src/net/quic/core/quic_stream.cc
+++ b/src/net/quic/core/quic_stream.cc
@@ -284,6 +284,8 @@ QuicConsumedData QuicStream::WritevData(
 
   // How much data flow control permits to be written.
   QuicByteCount send_window = flow_controller_.SendWindowSize();
+  VLOG(1) << "sakacho WindowSize diff:" << send_window << ", conn:" <<
+    connection_flow_controller_->SendWindowSize();
   if (stream_contributes_to_connection_flow_control_) {
     send_window =
         std::min(send_window, connection_flow_controller_->SendWindowSize());
@@ -291,10 +293,12 @@ QuicConsumedData QuicStream::WritevData(
 
   if (session_->ShouldYield(id())) {
     session_->MarkConnectionLevelWriteBlocked(id());
+    VLOG(1) << "sakacho id():" << id() << ",Yield";
     return QuicConsumedData(0, false);
   }
 
   if (send_window == 0 && !fin_with_zero_data) {
+    VLOG(1) << "sakacho MaybeSendBlocked()";
     // Quick return if nothing can be sent.
     MaybeSendBlocked();
     return QuicConsumedData(0, false);
diff --git a/src/net/tools/quic/end_to_end_test.cc.orig b/src/net/tools/quic/end_to_end_test.cc.orig
deleted file mode 100644
index 9b78393..0000000
--- a/src/net/tools/quic/end_to_end_test.cc.orig
+++ /dev/null
@@ -1,2843 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include <stddef.h>
-#include <sys/epoll.h>
-
-#include <list>
-#include <memory>
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "base/memory/singleton.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/synchronization/waitable_event.h"
-#include "base/threading/platform_thread.h"
-#include "base/time/time.h"
-#include "net/base/ip_address.h"
-#include "net/base/ip_endpoint.h"
-#include "net/quic/crypto/aes_128_gcm_12_encrypter.h"
-#include "net/quic/crypto/null_encrypter.h"
-#include "net/quic/quic_client_session_base.h"
-#include "net/quic/quic_flags.h"
-#include "net/quic/quic_framer.h"
-#include "net/quic/quic_packet_creator.h"
-#include "net/quic/quic_protocol.h"
-#include "net/quic/quic_server_id.h"
-#include "net/quic/quic_session.h"
-#include "net/quic/quic_utils.h"
-#include "net/quic/test_tools/crypto_test_utils.h"
-#include "net/quic/test_tools/quic_config_peer.h"
-#include "net/quic/test_tools/quic_connection_peer.h"
-#include "net/quic/test_tools/quic_flow_controller_peer.h"
-#include "net/quic/test_tools/quic_sent_packet_manager_peer.h"
-#include "net/quic/test_tools/quic_session_peer.h"
-#include "net/quic/test_tools/quic_spdy_session_peer.h"
-#include "net/quic/test_tools/quic_test_utils.h"
-#include "net/quic/test_tools/reliable_quic_stream_peer.h"
-#include "net/test/gtest_util.h"
-#include "net/tools/epoll_server/epoll_server.h"
-#include "net/tools/quic/quic_epoll_connection_helper.h"
-#include "net/tools/quic/quic_in_memory_cache.h"
-#include "net/tools/quic/quic_packet_writer_wrapper.h"
-#include "net/tools/quic/quic_server.h"
-#include "net/tools/quic/quic_simple_server_stream.h"
-#include "net/tools/quic/quic_socket_utils.h"
-#include "net/tools/quic/quic_spdy_client_stream.h"
-#include "net/tools/quic/test_tools/http_message.h"
-#include "net/tools/quic/test_tools/packet_dropping_test_writer.h"
-#include "net/tools/quic/test_tools/quic_client_peer.h"
-#include "net/tools/quic/test_tools/quic_dispatcher_peer.h"
-#include "net/tools/quic/test_tools/quic_in_memory_cache_peer.h"
-#include "net/tools/quic/test_tools/quic_server_peer.h"
-#include "net/tools/quic/test_tools/quic_test_client.h"
-#include "net/tools/quic/test_tools/quic_test_server.h"
-#include "net/tools/quic/test_tools/server_thread.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-using base::IntToString;
-using base::StringPiece;
-using base::WaitableEvent;
-using net::EpollServer;
-using net::test::ConstructEncryptedPacket;
-using net::test::CryptoTestUtils;
-using net::test::GenerateBody;
-using net::test::Loopback4;
-using net::test::MockQuicConnectionDebugVisitor;
-using net::test::QuicConnectionPeer;
-using net::test::QuicFlowControllerPeer;
-using net::test::QuicSentPacketManagerPeer;
-using net::test::QuicSessionPeer;
-using net::test::QuicSpdySessionPeer;
-using net::test::ReliableQuicStreamPeer;
-using net::test::ValueRestore;
-using net::test::kClientDataStreamId1;
-using net::test::kInitialSessionFlowControlWindowForTest;
-using net::test::kInitialStreamFlowControlWindowForTest;
-using net::test::PacketDroppingTestWriter;
-using net::test::QuicDispatcherPeer;
-using net::test::QuicServerPeer;
-using std::ostream;
-using std::string;
-using std::vector;
-
-namespace net {
-namespace test {
-namespace {
-
-const char kFooResponseBody[] = "Artichoke hearts make me happy.";
-const char kBarResponseBody[] = "Palm hearts are pretty delicious, also.";
-const float kSessionToStreamRatio = 1.5;
-
-// Run all tests with the cross products of all versions.
-struct TestParams {
-  TestParams(const QuicVersionVector& client_supported_versions,
-             const QuicVersionVector& server_supported_versions,
-             QuicVersion negotiated_version,
-             bool client_supports_stateless_rejects,
-             bool server_uses_stateless_rejects_if_peer_supported,
-             QuicTag congestion_control_tag,
-             bool auto_tune_flow_control_window,
-             bool disable_hpack_dynamic_table,
-             bool force_hol_blocking)
-      : client_supported_versions(client_supported_versions),
-        server_supported_versions(server_supported_versions),
-        negotiated_version(negotiated_version),
-        client_supports_stateless_rejects(client_supports_stateless_rejects),
-        server_uses_stateless_rejects_if_peer_supported(
-            server_uses_stateless_rejects_if_peer_supported),
-        congestion_control_tag(congestion_control_tag),
-        auto_tune_flow_control_window(auto_tune_flow_control_window),
-        disable_hpack_dynamic_table(disable_hpack_dynamic_table),
-        force_hol_blocking(force_hol_blocking) {}
-
-  friend ostream& operator<<(ostream& os, const TestParams& p) {
-    os << "{ server_supported_versions: "
-       << QuicVersionVectorToString(p.server_supported_versions);
-    os << " client_supported_versions: "
-       << QuicVersionVectorToString(p.client_supported_versions);
-    os << " negotiated_version: " << QuicVersionToString(p.negotiated_version);
-    os << " client_supports_stateless_rejects: "
-       << p.client_supports_stateless_rejects;
-    os << " server_uses_stateless_rejects_if_peer_supported: "
-       << p.server_uses_stateless_rejects_if_peer_supported;
-    os << " congestion_control_tag: "
-       << QuicUtils::TagToString(p.congestion_control_tag);
-    os << " auto_tune_flow_control_window: " << p.auto_tune_flow_control_window;
-    os << " disable_hpack_dynamic_table: " << p.disable_hpack_dynamic_table;
-    os << " force_hol_blocking: " << p.force_hol_blocking << " }";
-    return os;
-  }
-
-  QuicVersionVector client_supported_versions;
-  QuicVersionVector server_supported_versions;
-  QuicVersion negotiated_version;
-  bool client_supports_stateless_rejects;
-  bool server_uses_stateless_rejects_if_peer_supported;
-  QuicTag congestion_control_tag;
-  bool auto_tune_flow_control_window;
-  bool disable_hpack_dynamic_table;
-  bool force_hol_blocking;
-};
-
-// Constructs various test permutations.
-vector<TestParams> GetTestParams() {
-  // Divide the versions into buckets in which the intra-frame format
-  // is compatible. When clients encounter QUIC version negotiation
-  // they simply retransmit all packets using the new version's
-  // QUIC framing. However, they are unable to change the intra-frame
-  // layout (for example to change SPDY/4 headers to SPDY/3). So
-  // these tests need to ensure that clients are never attempting
-  // to do 0-RTT across incompatible versions. Chromium only supports
-  // a single version at a time anyway. :)
-  QuicVersionVector all_supported_versions = QuicSupportedVersions();
-  QuicVersionVector version_buckets[4];
-
-  for (const QuicVersion version : all_supported_versions) {
-    if (version <= QUIC_VERSION_25) {
-      // SPDY/4
-      version_buckets[0].push_back(version);
-    } else if (version <= QUIC_VERSION_32) {
-      // QUIC_VERSION_26 changes the kdf in a way that is incompatible with
-      // version negotiation across the version 26 boundary.
-      version_buckets[1].push_back(version);
-    } else if (version <= QUIC_VERSION_33) {
-      // QUIC_VERSION_33 changes the kdf in a way that is incompatible with
-      // version negotiation across the version 33 boundary, by using the
-      // diversification nonce.
-      version_buckets[2].push_back(version);
-    } else {
-      // QUIC_VERSION_34 deprecates entropy and uses new ack and stop waiting
-      // wire formats, so it is incompatible with version negotiation across the
-      // version 34 boundary.
-      version_buckets[3].push_back(version);
-    }
-  }
-
-  // This must be kept in sync with the number of nested for-loops below as it
-  // is used to prune the number of tests that are run.
-  const int kMaxEnabledOptions = 5;
-  int max_enabled_options = 0;
-  vector<TestParams> params;
-  for (bool server_uses_stateless_rejects_if_peer_supported : {true, false}) {
-    for (bool client_supports_stateless_rejects : {true, false}) {
-      for (const QuicTag congestion_control_tag : {kRENO, kQBIC}) {
-        for (bool auto_tune_flow_control_window : {true, false}) {
-          for (bool disable_hpack_dynamic_table : {false}) {
-            for (bool force_hol_blocking : {true, false}) {
-              int enabled_options = 0;
-              if (force_hol_blocking) {
-                ++enabled_options;
-              }
-              if (congestion_control_tag != kQBIC) {
-                ++enabled_options;
-              }
-              if (auto_tune_flow_control_window) {
-                ++enabled_options;
-              }
-              if (disable_hpack_dynamic_table) {
-                ++enabled_options;
-              }
-              if (client_supports_stateless_rejects) {
-                ++enabled_options;
-              }
-              if (server_uses_stateless_rejects_if_peer_supported) {
-                ++enabled_options;
-              }
-              CHECK_GE(kMaxEnabledOptions, enabled_options);
-              if (enabled_options > max_enabled_options) {
-                max_enabled_options = enabled_options;
-              }
-
-              // Run tests with no options, a single option, or all the options
-              // enabled to avoid a combinatorial explosion.
-              if (enabled_options > 1 && enabled_options < kMaxEnabledOptions) {
-                continue;
-              }
-
-              for (const QuicVersionVector& client_versions : version_buckets) {
-                if (client_versions.front() < QUIC_VERSION_30 &&
-                    FLAGS_quic_disable_pre_30) {
-                  continue;
-                }
-                CHECK(!client_versions.empty());
-                // Add an entry for server and client supporting all versions.
-                params.push_back(TestParams(
-                    client_versions, all_supported_versions,
-                    client_versions.front(), client_supports_stateless_rejects,
-                    server_uses_stateless_rejects_if_peer_supported,
-                    congestion_control_tag, auto_tune_flow_control_window,
-                    disable_hpack_dynamic_table, force_hol_blocking));
-
-                // Run version negotiation tests tests with no options, or all
-                // the options enabled to avoid a combinatorial explosion.
-                if (enabled_options > 0 &&
-                    enabled_options < kMaxEnabledOptions) {
-                  continue;
-                }
-
-                // Test client supporting all versions and server
-                // supporting 1 version. Simulate an old server and
-                // exercise version downgrade in the client. Protocol
-                // negotiation should occur. Skip the i = 0 case
-                // because it is essentially the same as the default
-                // case.
-                for (size_t i = 1; i < client_versions.size(); ++i) {
-                  if (client_versions[i] < QUIC_VERSION_30 &&
-                      FLAGS_quic_disable_pre_30) {
-                    continue;
-                  }
-                  QuicVersionVector server_supported_versions;
-                  server_supported_versions.push_back(client_versions[i]);
-                  params.push_back(TestParams(
-                      client_versions, server_supported_versions,
-                      server_supported_versions.front(),
-                      client_supports_stateless_rejects,
-                      server_uses_stateless_rejects_if_peer_supported,
-                      congestion_control_tag, auto_tune_flow_control_window,
-                      disable_hpack_dynamic_table, force_hol_blocking));
-                }
-              }
-            }
-          }
-        }
-      }
-    }
-    CHECK_EQ(kMaxEnabledOptions, max_enabled_options);
-  }
-  return params;
-}
-
-class ServerDelegate : public PacketDroppingTestWriter::Delegate {
- public:
-  explicit ServerDelegate(QuicDispatcher* dispatcher)
-      : dispatcher_(dispatcher) {}
-  ~ServerDelegate() override {}
-  void OnCanWrite() override { dispatcher_->OnCanWrite(); }
-
- private:
-  QuicDispatcher* dispatcher_;
-};
-
-class ClientDelegate : public PacketDroppingTestWriter::Delegate {
- public:
-  explicit ClientDelegate(QuicClient* client) : client_(client) {}
-  ~ClientDelegate() override {}
-  void OnCanWrite() override {
-    EpollEvent event(EPOLLOUT, false);
-    client_->OnEvent(client_->GetLatestFD(), &event);
-  }
-
- private:
-  QuicClient* client_;
-};
-
-class EndToEndTest : public ::testing::TestWithParam<TestParams> {
- protected:
-  EndToEndTest()
-      : initialized_(false),
-        server_address_(IPEndPoint(Loopback4(), 0)),
-        server_hostname_("example.com"),
-        server_started_(false),
-        strike_register_no_startup_period_(false),
-        chlo_multiplier_(0),
-        stream_factory_(nullptr),
-        support_server_push_(false) {
-    client_supported_versions_ = GetParam().client_supported_versions;
-    server_supported_versions_ = GetParam().server_supported_versions;
-    negotiated_version_ = GetParam().negotiated_version;
-
-    VLOG(1) << "Using Configuration: " << GetParam();
-
-    // Use different flow control windows for client/server.
-    client_config_.SetInitialStreamFlowControlWindowToSend(
-        2 * kInitialStreamFlowControlWindowForTest);
-    client_config_.SetInitialSessionFlowControlWindowToSend(
-        2 * kInitialSessionFlowControlWindowForTest);
-    server_config_.SetInitialStreamFlowControlWindowToSend(
-        3 * kInitialStreamFlowControlWindowForTest);
-    server_config_.SetInitialSessionFlowControlWindowToSend(
-        3 * kInitialSessionFlowControlWindowForTest);
-
-    // The default idle timeouts can be too strict when running on a busy
-    // machine.
-    const QuicTime::Delta timeout = QuicTime::Delta::FromSeconds(30);
-    client_config_.set_max_time_before_crypto_handshake(timeout);
-    client_config_.set_max_idle_time_before_crypto_handshake(timeout);
-    server_config_.set_max_time_before_crypto_handshake(timeout);
-    server_config_.set_max_idle_time_before_crypto_handshake(timeout);
-
-    QuicInMemoryCachePeer::ResetForTests();
-    AddToCache("/foo", 200, kFooResponseBody);
-    AddToCache("/bar", 200, kBarResponseBody);
-  }
-
-  ~EndToEndTest() override {
-    // TODO(rtenneti): port RecycleUnusedPort if needed.
-    // RecycleUnusedPort(server_address_.port());
-    QuicInMemoryCachePeer::ResetForTests();
-  }
-
-  QuicTestClient* CreateQuicClient(QuicPacketWriterWrapper* writer) {
-    QuicTestClient* client =
-        new QuicTestClient(server_address_, server_hostname_, client_config_,
-                           client_supported_versions_);
-    client->UseWriter(writer);
-    client->Connect();
-    return client;
-  }
-
-  void set_smaller_flow_control_receive_window() {
-    const uint32_t kClientIFCW = 64 * 1024;
-    const uint32_t kServerIFCW = 1024 * 1024;
-    set_client_initial_stream_flow_control_receive_window(kClientIFCW);
-    set_client_initial_session_flow_control_receive_window(
-        kSessionToStreamRatio * kClientIFCW);
-    set_server_initial_stream_flow_control_receive_window(kServerIFCW);
-    set_server_initial_session_flow_control_receive_window(
-        kSessionToStreamRatio * kServerIFCW);
-  }
-
-  void set_client_initial_stream_flow_control_receive_window(uint32_t window) {
-    CHECK(client_.get() == nullptr);
-    DVLOG(1) << "Setting client initial stream flow control window: " << window;
-    client_config_.SetInitialStreamFlowControlWindowToSend(window);
-  }
-
-  void set_client_initial_session_flow_control_receive_window(uint32_t window) {
-    CHECK(client_.get() == nullptr);
-    DVLOG(1) << "Setting client initial session flow control window: "
-             << window;
-    client_config_.SetInitialSessionFlowControlWindowToSend(window);
-  }
-
-  void set_server_initial_stream_flow_control_receive_window(uint32_t window) {
-    CHECK(server_thread_.get() == nullptr);
-    DVLOG(1) << "Setting server initial stream flow control window: " << window;
-    server_config_.SetInitialStreamFlowControlWindowToSend(window);
-  }
-
-  void set_server_initial_session_flow_control_receive_window(uint32_t window) {
-    CHECK(server_thread_.get() == nullptr);
-    DVLOG(1) << "Setting server initial session flow control window: "
-             << window;
-    server_config_.SetInitialSessionFlowControlWindowToSend(window);
-  }
-
-  const QuicSentPacketManagerInterface*
-  GetSentPacketManagerFromFirstServerSession() const {
-    QuicDispatcher* dispatcher =
-        QuicServerPeer::GetDispatcher(server_thread_->server());
-    QuicSession* session = dispatcher->session_map().begin()->second;
-    return &session->connection()->sent_packet_manager();
-  }
-
-  bool Initialize() {
-    QuicTagVector copt;
-    server_config_.SetConnectionOptionsToSend(copt);
-
-    // TODO(nimia): Consider setting the congestion control algorithm for the
-    // client as well according to the test parameter.
-    copt.push_back(GetParam().congestion_control_tag);
-    if (support_server_push_) {
-      copt.push_back(kSPSH);
-    }
-    if (GetParam().client_supports_stateless_rejects) {
-      copt.push_back(kSREJ);
-    }
-    if (GetParam().auto_tune_flow_control_window) {
-      copt.push_back(kAFCW);
-      copt.push_back(kIFW5);
-    }
-    if (GetParam().disable_hpack_dynamic_table) {
-      copt.push_back(kDHDT);
-    }
-    if (GetParam().force_hol_blocking) {
-      client_config_.SetForceHolBlocking();
-      QuicConfigPeer::SetReceivedForceHolBlocking(&server_config_);
-    }
-    client_config_.SetConnectionOptionsToSend(copt);
-
-    // Start the server first, because CreateQuicClient() attempts
-    // to connect to the server.
-    StartServer();
-
-    client_.reset(CreateQuicClient(client_writer_));
-    static EpollEvent event(EPOLLOUT, false);
-    client_writer_->Initialize(
-        reinterpret_cast<QuicEpollConnectionHelper*>(
-            QuicConnectionPeer::GetHelper(
-                client_->client()->session()->connection())),
-        QuicConnectionPeer::GetAlarmFactory(
-            client_->client()->session()->connection()),
-        new ClientDelegate(client_->client()));
-
-    initialized_ = true;
-    return client_->client()->connected();
-  }
-
-  void SetUp() override {
-    // The ownership of these gets transferred to the QuicPacketWriterWrapper
-    // when Initialize() is executed.
-    client_writer_ = new PacketDroppingTestWriter();
-    server_writer_ = new PacketDroppingTestWriter();
-  }
-
-  void TearDown() override {
-    ASSERT_TRUE(initialized_) << "You must call Initialize() in every test "
-                              << "case. Otherwise, your test will leak memory.";
-    StopServer();
-  }
-
-  void StartServer() {
-    server_thread_.reset(new ServerThread(
-        new QuicTestServer(CryptoTestUtils::ProofSourceForTesting(),
-                           server_config_, server_supported_versions_),
-        server_address_, strike_register_no_startup_period_));
-    if (chlo_multiplier_ != 0) {
-      server_thread_->server()->SetChloMultiplier(chlo_multiplier_);
-    }
-    server_thread_->Initialize();
-    server_address_ =
-        IPEndPoint(server_address_.address(), server_thread_->GetPort());
-    QuicDispatcher* dispatcher =
-        QuicServerPeer::GetDispatcher(server_thread_->server());
-    QuicDispatcherPeer::UseWriter(dispatcher, server_writer_);
-
-    FLAGS_enable_quic_stateless_reject_support =
-        GetParam().server_uses_stateless_rejects_if_peer_supported;
-
-    server_writer_->Initialize(QuicDispatcherPeer::GetHelper(dispatcher),
-                               QuicDispatcherPeer::GetAlarmFactory(dispatcher),
-                               new ServerDelegate(dispatcher));
-    if (stream_factory_ != nullptr) {
-      static_cast<QuicTestServer*>(server_thread_->server())
-          ->SetSpdyStreamFactory(stream_factory_);
-    }
-
-    server_thread_->Start();
-    server_started_ = true;
-  }
-
-  void StopServer() {
-    if (!server_started_)
-      return;
-    if (server_thread_.get()) {
-      server_thread_->Quit();
-      server_thread_->Join();
-    }
-  }
-
-  void AddToCache(StringPiece path, int response_code, StringPiece body) {
-    QuicInMemoryCache::GetInstance()->AddSimpleResponse("www.google.com", path,
-                                                        response_code, body);
-  }
-
-  void SetPacketLossPercentage(int32_t loss) {
-    // TODO(rtenneti): enable when we can do random packet loss tests in
-    // chrome's tree.
-    if (loss != 0 && loss != 100)
-      return;
-    client_writer_->set_fake_packet_loss_percentage(loss);
-    server_writer_->set_fake_packet_loss_percentage(loss);
-  }
-
-  void SetPacketSendDelay(QuicTime::Delta delay) {
-    // TODO(rtenneti): enable when we can do random packet send delay tests in
-    // chrome's tree.
-    // client_writer_->set_fake_packet_delay(delay);
-    // server_writer_->set_fake_packet_delay(delay);
-  }
-
-  void SetReorderPercentage(int32_t reorder) {
-    // TODO(rtenneti): enable when we can do random packet reorder tests in
-    // chrome's tree.
-    // client_writer_->set_fake_reorder_percentage(reorder);
-    // server_writer_->set_fake_reorder_percentage(reorder);
-  }
-
-  // Verifies that the client and server connections were both free of packets
-  // being discarded, based on connection stats.
-  // Calls server_thread_ Pause() and Resume(), which may only be called once
-  // per test.
-  void VerifyCleanConnection(bool had_packet_loss) {
-    QuicConnectionStats client_stats =
-        client_->client()->session()->connection()->GetStats();
-    if (FLAGS_quic_reply_to_rej && !had_packet_loss) {
-      EXPECT_EQ(0u, client_stats.packets_lost);
-    }
-    EXPECT_EQ(0u, client_stats.packets_discarded);
-    // When doing 0-RTT with stateless rejects, the encrypted requests cause
-    // a retranmission of the SREJ packets which are dropped by the client.
-    if (!BothSidesSupportStatelessRejects()) {
-      EXPECT_EQ(0u, client_stats.packets_dropped);
-    }
-    EXPECT_EQ(client_stats.packets_received, client_stats.packets_processed);
-
-    const int num_expected_stateless_rejects =
-        (BothSidesSupportStatelessRejects() &&
-         client_->client()->session()->GetNumSentClientHellos() > 0)
-            ? 1
-            : 0;
-    EXPECT_EQ(num_expected_stateless_rejects,
-              client_->client()->num_stateless_rejects_received());
-
-    server_thread_->Pause();
-    QuicDispatcher* dispatcher =
-        QuicServerPeer::GetDispatcher(server_thread_->server());
-    ASSERT_EQ(1u, dispatcher->session_map().size());
-    QuicSession* session = dispatcher->session_map().begin()->second;
-    QuicConnectionStats server_stats = session->connection()->GetStats();
-    if (FLAGS_quic_reply_to_rej && !had_packet_loss) {
-      EXPECT_EQ(0u, server_stats.packets_lost);
-    }
-    EXPECT_EQ(0u, server_stats.packets_discarded);
-    // TODO(ianswett): Restore the check for packets_dropped equals 0.
-    // The expect for packets received is equal to packets processed fails
-    // due to version negotiation packets.
-    server_thread_->Resume();
-  }
-
-  bool BothSidesSupportStatelessRejects() {
-    return (GetParam().server_uses_stateless_rejects_if_peer_supported &&
-            GetParam().client_supports_stateless_rejects);
-  }
-
-  void ExpectFlowControlsSynced(QuicFlowController* client,
-                                QuicFlowController* server) {
-    EXPECT_EQ(QuicFlowControllerPeer::SendWindowSize(client),
-              QuicFlowControllerPeer::ReceiveWindowSize(server));
-    EXPECT_EQ(QuicFlowControllerPeer::ReceiveWindowSize(client),
-              QuicFlowControllerPeer::SendWindowSize(server));
-  }
-
-  // Must be called before Initialize to have effect.
-  void SetSpdyStreamFactory(QuicTestServer::StreamFactory* factory) {
-    stream_factory_ = factory;
-  }
-
-  bool initialized_;
-  IPEndPoint server_address_;
-  string server_hostname_;
-  std::unique_ptr<ServerThread> server_thread_;
-  std::unique_ptr<QuicTestClient> client_;
-  PacketDroppingTestWriter* client_writer_;
-  PacketDroppingTestWriter* server_writer_;
-  bool server_started_;
-  QuicConfig client_config_;
-  QuicConfig server_config_;
-  QuicVersionVector client_supported_versions_;
-  QuicVersionVector server_supported_versions_;
-  QuicVersion negotiated_version_;
-  bool strike_register_no_startup_period_;
-  size_t chlo_multiplier_;
-  QuicTestServer::StreamFactory* stream_factory_;
-  bool support_server_push_;
-  bool force_hol_blocking_;
-};
-
-// Run all end to end tests with all supported versions.
-INSTANTIATE_TEST_CASE_P(EndToEndTests,
-                        EndToEndTest,
-                        ::testing::ValuesIn(GetTestParams()));
-
-TEST_P(EndToEndTest, SimpleRequestResponse) {
-  ASSERT_TRUE(Initialize());
-
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-  EXPECT_EQ(2, client_->client()->GetNumSentClientHellos());
-}
-
-TEST_P(EndToEndTest, SimpleRequestResponseWithLargeReject) {
-  chlo_multiplier_ = 1;
-  ASSERT_TRUE(Initialize());
-
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-  EXPECT_EQ(3, client_->client()->GetNumSentClientHellos());
-}
-
-// TODO(rch): figure out how to detect missing v6 support (like on the linux
-// try bots) and selectively disable this test.
-TEST_P(EndToEndTest, DISABLED_SimpleRequestResponsev6) {
-  server_address_ =
-      IPEndPoint(IPAddress::IPv6Localhost(), server_address_.port());
-  ASSERT_TRUE(Initialize());
-
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-}
-
-TEST_P(EndToEndTest, SeparateFinPacket) {
-  ASSERT_TRUE(Initialize());
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.set_has_complete_message(false);
-
-  // Send a request in two parts: the request and then an empty packet with FIN.
-  client_->SendMessage(request);
-  client_->SendData("", true);
-  client_->WaitForResponse();
-  EXPECT_EQ(kFooResponseBody, client_->response_body());
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-
-  // Now do the same thing but with a content length.
-  request.AddBody("foo", true);
-  client_->SendMessage(request);
-  client_->SendData("", true);
-  client_->WaitForResponse();
-  EXPECT_EQ(kFooResponseBody, client_->response_body());
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-}
-
-TEST_P(EndToEndTest, MultipleRequestResponse) {
-  ASSERT_TRUE(Initialize());
-
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-  EXPECT_EQ(kBarResponseBody, client_->SendSynchronousRequest("/bar"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-}
-
-TEST_P(EndToEndTest, MultipleClients) {
-  ASSERT_TRUE(Initialize());
-  std::unique_ptr<QuicTestClient> client2(CreateQuicClient(nullptr));
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddHeader("content-length", "3");
-  request.set_has_complete_message(false);
-
-  client_->SendMessage(request);
-  client2->SendMessage(request);
-
-  client_->SendData("bar", true);
-  client_->WaitForResponse();
-  EXPECT_EQ(kFooResponseBody, client_->response_body());
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-
-  client2->SendData("eep", true);
-  client2->WaitForResponse();
-  EXPECT_EQ(kFooResponseBody, client2->response_body());
-  EXPECT_EQ(200u, client2->response_headers()->parsed_response_code());
-}
-
-TEST_P(EndToEndTest, RequestOverMultiplePackets) {
-  // Send a large enough request to guarantee fragmentation.
-  string huge_request = "/some/path?query=" + string(kMaxPacketSize, '.');
-  AddToCache(huge_request, 200, kBarResponseBody);
-
-  ASSERT_TRUE(Initialize());
-
-  EXPECT_EQ(kBarResponseBody, client_->SendSynchronousRequest(huge_request));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-}
-
-TEST_P(EndToEndTest, MultiplePacketsRandomOrder) {
-  // Send a large enough request to guarantee fragmentation.
-  string huge_request = "/some/path?query=" + string(kMaxPacketSize, '.');
-  AddToCache(huge_request, 200, kBarResponseBody);
-
-  ASSERT_TRUE(Initialize());
-  SetPacketSendDelay(QuicTime::Delta::FromMilliseconds(2));
-  SetReorderPercentage(50);
-
-  EXPECT_EQ(kBarResponseBody, client_->SendSynchronousRequest(huge_request));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-}
-
-TEST_P(EndToEndTest, PostMissingBytes) {
-  ASSERT_TRUE(Initialize());
-
-  // Add a content length header with no body.
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddHeader("content-length", "3");
-  request.set_skip_message_validation(true);
-
-  // This should be detected as stream fin without complete request,
-  // triggering an error response.
-  client_->SendCustomSynchronousRequest(request);
-  EXPECT_EQ(QuicSimpleServerStream::kErrorResponseBody,
-            client_->response_body());
-  EXPECT_EQ(500u, client_->response_headers()->parsed_response_code());
-}
-
-TEST_P(EndToEndTest, LargePostNoPacketLoss) {
-  ASSERT_TRUE(Initialize());
-
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  // 1 MB body.
-  string body;
-  GenerateBody(&body, 1024 * 1024);
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddBody(body, true);
-
-  EXPECT_EQ(kFooResponseBody, client_->SendCustomSynchronousRequest(request));
-  // TODO(ianswett): There should not be packet loss in this test, but on some
-  // platforms the receive buffer overflows.
-  VerifyCleanConnection(true);
-}
-
-TEST_P(EndToEndTest, LargePostNoPacketLoss1sRTT) {
-  ASSERT_TRUE(Initialize());
-  SetPacketSendDelay(QuicTime::Delta::FromMilliseconds(1000));
-
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  // 100 KB body.
-  string body;
-  GenerateBody(&body, 100 * 1024);
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddBody(body, true);
-
-  EXPECT_EQ(kFooResponseBody, client_->SendCustomSynchronousRequest(request));
-  VerifyCleanConnection(false);
-}
-
-TEST_P(EndToEndTest, LargePostWithPacketLoss) {
-  if (!BothSidesSupportStatelessRejects()) {
-    // Connect with lower fake packet loss than we'd like to test.
-    // Until b/10126687 is fixed, losing handshake packets is pretty
-    // brutal.
-    // TODO(jokulik): Until we support redundant SREJ packets, don't
-    // drop handshake packets for stateless rejects.
-    SetPacketLossPercentage(5);
-  }
-  ASSERT_TRUE(Initialize());
-
-  // Wait for the server SHLO before upping the packet loss.
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  SetPacketLossPercentage(30);
-
-  // 10 KB body.
-  string body;
-  GenerateBody(&body, 1024 * 10);
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddBody(body, true);
-
-  EXPECT_EQ(kFooResponseBody, client_->SendCustomSynchronousRequest(request));
-  VerifyCleanConnection(true);
-}
-
-TEST_P(EndToEndTest, LargePostWithPacketLossAndBlockedSocket) {
-  if (!BothSidesSupportStatelessRejects()) {
-    // Connect with lower fake packet loss than we'd like to test.  Until
-    // b/10126687 is fixed, losing handshake packets is pretty brutal.
-    // TODO(jokulik): Until we support redundant SREJ packets, don't
-    // drop handshake packets for stateless rejects.
-    SetPacketLossPercentage(5);
-  }
-  ASSERT_TRUE(Initialize());
-
-  // Wait for the server SHLO before upping the packet loss.
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  SetPacketLossPercentage(10);
-  client_writer_->set_fake_blocked_socket_percentage(10);
-
-  // 10 KB body.
-  string body;
-  GenerateBody(&body, 1024 * 10);
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddBody(body, true);
-
-  EXPECT_EQ(kFooResponseBody, client_->SendCustomSynchronousRequest(request));
-}
-
-TEST_P(EndToEndTest, LargePostNoPacketLossWithDelayAndReordering) {
-  ASSERT_TRUE(Initialize());
-
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  // Both of these must be called when the writer is not actively used.
-  SetPacketSendDelay(QuicTime::Delta::FromMilliseconds(2));
-  SetReorderPercentage(30);
-
-  // 1 MB body.
-  string body;
-  GenerateBody(&body, 1024 * 1024);
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddBody(body, true);
-
-  EXPECT_EQ(kFooResponseBody, client_->SendCustomSynchronousRequest(request));
-}
-
-TEST_P(EndToEndTest, LargePostZeroRTTFailure) {
-  // Have the server accept 0-RTT without waiting a startup period.
-  strike_register_no_startup_period_ = true;
-
-  // Send a request and then disconnect. This prepares the client to attempt
-  // a 0-RTT handshake for the next request.
-  ASSERT_TRUE(Initialize());
-
-  string body;
-  GenerateBody(&body, 20480);
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddBody(body, true);
-
-  EXPECT_EQ(kFooResponseBody, client_->SendCustomSynchronousRequest(request));
-  // In the non-stateless case, the same session is used for both
-  // hellos, so the number of hellos sent on that session is 2.  In
-  // the stateless case, the first client session will be completely
-  // torn down after the reject.  The number of hellos on the latest
-  // session is 1.
-  const int expected_num_hellos_latest_session =
-      BothSidesSupportStatelessRejects() ? 1 : 2;
-  EXPECT_EQ(expected_num_hellos_latest_session,
-            client_->client()->session()->GetNumSentClientHellos());
-  EXPECT_EQ(2, client_->client()->GetNumSentClientHellos());
-
-  client_->Disconnect();
-
-  // The 0-RTT handshake should succeed.
-  client_->Connect();
-  client_->WaitForResponseForMs(-1);
-  ASSERT_TRUE(client_->client()->connected());
-  EXPECT_EQ(kFooResponseBody, client_->SendCustomSynchronousRequest(request));
-
-  if (negotiated_version_ <= QUIC_VERSION_32) {
-    EXPECT_EQ(expected_num_hellos_latest_session,
-              client_->client()->session()->GetNumSentClientHellos());
-    EXPECT_EQ(2, client_->client()->GetNumSentClientHellos());
-  } else {
-    EXPECT_EQ(1, client_->client()->session()->GetNumSentClientHellos());
-    EXPECT_EQ(1, client_->client()->GetNumSentClientHellos());
-  }
-
-  client_->Disconnect();
-
-  // Restart the server so that the 0-RTT handshake will take 1 RTT.
-  StopServer();
-  server_writer_ = new PacketDroppingTestWriter();
-  StartServer();
-
-  client_->Connect();
-  ASSERT_TRUE(client_->client()->connected());
-  EXPECT_EQ(kFooResponseBody, client_->SendCustomSynchronousRequest(request));
-  // In the non-stateless case, the same session is used for both
-  // hellos, so the number of hellos sent on that session is 2.  In
-  // the stateless case, the first client session will be completely
-  // torn down after the reject.  The number of hellos sent on the
-  // latest session is 1.
-  EXPECT_EQ(expected_num_hellos_latest_session,
-            client_->client()->session()->GetNumSentClientHellos());
-  EXPECT_EQ(2, client_->client()->GetNumSentClientHellos());
-
-  VerifyCleanConnection(false);
-}
-
-TEST_P(EndToEndTest, SynchronousRequestZeroRTTFailure) {
-  // Have the server accept 0-RTT without waiting a startup period.
-  strike_register_no_startup_period_ = true;
-
-  // Send a request and then disconnect. This prepares the client to attempt
-  // a 0-RTT handshake for the next request.
-  ASSERT_TRUE(Initialize());
-
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  // In the non-stateless case, the same session is used for both
-  // hellos, so the number of hellos sent on that session is 2.  In
-  // the stateless case, the first client session will be completely
-  // torn down after the reject.  The number of hellos on that second
-  // latest session is 1.
-  const int expected_num_hellos_latest_session =
-      BothSidesSupportStatelessRejects() ? 1 : 2;
-  EXPECT_EQ(expected_num_hellos_latest_session,
-            client_->client()->session()->GetNumSentClientHellos());
-  EXPECT_EQ(2, client_->client()->GetNumSentClientHellos());
-
-  client_->Disconnect();
-
-  // The 0-RTT handshake should succeed.
-  client_->Connect();
-  client_->WaitForInitialResponse();
-  ASSERT_TRUE(client_->client()->connected());
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-
-  if (negotiated_version_ <= QUIC_VERSION_32) {
-    EXPECT_EQ(expected_num_hellos_latest_session,
-              client_->client()->session()->GetNumSentClientHellos());
-    EXPECT_EQ(2, client_->client()->GetNumSentClientHellos());
-  } else {
-    EXPECT_EQ(1, client_->client()->session()->GetNumSentClientHellos());
-    EXPECT_EQ(1, client_->client()->GetNumSentClientHellos());
-  }
-
-  client_->Disconnect();
-
-  // Restart the server so that the 0-RTT handshake will take 1 RTT.
-  StopServer();
-  server_writer_ = new PacketDroppingTestWriter();
-  StartServer();
-
-  client_->Connect();
-  ASSERT_TRUE(client_->client()->connected());
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  // In the non-stateless case, the same session is used for both
-  // hellos, so the number of hellos sent on that session is 2.  In
-  // the stateless case, the first client session will be completely
-  // torn down after the reject.  The number of hellos sent on the
-  // latest session is 1.
-  EXPECT_EQ(expected_num_hellos_latest_session,
-            client_->client()->session()->GetNumSentClientHellos());
-  EXPECT_EQ(2, client_->client()->GetNumSentClientHellos());
-
-  VerifyCleanConnection(false);
-}
-
-TEST_P(EndToEndTest, LargePostSynchronousRequest) {
-  // Have the server accept 0-RTT without waiting a startup period.
-  strike_register_no_startup_period_ = true;
-
-  // Send a request and then disconnect. This prepares the client to attempt
-  // a 0-RTT handshake for the next request.
-  ASSERT_TRUE(Initialize());
-
-  string body;
-  GenerateBody(&body, 20480);
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddBody(body, true);
-
-  EXPECT_EQ(kFooResponseBody, client_->SendCustomSynchronousRequest(request));
-  // In the non-stateless case, the same session is used for both
-  // hellos, so the number of hellos sent on that session is 2.  In
-  // the stateless case, the first client session will be completely
-  // torn down after the reject.  The number of hellos on the latest
-  // session is 1.
-  const int expected_num_hellos_latest_session =
-      BothSidesSupportStatelessRejects() ? 1 : 2;
-  EXPECT_EQ(expected_num_hellos_latest_session,
-            client_->client()->session()->GetNumSentClientHellos());
-  EXPECT_EQ(2, client_->client()->GetNumSentClientHellos());
-
-  client_->Disconnect();
-
-  // The 0-RTT handshake should succeed.
-  client_->Connect();
-  client_->WaitForInitialResponse();
-  ASSERT_TRUE(client_->client()->connected());
-  EXPECT_EQ(kFooResponseBody, client_->SendCustomSynchronousRequest(request));
-
-  if (negotiated_version_ <= QUIC_VERSION_32) {
-    EXPECT_EQ(expected_num_hellos_latest_session,
-              client_->client()->session()->GetNumSentClientHellos());
-    EXPECT_EQ(2, client_->client()->GetNumSentClientHellos());
-  } else {
-    EXPECT_EQ(1, client_->client()->session()->GetNumSentClientHellos());
-    EXPECT_EQ(1, client_->client()->GetNumSentClientHellos());
-  }
-
-  client_->Disconnect();
-
-  // Restart the server so that the 0-RTT handshake will take 1 RTT.
-  StopServer();
-  server_writer_ = new PacketDroppingTestWriter();
-  StartServer();
-
-  client_->Connect();
-  ASSERT_TRUE(client_->client()->connected());
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  // In the non-stateless case, the same session is used for both
-  // hellos, so the number of hellos sent on that session is 2.  In
-  // the stateless case, the first client session will be completely
-  // torn down after the reject.  The number of hellos sent on the
-  // latest session is 1.
-  EXPECT_EQ(expected_num_hellos_latest_session,
-            client_->client()->session()->GetNumSentClientHellos());
-  EXPECT_EQ(2, client_->client()->GetNumSentClientHellos());
-
-  VerifyCleanConnection(false);
-}
-
-TEST_P(EndToEndTest, StatelessRejectWithPacketLoss) {
-  // In this test, we intentionally drop the first packet from the
-  // server, which corresponds with the initial REJ/SREJ response from
-  // the server.
-  server_writer_->set_fake_drop_first_n_packets(1);
-  ASSERT_TRUE(Initialize());
-}
-
-TEST_P(EndToEndTest, SetInitialReceivedConnectionOptions) {
-  QuicTagVector initial_received_options;
-  initial_received_options.push_back(kTBBR);
-  initial_received_options.push_back(kIW10);
-  initial_received_options.push_back(kPRST);
-  EXPECT_TRUE(server_config_.SetInitialReceivedConnectionOptions(
-      initial_received_options));
-
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  server_thread_->WaitForCryptoHandshakeConfirmed();
-
-  EXPECT_FALSE(server_config_.SetInitialReceivedConnectionOptions(
-      initial_received_options));
-
-  // Verify that server's configuration is correct.
-  server_thread_->Pause();
-  EXPECT_TRUE(server_config_.HasReceivedConnectionOptions());
-  EXPECT_TRUE(
-      ContainsQuicTag(server_config_.ReceivedConnectionOptions(), kTBBR));
-  EXPECT_TRUE(
-      ContainsQuicTag(server_config_.ReceivedConnectionOptions(), kIW10));
-  EXPECT_TRUE(
-      ContainsQuicTag(server_config_.ReceivedConnectionOptions(), kPRST));
-}
-
-TEST_P(EndToEndTest, LargePostSmallBandwidthLargeBuffer) {
-  ASSERT_TRUE(Initialize());
-  SetPacketSendDelay(QuicTime::Delta::FromMicroseconds(1));
-  // 256KB per second with a 256KB buffer from server to client.  Wireless
-  // clients commonly have larger buffers, but our max CWND is 200.
-  server_writer_->set_max_bandwidth_and_buffer_size(
-      QuicBandwidth::FromBytesPerSecond(256 * 1024), 256 * 1024);
-
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  // 1 MB body.
-  string body;
-  GenerateBody(&body, 1024 * 1024);
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddBody(body, true);
-
-  EXPECT_EQ(kFooResponseBody, client_->SendCustomSynchronousRequest(request));
-  // This connection may drop packets, because the buffer is smaller than the
-  // max CWND.
-  VerifyCleanConnection(true);
-}
-
-TEST_P(EndToEndTest, DoNotSetResumeWriteAlarmIfConnectionFlowControlBlocked) {
-  // Regression test for b/14677858.
-  // Test that the resume write alarm is not set in QuicConnection::OnCanWrite
-  // if currently connection level flow control blocked. If set, this results in
-  // an infinite loop in the EpollServer, as the alarm fires and is immediately
-  // rescheduled.
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  // Ensure both stream and connection level are flow control blocked by setting
-  // the send window offset to 0.
-  const uint64_t flow_control_window =
-      server_config_.GetInitialStreamFlowControlWindowToSend();
-  QuicSpdyClientStream* stream = client_->GetOrCreateStream();
-  QuicSession* session = client_->client()->session();
-  QuicFlowControllerPeer::SetSendWindowOffset(stream->flow_controller(), 0);
-  QuicFlowControllerPeer::SetSendWindowOffset(session->flow_controller(), 0);
-  EXPECT_TRUE(stream->flow_controller()->IsBlocked());
-  EXPECT_TRUE(session->flow_controller()->IsBlocked());
-
-  // Make sure that the stream has data pending so that it will be marked as
-  // write blocked when it receives a stream level WINDOW_UPDATE.
-  stream->WriteOrBufferBody("hello", false, nullptr);
-
-  // The stream now attempts to write, fails because it is still connection
-  // level flow control blocked, and is added to the write blocked list.
-  QuicWindowUpdateFrame window_update(stream->id(), 2 * flow_control_window);
-  stream->OnWindowUpdateFrame(window_update);
-
-  // Prior to fixing b/14677858 this call would result in an infinite loop in
-  // Chromium. As a proxy for detecting this, we now check whether the
-  // resume_writes_alarm is set after OnCanWrite. It should not be, as the
-  // connection is still flow control blocked.
-  session->connection()->OnCanWrite();
-
-  QuicAlarm* resume_writes_alarm =
-      QuicConnectionPeer::GetResumeWritesAlarm(session->connection());
-  EXPECT_FALSE(resume_writes_alarm->IsSet());
-}
-
-TEST_P(EndToEndTest, InvalidStream) {
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  string body;
-  GenerateBody(&body, kMaxPacketSize);
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddBody(body, true);
-  // Force the client to write with a stream ID belonging to a nonexistent
-  // server-side stream.
-  QuicSessionPeer::SetNextOutgoingStreamId(client_->client()->session(), 2);
-
-  client_->SendCustomSynchronousRequest(request);
-  // EXPECT_EQ(QUIC_STREAM_CONNECTION_ERROR, client_->stream_error());
-  EXPECT_EQ(QUIC_STREAM_CONNECTION_ERROR, client_->stream_error());
-  EXPECT_EQ(QUIC_INVALID_STREAM_ID, client_->connection_error());
-}
-
-TEST_P(EndToEndTest, EarlyResponseWithQuicStreamNoError) {
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  string large_body;
-  GenerateBody(&large_body, 1024 * 1024);
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddBody(large_body, false);
-
-  // Insert an invalid content_length field in request to trigger an early
-  // response from server.
-  request.AddHeader("content-length", "-3");
-
-  request.set_skip_message_validation(true);
-  client_->SendCustomSynchronousRequest(request);
-  EXPECT_EQ("bad", client_->response_body());
-  EXPECT_EQ(500u, client_->response_headers()->parsed_response_code());
-  EXPECT_EQ(QUIC_STREAM_NO_ERROR, client_->stream_error());
-  EXPECT_EQ(QUIC_NO_ERROR, client_->connection_error());
-}
-
-// TODO(rch): this test seems to cause net_unittests timeouts :|
-TEST_P(EndToEndTest, DISABLED_MultipleTermination) {
-  ASSERT_TRUE(Initialize());
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddHeader("content-length", "3");
-  request.set_has_complete_message(false);
-
-  // Set the offset so we won't frame.  Otherwise when we pick up termination
-  // before HTTP framing is complete, we send an error and close the stream,
-  // and the second write is picked up as writing on a closed stream.
-  QuicSpdyClientStream* stream = client_->GetOrCreateStream();
-  ASSERT_TRUE(stream != nullptr);
-  ReliableQuicStreamPeer::SetStreamBytesWritten(3, stream);
-
-  client_->SendData("bar", true);
-  client_->WaitForWriteToFlush();
-
-  // By default the stream protects itself from writes after terminte is set.
-  // Override this to test the server handling buggy clients.
-  ReliableQuicStreamPeer::SetWriteSideClosed(false,
-                                             client_->GetOrCreateStream());
-
-  EXPECT_DFATAL(client_->SendData("eep", true), "Fin already buffered");
-}
-
-TEST_P(EndToEndTest, Timeout) {
-  client_config_.SetIdleConnectionStateLifetime(
-      QuicTime::Delta::FromMicroseconds(500),
-      QuicTime::Delta::FromMicroseconds(500));
-  // Note: we do NOT ASSERT_TRUE: we may time out during initial handshake:
-  // that's enough to validate timeout in this case.
-  Initialize();
-  while (client_->client()->connected()) {
-    client_->client()->WaitForEvents();
-  }
-}
-
-TEST_P(EndToEndTest, NegotiateMaxOpenStreams) {
-  // Negotiate 1 max open stream.
-  client_config_.SetMaxStreamsPerConnection(1, 1);
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  if (negotiated_version_ > QUIC_VERSION_34) {
-    // Newer versions use max incoming dynamic streams.
-    return;
-  }
-
-  // Make the client misbehave after negotiation.
-  const int kServerMaxStreams = kMaxStreamsMinimumIncrement + 1;
-  QuicSessionPeer::SetMaxOpenOutgoingStreams(client_->client()->session(),
-                                             kServerMaxStreams + 1);
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddHeader("content-length", "3");
-  request.set_has_complete_message(false);
-
-  // The server supports a small number of additional streams beyond the
-  // negotiated limit. Open enough streams to go beyond that limit.
-  for (int i = 0; i < kServerMaxStreams + 1; ++i) {
-    client_->SendMessage(request);
-  }
-  client_->WaitForResponse();
-
-  if (negotiated_version_ <= QUIC_VERSION_27) {
-    EXPECT_FALSE(client_->connected());
-    EXPECT_EQ(QUIC_STREAM_CONNECTION_ERROR, client_->stream_error());
-    EXPECT_EQ(QUIC_TOO_MANY_OPEN_STREAMS, client_->connection_error());
-  } else {
-    EXPECT_TRUE(client_->connected());
-    EXPECT_EQ(QUIC_REFUSED_STREAM, client_->stream_error());
-    EXPECT_EQ(QUIC_NO_ERROR, client_->connection_error());
-  }
-}
-
-TEST_P(EndToEndTest, MaxIncomingDynamicStreamsLimitRespected) {
-  // Set a limit on maximum number of incoming dynamic streams.
-  // Make sure the limit is respected.
-  const uint32_t kServerMaxIncomingDynamicStreams = 1;
-  server_config_.SetMaxIncomingDynamicStreamsToSend(
-      kServerMaxIncomingDynamicStreams);
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  if (negotiated_version_ <= QUIC_VERSION_34) {
-    // Earlier versions negotiated max open streams.
-    return;
-  }
-
-  // Make the client misbehave after negotiation.
-  const int kServerMaxStreams =
-      kMaxStreamsMinimumIncrement + kServerMaxIncomingDynamicStreams;
-  QuicSessionPeer::SetMaxOpenOutgoingStreams(client_->client()->session(),
-                                             kServerMaxStreams + 1);
-
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.AddHeader("content-length", "3");
-  request.set_has_complete_message(false);
-
-  // The server supports a small number of additional streams beyond the
-  // negotiated limit. Open enough streams to go beyond that limit.
-  for (int i = 0; i < kServerMaxStreams + 1; ++i) {
-    client_->SendMessage(request);
-  }
-  client_->WaitForResponse();
-
-  EXPECT_TRUE(client_->connected());
-  EXPECT_EQ(QUIC_REFUSED_STREAM, client_->stream_error());
-  EXPECT_EQ(QUIC_NO_ERROR, client_->connection_error());
-}
-
-TEST_P(EndToEndTest, SetIndependentMaxIncomingDynamicStreamsLimits) {
-  // Each endpoint can set max incoming dynamic streams independently.
-  const uint32_t kClientMaxIncomingDynamicStreams = 2;
-  const uint32_t kServerMaxIncomingDynamicStreams = 1;
-  client_config_.SetMaxIncomingDynamicStreamsToSend(
-      kClientMaxIncomingDynamicStreams);
-  server_config_.SetMaxIncomingDynamicStreamsToSend(
-      kServerMaxIncomingDynamicStreams);
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  if (negotiated_version_ <= QUIC_VERSION_34) {
-    // Earlier versions negotiated max open streams.
-    return;
-  }
-
-  // The client has received the server's limit and vice versa.
-  EXPECT_EQ(kServerMaxIncomingDynamicStreams,
-            client_->client()->session()->max_open_outgoing_streams());
-  server_thread_->Pause();
-  QuicDispatcher* dispatcher =
-      QuicServerPeer::GetDispatcher(server_thread_->server());
-  QuicSession* server_session = dispatcher->session_map().begin()->second;
-  EXPECT_EQ(kClientMaxIncomingDynamicStreams,
-            server_session->max_open_outgoing_streams());
-  server_thread_->Resume();
-}
-
-TEST_P(EndToEndTest, NegotiateCongestionControl) {
-  ValueRestore<bool> old_flag(&FLAGS_quic_allow_bbr, true);
-  // Disable this flag because if connection uses multipath sent packet manager,
-  // static_cast here does not work.
-  FLAGS_quic_enable_multipath = false;
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  CongestionControlType expected_congestion_control_type = kReno;
-  switch (GetParam().congestion_control_tag) {
-    case kRENO:
-      expected_congestion_control_type = kReno;
-      break;
-    case kTBBR:
-      expected_congestion_control_type = kBBR;
-      break;
-    case kQBIC:
-      expected_congestion_control_type = kCubic;
-      break;
-    default:
-      DLOG(FATAL) << "Unexpected congestion control tag";
-  }
-
-  EXPECT_EQ(expected_congestion_control_type,
-            QuicSentPacketManagerPeer::GetSendAlgorithm(
-                *static_cast<const QuicSentPacketManager*>(
-                    GetSentPacketManagerFromFirstServerSession()))
-                ->GetCongestionControlType());
-}
-
-TEST_P(EndToEndTest, LimitMaxOpenStreams) {
-  // Server limits the number of max streams to 2.
-  server_config_.SetMaxStreamsPerConnection(2, 2);
-  // Client tries to negotiate for 10.
-  client_config_.SetMaxStreamsPerConnection(10, 5);
-
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  if (negotiated_version_ > QUIC_VERSION_34) {
-    // No negotiated max streams beyond version 34.
-    return;
-  }
-  QuicConfig* client_negotiated_config = client_->client()->session()->config();
-  EXPECT_EQ(2u, client_negotiated_config->MaxStreamsPerConnection());
-}
-
-TEST_P(EndToEndTest, ClientSuggestsRTT) {
-  // Client suggests initial RTT, verify it is used.
-  const uint32_t kInitialRTT = 20000;
-  client_config_.SetInitialRoundTripTimeUsToSend(kInitialRTT);
-
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  server_thread_->WaitForCryptoHandshakeConfirmed();
-
-  // Pause the server so we can access the server's internals without races.
-  server_thread_->Pause();
-  QuicDispatcher* dispatcher =
-      QuicServerPeer::GetDispatcher(server_thread_->server());
-  ASSERT_EQ(1u, dispatcher->session_map().size());
-  const QuicSentPacketManagerInterface& client_sent_packet_manager =
-      client_->client()->session()->connection()->sent_packet_manager();
-  const QuicSentPacketManagerInterface* server_sent_packet_manager =
-      GetSentPacketManagerFromFirstServerSession();
-
-  EXPECT_EQ(kInitialRTT,
-            client_sent_packet_manager.GetRttStats()->initial_rtt_us());
-  EXPECT_EQ(kInitialRTT,
-            server_sent_packet_manager->GetRttStats()->initial_rtt_us());
-  server_thread_->Resume();
-}
-
-TEST_P(EndToEndTest, MaxInitialRTT) {
-  // Client tries to suggest twice the server's max initial rtt and the server
-  // uses the max.
-  client_config_.SetInitialRoundTripTimeUsToSend(2 *
-                                                 kMaxInitialRoundTripTimeUs);
-
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  server_thread_->WaitForCryptoHandshakeConfirmed();
-
-  // Pause the server so we can access the server's internals without races.
-  server_thread_->Pause();
-  QuicDispatcher* dispatcher =
-      QuicServerPeer::GetDispatcher(server_thread_->server());
-  ASSERT_EQ(1u, dispatcher->session_map().size());
-  QuicSession* session = dispatcher->session_map().begin()->second;
-  const QuicSentPacketManagerInterface& client_sent_packet_manager =
-      client_->client()->session()->connection()->sent_packet_manager();
-
-  // Now that acks have been exchanged, the RTT estimate has decreased on the
-  // server and is not infinite on the client.
-  EXPECT_FALSE(
-      client_sent_packet_manager.GetRttStats()->smoothed_rtt().IsInfinite());
-  const RttStats& server_rtt_stats =
-      *session->connection()->sent_packet_manager().GetRttStats();
-  EXPECT_EQ(static_cast<int64_t>(kMaxInitialRoundTripTimeUs),
-            server_rtt_stats.initial_rtt_us());
-  EXPECT_GE(static_cast<int64_t>(kMaxInitialRoundTripTimeUs),
-            server_rtt_stats.smoothed_rtt().ToMicroseconds());
-  server_thread_->Resume();
-}
-
-TEST_P(EndToEndTest, MinInitialRTT) {
-  // Client tries to suggest 0 and the server uses the default.
-  client_config_.SetInitialRoundTripTimeUsToSend(0);
-
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  server_thread_->WaitForCryptoHandshakeConfirmed();
-
-  // Pause the server so we can access the server's internals without races.
-  server_thread_->Pause();
-  QuicDispatcher* dispatcher =
-      QuicServerPeer::GetDispatcher(server_thread_->server());
-  ASSERT_EQ(1u, dispatcher->session_map().size());
-  QuicSession* session = dispatcher->session_map().begin()->second;
-  const QuicSentPacketManagerInterface& client_sent_packet_manager =
-      client_->client()->session()->connection()->sent_packet_manager();
-  const QuicSentPacketManagerInterface& server_sent_packet_manager =
-      session->connection()->sent_packet_manager();
-
-  // Now that acks have been exchanged, the RTT estimate has decreased on the
-  // server and is not infinite on the client.
-  EXPECT_FALSE(
-      client_sent_packet_manager.GetRttStats()->smoothed_rtt().IsInfinite());
-  // Expect the default rtt of 100ms.
-  EXPECT_EQ(static_cast<int64_t>(100 * kNumMicrosPerMilli),
-            server_sent_packet_manager.GetRttStats()->initial_rtt_us());
-  // Ensure the bandwidth is valid.
-  client_sent_packet_manager.BandwidthEstimate();
-  server_sent_packet_manager.BandwidthEstimate();
-  server_thread_->Resume();
-}
-
-TEST_P(EndToEndTest, 0ByteConnectionId) {
-  client_config_.SetBytesForConnectionIdToSend(0);
-  ASSERT_TRUE(Initialize());
-
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-
-  QuicPacketHeader* header = QuicConnectionPeer::GetLastHeader(
-      client_->client()->session()->connection());
-  EXPECT_EQ(PACKET_0BYTE_CONNECTION_ID,
-            header->public_header.connection_id_length);
-}
-
-TEST_P(EndToEndTest, 8ByteConnectionId) {
-  client_config_.SetBytesForConnectionIdToSend(8);
-  ASSERT_TRUE(Initialize());
-
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-  QuicPacketHeader* header = QuicConnectionPeer::GetLastHeader(
-      client_->client()->session()->connection());
-  EXPECT_EQ(PACKET_8BYTE_CONNECTION_ID,
-            header->public_header.connection_id_length);
-}
-
-TEST_P(EndToEndTest, 15ByteConnectionId) {
-  client_config_.SetBytesForConnectionIdToSend(15);
-  ASSERT_TRUE(Initialize());
-
-  // Our server is permissive and allows for out of bounds values.
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-  QuicPacketHeader* header = QuicConnectionPeer::GetLastHeader(
-      client_->client()->session()->connection());
-  EXPECT_EQ(PACKET_8BYTE_CONNECTION_ID,
-            header->public_header.connection_id_length);
-}
-
-TEST_P(EndToEndTest, ResetConnection) {
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-  client_->ResetConnection();
-  EXPECT_EQ(kBarResponseBody, client_->SendSynchronousRequest("/bar"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-}
-
-TEST_P(EndToEndTest, MaxStreamsUberTest) {
-  if (!BothSidesSupportStatelessRejects()) {
-    // Connect with lower fake packet loss than we'd like to test.  Until
-    // b/10126687 is fixed, losing handshake packets is pretty brutal.
-    // TODO(jokulik): Until we support redundant SREJ packets, don't
-    // drop handshake packets for stateless rejects.
-    SetPacketLossPercentage(1);
-  }
-  ASSERT_TRUE(Initialize());
-  string large_body;
-  GenerateBody(&large_body, 10240);
-  int max_streams = 100;
-
-  AddToCache("/large_response", 200, large_body);
-
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  SetPacketLossPercentage(10);
-
-  for (int i = 0; i < max_streams; ++i) {
-    EXPECT_LT(0, client_->SendRequest("/large_response"));
-  }
-
-  // WaitForEvents waits 50ms and returns true if there are outstanding
-  // requests.
-  while (client_->client()->WaitForEvents() == true) {
-  }
-}
-
-TEST_P(EndToEndTest, StreamCancelErrorTest) {
-  ASSERT_TRUE(Initialize());
-  string small_body;
-  GenerateBody(&small_body, 256);
-
-  AddToCache("/small_response", 200, small_body);
-
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  QuicSession* session = client_->client()->session();
-  // Lose the request.
-  SetPacketLossPercentage(100);
-  EXPECT_LT(0, client_->SendRequest("/small_response"));
-  client_->client()->WaitForEvents();
-  // Transmit the cancel, and ensure the connection is torn down properly.
-  SetPacketLossPercentage(0);
-  QuicStreamId stream_id = kClientDataStreamId1;
-  session->SendRstStream(stream_id, QUIC_STREAM_CANCELLED, 0);
-
-  // WaitForEvents waits 50ms and returns true if there are outstanding
-  // requests.
-  while (client_->client()->WaitForEvents() == true) {
-  }
-  // It should be completely fine to RST a stream before any data has been
-  // received for that stream.
-  EXPECT_EQ(QUIC_NO_ERROR, client_->connection_error());
-}
-
-class WrongAddressWriter : public QuicPacketWriterWrapper {
- public:
-  WrongAddressWriter() {
-    self_address_ = IPEndPoint(IPAddress(127, 0, 0, 2), 0);
-  }
-
-  WriteResult WritePacket(const char* buffer,
-                          size_t buf_len,
-                          const IPAddress& /*real_self_address*/,
-                          const IPEndPoint& peer_address,
-                          PerPacketOptions* options) override {
-    // Use wrong address!
-    return QuicPacketWriterWrapper::WritePacket(
-        buffer, buf_len, self_address_.address(), peer_address, options);
-  }
-
-  bool IsWriteBlockedDataBuffered() const override { return false; }
-
-  IPEndPoint self_address_;
-};
-
-TEST_P(EndToEndTest, ConnectionMigrationClientIPChanged) {
-  ASSERT_TRUE(Initialize());
-
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-
-  // Store the client IP address which was used to send the first request.
-  IPAddress old_host = client_->client()->GetLatestClientAddress().address();
-
-  // Migrate socket to the new IP address.
-  IPAddress new_host(127, 0, 0, 2);
-  EXPECT_NE(old_host, new_host);
-  ASSERT_TRUE(client_->client()->MigrateSocket(new_host));
-
-  // Send a request using the new socket.
-  EXPECT_EQ(kBarResponseBody, client_->SendSynchronousRequest("/bar"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-}
-
-TEST_P(EndToEndTest, ConnectionMigrationClientPortChanged) {
-  // Tests that the client's port can change during an established QUIC
-  // connection, and that doing so does not result in the connection being
-  // closed by the server.
-  ASSERT_TRUE(Initialize());
-
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-
-  // Store the client address which was used to send the first request.
-  IPEndPoint old_address = client_->client()->GetLatestClientAddress();
-  int old_fd = client_->client()->GetLatestFD();
-
-  // Create a new socket before closing the old one, which will result in a new
-  // ephemeral port.
-  QuicClientPeer::CreateUDPSocketAndBind(client_->client());
-
-  // Stop listening and close the old FD.
-  QuicClientPeer::CleanUpUDPSocket(client_->client(), old_fd);
-
-  // The packet writer needs to be updated to use the new FD.
-  client_->client()->CreateQuicPacketWriter();
-
-  // Change the internal state of the client and connection to use the new port,
-  // this is done because in a real NAT rebinding the client wouldn't see any
-  // port change, and so expects no change to incoming port.
-  // This is kind of ugly, but needed as we are simply swapping out the client
-  // FD rather than any more complex NAT rebinding simulation.
-  int new_port = client_->client()->GetLatestClientAddress().port();
-  QuicClientPeer::SetClientPort(client_->client(), new_port);
-  QuicConnectionPeer::SetSelfAddress(
-      client_->client()->session()->connection(),
-      IPEndPoint(
-          client_->client()->session()->connection()->self_address().address(),
-          new_port));
-
-  // Register the new FD for epoll events.
-  int new_fd = client_->client()->GetLatestFD();
-  EpollServer* eps = client_->epoll_server();
-  eps->RegisterFD(new_fd, client_->client(), EPOLLIN | EPOLLOUT | EPOLLET);
-
-  // Send a second request, using the new FD.
-  EXPECT_EQ(kBarResponseBody, client_->SendSynchronousRequest("/bar"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-
-  // Verify that the client's ephemeral port is different.
-  IPEndPoint new_address = client_->client()->GetLatestClientAddress();
-  EXPECT_EQ(old_address.address(), new_address.address());
-  EXPECT_NE(old_address.port(), new_address.port());
-}
-
-TEST_P(EndToEndTest, DifferentFlowControlWindows) {
-  // Client and server can set different initial flow control receive windows.
-  // These are sent in CHLO/SHLO. Tests that these values are exchanged properly
-  // in the crypto handshake.
-  const uint32_t kClientStreamIFCW = 123456;
-  const uint32_t kClientSessionIFCW = 234567;
-  set_client_initial_stream_flow_control_receive_window(kClientStreamIFCW);
-  set_client_initial_session_flow_control_receive_window(kClientSessionIFCW);
-
-  uint32_t kServerStreamIFCW =
-      GetParam().auto_tune_flow_control_window ? 32 * 1024 : 654321;
-  uint32_t kServerSessionIFCW =
-      GetParam().auto_tune_flow_control_window ? 48 * 1024 : 765432;
-  set_server_initial_stream_flow_control_receive_window(kServerStreamIFCW);
-  set_server_initial_session_flow_control_receive_window(kServerSessionIFCW);
-
-  ASSERT_TRUE(Initialize());
-
-  // Values are exchanged during crypto handshake, so wait for that to finish.
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  server_thread_->WaitForCryptoHandshakeConfirmed();
-
-  // Open a data stream to make sure the stream level flow control is updated.
-  QuicSpdyClientStream* stream = client_->GetOrCreateStream();
-  stream->WriteOrBufferBody("hello", false, nullptr);
-
-  // Client should have the right values for server's receive window.
-  EXPECT_EQ(kServerStreamIFCW,
-            client_->client()
-                ->session()
-                ->config()
-                ->ReceivedInitialStreamFlowControlWindowBytes());
-  EXPECT_EQ(kServerSessionIFCW,
-            client_->client()
-                ->session()
-                ->config()
-                ->ReceivedInitialSessionFlowControlWindowBytes());
-  EXPECT_EQ(kServerStreamIFCW, QuicFlowControllerPeer::SendWindowOffset(
-                                   stream->flow_controller()));
-  EXPECT_EQ(kServerSessionIFCW,
-            QuicFlowControllerPeer::SendWindowOffset(
-                client_->client()->session()->flow_controller()));
-
-  // Server should have the right values for client's receive window.
-  server_thread_->Pause();
-  QuicDispatcher* dispatcher =
-      QuicServerPeer::GetDispatcher(server_thread_->server());
-  QuicSession* session = dispatcher->session_map().begin()->second;
-  EXPECT_EQ(kClientStreamIFCW,
-            session->config()->ReceivedInitialStreamFlowControlWindowBytes());
-  EXPECT_EQ(kClientSessionIFCW,
-            session->config()->ReceivedInitialSessionFlowControlWindowBytes());
-  EXPECT_EQ(kClientSessionIFCW, QuicFlowControllerPeer::SendWindowOffset(
-                                    session->flow_controller()));
-  server_thread_->Resume();
-}
-
-TEST_P(EndToEndTest, HeadersAndCryptoStreamsNoConnectionFlowControl) {
-  // The special headers and crypto streams should be subject to per-stream flow
-  // control limits, but should not be subject to connection level flow control
-  const uint32_t kStreamIFCW =
-      GetParam().auto_tune_flow_control_window ? 32 * 1024 : 123456;
-  const uint32_t kSessionIFCW =
-      GetParam().auto_tune_flow_control_window ? 48 * 1024 : 234567;
-  set_client_initial_stream_flow_control_receive_window(kStreamIFCW);
-  set_client_initial_session_flow_control_receive_window(kSessionIFCW);
-  set_server_initial_stream_flow_control_receive_window(kStreamIFCW);
-  set_server_initial_session_flow_control_receive_window(kSessionIFCW);
-
-  ASSERT_TRUE(Initialize());
-
-  // Wait for crypto handshake to finish. This should have contributed to the
-  // crypto stream flow control window, but not affected the session flow
-  // control window.
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  server_thread_->WaitForCryptoHandshakeConfirmed();
-
-  QuicCryptoStream* crypto_stream =
-      QuicSessionPeer::GetCryptoStream(client_->client()->session());
-  EXPECT_LT(
-      QuicFlowControllerPeer::SendWindowSize(crypto_stream->flow_controller()),
-      kStreamIFCW);
-  EXPECT_EQ(kSessionIFCW, QuicFlowControllerPeer::SendWindowSize(
-                              client_->client()->session()->flow_controller()));
-
-  // Send a request with no body, and verify that the connection level window
-  // has not been affected.
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-
-  QuicHeadersStream* headers_stream =
-      QuicSpdySessionPeer::GetHeadersStream(client_->client()->session());
-  EXPECT_LT(
-      QuicFlowControllerPeer::SendWindowSize(headers_stream->flow_controller()),
-      kStreamIFCW);
-  EXPECT_EQ(kSessionIFCW, QuicFlowControllerPeer::SendWindowSize(
-                              client_->client()->session()->flow_controller()));
-
-  // Server should be in a similar state: connection flow control window should
-  // not have any bytes marked as received.
-  server_thread_->Pause();
-  QuicDispatcher* dispatcher =
-      QuicServerPeer::GetDispatcher(server_thread_->server());
-  QuicSession* session = dispatcher->session_map().begin()->second;
-  QuicFlowController* server_connection_flow_controller =
-      session->flow_controller();
-  EXPECT_EQ(kSessionIFCW, QuicFlowControllerPeer::ReceiveWindowSize(
-                              server_connection_flow_controller));
-  server_thread_->Resume();
-}
-
-TEST_P(EndToEndTest, FlowControlsSynced) {
-  set_smaller_flow_control_receive_window();
-
-  ASSERT_TRUE(Initialize());
-
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  server_thread_->WaitForCryptoHandshakeConfirmed();
-
-  server_thread_->Pause();
-  QuicSpdySession* const client_session = client_->client()->session();
-  QuicDispatcher* dispatcher =
-      QuicServerPeer::GetDispatcher(server_thread_->server());
-  QuicSpdySession* server_session = dispatcher->session_map().begin()->second;
-
-  ExpectFlowControlsSynced(client_session->flow_controller(),
-                           server_session->flow_controller());
-  ExpectFlowControlsSynced(
-      QuicSessionPeer::GetCryptoStream(client_session)->flow_controller(),
-      QuicSessionPeer::GetCryptoStream(server_session)->flow_controller());
-  ExpectFlowControlsSynced(
-      QuicSpdySessionPeer::GetHeadersStream(client_session)->flow_controller(),
-      QuicSpdySessionPeer::GetHeadersStream(server_session)->flow_controller());
-
-  EXPECT_EQ(static_cast<float>(QuicFlowControllerPeer::ReceiveWindowSize(
-                client_session->flow_controller())) /
-                QuicFlowControllerPeer::ReceiveWindowSize(
-                    QuicSpdySessionPeer::GetHeadersStream(client_session)
-                        ->flow_controller()),
-            kSessionToStreamRatio);
-
-  server_thread_->Resume();
-}
-
-TEST_P(EndToEndTest, RequestWithNoBodyWillNeverSendStreamFrameWithFIN) {
-  // A stream created on receipt of a simple request with no body will never get
-  // a stream frame with a FIN. Verify that we don't keep track of the stream in
-  // the locally closed streams map: it will never be removed if so.
-  ASSERT_TRUE(Initialize());
-
-  // Send a simple headers only request, and receive response.
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-
-  // Now verify that the server is not waiting for a final FIN or RST.
-  server_thread_->Pause();
-  QuicDispatcher* dispatcher =
-      QuicServerPeer::GetDispatcher(server_thread_->server());
-  QuicSession* session = dispatcher->session_map().begin()->second;
-  EXPECT_EQ(
-      0u,
-      QuicSessionPeer::GetLocallyClosedStreamsHighestOffset(session).size());
-  server_thread_->Resume();
-}
-
-// A TestAckListener verifies that its OnAckNotification method has been
-// called exactly once on destruction.
-class TestAckListener : public QuicAckListenerInterface {
- public:
-  explicit TestAckListener(int num_packets) : num_notifications_(num_packets) {}
-
-  void OnPacketAcked(int /*acked_bytes*/,
-                     QuicTime::Delta /*delta_largest_observed*/) override {
-    ASSERT_LT(0, num_notifications_);
-    num_notifications_--;
-  }
-
-  void OnPacketRetransmitted(int /*retransmitted_bytes*/) override {}
-
-  bool has_been_notified() const { return num_notifications_ == 0; }
-
- protected:
-  // Object is ref counted.
-  ~TestAckListener() override { EXPECT_EQ(0, num_notifications_); }
-
- private:
-  int num_notifications_;
-};
-
-class TestResponseListener : public QuicClient::ResponseListener {
- public:
-  void OnCompleteResponse(QuicStreamId id,
-                          const BalsaHeaders& response_headers,
-                          const string& response_body) override {
-    string debug_string;
-    response_headers.DumpHeadersToString(&debug_string);
-    DVLOG(1) << "response for stream " << id << " " << debug_string << "\n"
-             << response_body;
-  }
-};
-
-TEST_P(EndToEndTest, AckNotifierWithPacketLossAndBlockedSocket) {
-  // Verify that even in the presence of packet loss and occasionally blocked
-  // socket,  an AckNotifierDelegate will get informed that the data it is
-  // interested in has been ACKed. This tests end-to-end ACK notification, and
-  // demonstrates that retransmissions do not break this functionality.
-  if (!BothSidesSupportStatelessRejects()) {
-    // TODO(jokulik): Until we support redundant SREJ packets, don't
-    // drop handshake packets for stateless rejects.
-    SetPacketLossPercentage(5);
-  }
-  ASSERT_TRUE(Initialize());
-
-  // Wait for the server SHLO before upping the packet loss.
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  SetPacketLossPercentage(30);
-  client_writer_->set_fake_blocked_socket_percentage(10);
-
-  // Create a POST request and send the headers only.
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  request.set_has_complete_message(false);
-  client_->SendMessage(request);
-
-  // The TestAckListener will cause a failure if not notified.
-  scoped_refptr<TestAckListener> delegate(new TestAckListener(2));
-
-  // Test the AckNotifier's ability to track multiple packets by making the
-  // request body exceed the size of a single packet.
-  string request_string =
-      "a request body bigger than one packet" + string(kMaxPacketSize, '.');
-
-  // Send the request, and register the delegate for ACKs.
-  client_->SendData(request_string, true, delegate.get());
-  client_->WaitForResponse();
-  EXPECT_EQ(kFooResponseBody, client_->response_body());
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-
-  // Send another request to flush out any pending ACKs on the server.
-  client_->SendSynchronousRequest("/bar");
-
-  // Pause the server to avoid races.
-  server_thread_->Pause();
-  // Make sure the delegate does get the notification it expects.
-  while (!delegate->has_been_notified()) {
-    // Waits for up to 50 ms.
-    client_->client()->WaitForEvents();
-  }
-  server_thread_->Resume();
-}
-
-// Send a public reset from the server.
-TEST_P(EndToEndTest, ServerSendPublicReset) {
-  ASSERT_TRUE(Initialize());
-
-  // Send the public reset.
-  QuicConnectionId connection_id =
-      client_->client()->session()->connection()->connection_id();
-  QuicPublicResetPacket header;
-  header.public_header.connection_id = connection_id;
-  header.public_header.reset_flag = true;
-  header.public_header.version_flag = false;
-  header.rejected_packet_number = 10101;
-  QuicFramer framer(server_supported_versions_, QuicTime::Zero(),
-                    Perspective::IS_SERVER);
-  std::unique_ptr<QuicEncryptedPacket> packet(
-      framer.BuildPublicResetPacket(header));
-  // We must pause the server's thread in order to call WritePacket without
-  // race conditions.
-  server_thread_->Pause();
-  server_writer_->WritePacket(
-      packet->data(), packet->length(), server_address_.address(),
-      client_->client()->GetLatestClientAddress(), nullptr);
-  server_thread_->Resume();
-
-  // The request should fail.
-  EXPECT_EQ("", client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(0u, client_->response_headers()->parsed_response_code());
-  EXPECT_EQ(QUIC_PUBLIC_RESET, client_->connection_error());
-}
-
-// Send a public reset from the server for a different connection ID.
-// It should be ignored.
-TEST_P(EndToEndTest, ServerSendPublicResetWithDifferentConnectionId) {
-  ASSERT_TRUE(Initialize());
-
-  // Send the public reset.
-  QuicConnectionId incorrect_connection_id =
-      client_->client()->session()->connection()->connection_id() + 1;
-  QuicPublicResetPacket header;
-  header.public_header.connection_id = incorrect_connection_id;
-  header.public_header.reset_flag = true;
-  header.public_header.version_flag = false;
-  header.rejected_packet_number = 10101;
-  QuicFramer framer(server_supported_versions_, QuicTime::Zero(),
-                    Perspective::IS_SERVER);
-  std::unique_ptr<QuicEncryptedPacket> packet(
-      framer.BuildPublicResetPacket(header));
-  testing::NiceMock<MockQuicConnectionDebugVisitor> visitor;
-  client_->client()->session()->connection()->set_debug_visitor(&visitor);
-  EXPECT_CALL(visitor, OnIncorrectConnectionId(incorrect_connection_id))
-      .Times(1);
-  // We must pause the server's thread in order to call WritePacket without
-  // race conditions.
-  server_thread_->Pause();
-  server_writer_->WritePacket(
-      packet->data(), packet->length(), server_address_.address(),
-      client_->client()->GetLatestClientAddress(), nullptr);
-  server_thread_->Resume();
-
-  // The connection should be unaffected.
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-
-  client_->client()->session()->connection()->set_debug_visitor(nullptr);
-}
-
-// Send a public reset from the client for a different connection ID.
-// It should be ignored.
-TEST_P(EndToEndTest, ClientSendPublicResetWithDifferentConnectionId) {
-  ASSERT_TRUE(Initialize());
-
-  // Send the public reset.
-  QuicConnectionId incorrect_connection_id =
-      client_->client()->session()->connection()->connection_id() + 1;
-  QuicPublicResetPacket header;
-  header.public_header.connection_id = incorrect_connection_id;
-  header.public_header.reset_flag = true;
-  header.public_header.version_flag = false;
-  header.rejected_packet_number = 10101;
-  QuicFramer framer(server_supported_versions_, QuicTime::Zero(),
-                    Perspective::IS_CLIENT);
-  std::unique_ptr<QuicEncryptedPacket> packet(
-      framer.BuildPublicResetPacket(header));
-  client_writer_->WritePacket(
-      packet->data(), packet->length(),
-      client_->client()->GetLatestClientAddress().address(), server_address_,
-      nullptr);
-
-  // The connection should be unaffected.
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-}
-
-// Send a version negotiation packet from the server for a different
-// connection ID.  It should be ignored.
-TEST_P(EndToEndTest, ServerSendVersionNegotiationWithDifferentConnectionId) {
-  ASSERT_TRUE(Initialize());
-
-  // Send the version negotiation packet.
-  QuicConnectionId incorrect_connection_id =
-      client_->client()->session()->connection()->connection_id() + 1;
-  std::unique_ptr<QuicEncryptedPacket> packet(
-      QuicFramer::BuildVersionNegotiationPacket(incorrect_connection_id,
-                                                server_supported_versions_));
-  testing::NiceMock<MockQuicConnectionDebugVisitor> visitor;
-  client_->client()->session()->connection()->set_debug_visitor(&visitor);
-  EXPECT_CALL(visitor, OnIncorrectConnectionId(incorrect_connection_id))
-      .Times(1);
-  // We must pause the server's thread in order to call WritePacket without
-  // race conditions.
-  server_thread_->Pause();
-  server_writer_->WritePacket(
-      packet->data(), packet->length(), server_address_.address(),
-      client_->client()->GetLatestClientAddress(), nullptr);
-  server_thread_->Resume();
-
-  // The connection should be unaffected.
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-
-  client_->client()->session()->connection()->set_debug_visitor(nullptr);
-}
-
-// A bad header shouldn't tear down the connection, because the receiver can't
-// tell the connection ID.
-TEST_P(EndToEndTest, BadPacketHeaderTruncated) {
-  ASSERT_TRUE(Initialize());
-
-  // Start the connection.
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-
-  // Packet with invalid public flags.
-  char packet[] = {// public flags (8 byte connection_id)
-                   0x3C,
-                   // truncated connection ID
-                   0x11};
-  client_writer_->WritePacket(
-      &packet[0], sizeof(packet),
-      client_->client()->GetLatestClientAddress().address(), server_address_,
-      nullptr);
-  // Give the server time to process the packet.
-  base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(100));
-  // Pause the server so we can access the server's internals without races.
-  server_thread_->Pause();
-  QuicDispatcher* dispatcher =
-      QuicServerPeer::GetDispatcher(server_thread_->server());
-  EXPECT_EQ(QUIC_INVALID_PACKET_HEADER,
-            QuicDispatcherPeer::GetAndClearLastError(dispatcher));
-  server_thread_->Resume();
-
-  // The connection should not be terminated.
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-}
-
-// A bad header shouldn't tear down the connection, because the receiver can't
-// tell the connection ID.
-TEST_P(EndToEndTest, BadPacketHeaderFlags) {
-  ASSERT_TRUE(Initialize());
-
-  // Start the connection.
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-
-  // Packet with invalid public flags.
-  char packet[] = {
-      // invalid public flags
-      0xFF,
-      // connection_id
-      0x10, 0x32, 0x54, 0x76, 0x98, 0xBA, 0xDC, 0xFE,
-      // packet sequence number
-      0xBC, 0x9A, 0x78, 0x56, 0x34, 0x12,
-      // private flags
-      0x00,
-  };
-  client_writer_->WritePacket(
-      &packet[0], sizeof(packet),
-      client_->client()->GetLatestClientAddress().address(), server_address_,
-      nullptr);
-  // Give the server time to process the packet.
-  base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(100));
-  // Pause the server so we can access the server's internals without races.
-  server_thread_->Pause();
-  QuicDispatcher* dispatcher =
-      QuicServerPeer::GetDispatcher(server_thread_->server());
-  EXPECT_EQ(QUIC_INVALID_PACKET_HEADER,
-            QuicDispatcherPeer::GetAndClearLastError(dispatcher));
-  server_thread_->Resume();
-
-  // The connection should not be terminated.
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-}
-
-// Send a packet from the client with bad encrypted data.  The server should not
-// tear down the connection.
-TEST_P(EndToEndTest, BadEncryptedData) {
-  ASSERT_TRUE(Initialize());
-
-  // Start the connection.
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-
-  std::unique_ptr<QuicEncryptedPacket> packet(ConstructEncryptedPacket(
-      client_->client()->session()->connection()->connection_id(), false, false,
-      false, kDefaultPathId, 1, "At least 20 characters.",
-      PACKET_8BYTE_CONNECTION_ID, PACKET_6BYTE_PACKET_NUMBER));
-  // Damage the encrypted data.
-  string damaged_packet(packet->data(), packet->length());
-  damaged_packet[30] ^= 0x01;
-  DVLOG(1) << "Sending bad packet.";
-  client_writer_->WritePacket(
-      damaged_packet.data(), damaged_packet.length(),
-      client_->client()->GetLatestClientAddress().address(), server_address_,
-      nullptr);
-  // Give the server time to process the packet.
-  base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(100));
-  // This error is sent to the connection's OnError (which ignores it), so the
-  // dispatcher doesn't see it.
-  // Pause the server so we can access the server's internals without races.
-  server_thread_->Pause();
-  QuicDispatcher* dispatcher =
-      QuicServerPeer::GetDispatcher(server_thread_->server());
-  EXPECT_EQ(QUIC_NO_ERROR,
-            QuicDispatcherPeer::GetAndClearLastError(dispatcher));
-  server_thread_->Resume();
-
-  // The connection should not be terminated.
-  EXPECT_EQ(kFooResponseBody, client_->SendSynchronousRequest("/foo"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-}
-
-// A test stream that gives |response_body_| as an error response body.
-class ServerStreamWithErrorResponseBody : public QuicSimpleServerStream {
- public:
-  ServerStreamWithErrorResponseBody(QuicStreamId id,
-                                    QuicSpdySession* session,
-                                    string response_body)
-      : QuicSimpleServerStream(id, session), response_body_(response_body) {}
-
-  ~ServerStreamWithErrorResponseBody() override {}
-
- protected:
-  void SendErrorResponse() override {
-    DVLOG(1) << "Sending error response for stream " << id();
-    SpdyHeaderBlock headers;
-    headers[":status"] = "500";
-    headers["content-length"] = base::UintToString(response_body_.size());
-    // This method must call CloseReadSide to cause the test case, StopReading
-    // is not sufficient.
-    ReliableQuicStreamPeer::CloseReadSide(this);
-    SendHeadersAndBody(std::move(headers), response_body_);
-  }
-
-  string response_body_;
-};
-
-class StreamWithErrorFactory : public QuicTestServer::StreamFactory {
- public:
-  explicit StreamWithErrorFactory(string response_body)
-      : response_body_(response_body) {}
-
-  ~StreamWithErrorFactory() override {}
-
-  QuicSimpleServerStream* CreateStream(QuicStreamId id,
-                                       QuicSpdySession* session) override {
-    return new ServerStreamWithErrorResponseBody(id, session, response_body_);
-  }
-
- private:
-  string response_body_;
-};
-
-// A test server stream that drops all received body.
-class ServerStreamThatDropsBody : public QuicSimpleServerStream {
- public:
-  ServerStreamThatDropsBody(QuicStreamId id, QuicSpdySession* session)
-      : QuicSimpleServerStream(id, session) {}
-
-  ~ServerStreamThatDropsBody() override {}
-
- protected:
-  void OnDataAvailable() override {
-    while (HasBytesToRead()) {
-      struct iovec iov;
-      if (GetReadableRegions(&iov, 1) == 0) {
-        // No more data to read.
-        break;
-      }
-      DVLOG(1) << "Processed " << iov.iov_len << " bytes for stream " << id();
-      MarkConsumed(iov.iov_len);
-    }
-
-    if (!sequencer()->IsClosed()) {
-      sequencer()->SetUnblocked();
-      return;
-    }
-
-    // If the sequencer is closed, then all the body, including the fin, has
-    // been consumed.
-    OnFinRead();
-
-    if (write_side_closed() || fin_buffered()) {
-      return;
-    }
-
-    SendResponse();
-  }
-};
-
-class ServerStreamThatDropsBodyFactory : public QuicTestServer::StreamFactory {
- public:
-  ServerStreamThatDropsBodyFactory() {}
-
-  ~ServerStreamThatDropsBodyFactory() override{};
-
-  QuicSimpleServerStream* CreateStream(QuicStreamId id,
-                                       QuicSpdySession* session) override {
-    return new ServerStreamThatDropsBody(id, session);
-  }
-};
-
-// A test server stream that sends response with body size greater than 4GB.
-class ServerStreamThatSendsHugeResponse : public QuicSimpleServerStream {
- public:
-  ServerStreamThatSendsHugeResponse(QuicStreamId id,
-                                    QuicSpdySession* session,
-                                    int64_t body_bytes)
-      : QuicSimpleServerStream(id, session), body_bytes_(body_bytes) {}
-
-  ~ServerStreamThatSendsHugeResponse() override {}
-
- protected:
-  void SendResponse() override {
-    QuicInMemoryCache::Response response;
-    string body;
-    test::GenerateBody(&body, body_bytes_);
-    response.set_body(body);
-    SendHeadersAndBodyAndTrailers(response.headers().Clone(), response.body(),
-                                  response.trailers().Clone());
-  }
-
- private:
-  // Use a explicit int64 rather than size_t to simulate a 64-bit server talking
-  // to a 32-bit client.
-  int64_t body_bytes_;
-};
-
-class ServerStreamThatSendsHugeResponseFactory
-    : public QuicTestServer::StreamFactory {
- public:
-  explicit ServerStreamThatSendsHugeResponseFactory(int64_t body_bytes)
-      : body_bytes_(body_bytes) {}
-
-  ~ServerStreamThatSendsHugeResponseFactory() override{};
-
-  QuicSimpleServerStream* CreateStream(QuicStreamId id,
-                                       QuicSpdySession* session) override {
-    return new ServerStreamThatSendsHugeResponse(id, session, body_bytes_);
-  }
-
-  int64_t body_bytes_;
-};
-
-// A test client stream that drops all received body.
-class ClientStreamThatDropsBody : public QuicSpdyClientStream {
- public:
-  ClientStreamThatDropsBody(QuicStreamId id, QuicClientSession* session)
-      : QuicSpdyClientStream(id, session) {}
-  ~ClientStreamThatDropsBody() override {}
-
-  void OnDataAvailable() override {
-    while (HasBytesToRead()) {
-      struct iovec iov;
-      if (GetReadableRegions(&iov, 1) == 0) {
-        break;
-      }
-      MarkConsumed(iov.iov_len);
-    }
-    if (sequencer()->IsClosed()) {
-      OnFinRead();
-    } else {
-      sequencer()->SetUnblocked();
-    }
-  }
-};
-
-class ClientSessionThatDropsBody : public QuicClientSession {
- public:
-  ClientSessionThatDropsBody(const QuicConfig& config,
-                             QuicConnection* connection,
-                             const QuicServerId& server_id,
-                             QuicCryptoClientConfig* crypto_config,
-                             QuicClientPushPromiseIndex* push_promise_index)
-      : QuicClientSession(config,
-                          connection,
-                          server_id,
-                          crypto_config,
-                          push_promise_index) {}
-
-  ~ClientSessionThatDropsBody() override {}
-
-  QuicSpdyClientStream* CreateClientStream() override {
-    return new ClientStreamThatDropsBody(GetNextOutgoingStreamId(), this);
-  }
-};
-
-class MockableQuicClientThatDropsBody : public MockableQuicClient {
- public:
-  MockableQuicClientThatDropsBody(IPEndPoint server_address,
-                                  const QuicServerId& server_id,
-                                  const QuicConfig& config,
-                                  const QuicVersionVector& supported_versions,
-                                  EpollServer* epoll_server)
-      : MockableQuicClient(server_address,
-                           server_id,
-                           config,
-                           supported_versions,
-                           epoll_server) {}
-  ~MockableQuicClientThatDropsBody() override {}
-
-  QuicClientSession* CreateQuicClientSession(
-      QuicConnection* connection) override {
-    auto* session =
-        new ClientSessionThatDropsBody(*config(), connection, server_id(),
-                                       crypto_config(), push_promise_index());
-    set_session(session);
-    return session;
-  }
-};
-
-class QuicTestClientThatDropsBody : public QuicTestClient {
- public:
-  QuicTestClientThatDropsBody(IPEndPoint server_address,
-                              const string& server_hostname,
-                              const QuicConfig& config,
-                              const QuicVersionVector& supported_versions)
-      : QuicTestClient(server_address,
-                       server_hostname,
-                       config,
-                       supported_versions) {
-    set_client(new MockableQuicClientThatDropsBody(
-        server_address, QuicServerId(server_hostname, server_address.port(),
-                                     PRIVACY_MODE_DISABLED),
-        config, supported_versions, epoll_server()));
-  }
-  ~QuicTestClientThatDropsBody() override {}
-};
-
-TEST_P(EndToEndTest, EarlyResponseFinRecording) {
-  set_smaller_flow_control_receive_window();
-
-  // Verify that an incoming FIN is recorded in a stream object even if the read
-  // side has been closed.  This prevents an entry from being made in
-  // locally_close_streams_highest_offset_ (which will never be deleted).
-  // To set up the test condition, the server must do the following in order:
-  // start sending the response and call CloseReadSide
-  // receive the FIN of the request
-  // send the FIN of the response
-
-  string response_body;
-  // The response body must be larger than the flow control window so the server
-  // must receive a window update from the client before it can finish sending
-  // it.
-  uint32_t response_body_size =
-      2 * client_config_.GetInitialStreamFlowControlWindowToSend();
-  GenerateBody(&response_body, response_body_size);
-
-  StreamWithErrorFactory stream_factory(response_body);
-  SetSpdyStreamFactory(&stream_factory);
-
-  ASSERT_TRUE(Initialize());
-
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  // A POST that gets an early error response, after the headers are received
-  // and before the body is received, due to invalid content-length.
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/garbage");
-  // The body must be large enough that the FIN will be in a different packet
-  // than the end of the headers, but short enough to not require a flow control
-  // update.  This allows headers processing to trigger the error response
-  // before the request FIN is processed but receive the request FIN before the
-  // response is sent completely.
-  const uint32_t kRequestBodySize = kMaxPacketSize + 10;
-  string request_body;
-  GenerateBody(&request_body, kRequestBodySize);
-  request.AddBody(request_body, false);
-  // Set an invalid content-length, so the request will receive an early 500
-  // response.  Must be done after AddBody, which also sets content-length.
-  request.AddHeader("content-length", "-1");
-  request.set_skip_message_validation(true);
-
-  // Send the request.
-  client_->SendMessage(request);
-  client_->WaitForResponse();
-  EXPECT_EQ(500u, client_->response_headers()->parsed_response_code());
-
-  // Pause the server so we can access the server's internals without races.
-  server_thread_->Pause();
-
-  QuicDispatcher* dispatcher =
-      QuicServerPeer::GetDispatcher(server_thread_->server());
-  QuicDispatcher::SessionMap const& map =
-      QuicDispatcherPeer::session_map(dispatcher);
-  QuicDispatcher::SessionMap::const_iterator it = map.begin();
-  EXPECT_TRUE(it != map.end());
-  QuicServerSessionBase* server_session = it->second;
-
-  // The stream is not waiting for the arrival of the peer's final offset.
-  EXPECT_EQ(
-      0u, QuicSessionPeer::GetLocallyClosedStreamsHighestOffset(server_session)
-              .size());
-
-  server_thread_->Resume();
-}
-
-TEST_P(EndToEndTest, LargePostEarlyResponse) {
-  const uint32_t kWindowSize = 65536;
-  set_client_initial_stream_flow_control_receive_window(kWindowSize);
-  set_client_initial_session_flow_control_receive_window(kWindowSize);
-  set_server_initial_stream_flow_control_receive_window(kWindowSize);
-  set_server_initial_session_flow_control_receive_window(kWindowSize);
-
-  ASSERT_TRUE(Initialize());
-
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  // POST to a URL that gets an early error response, after the headers are
-  // received and before the body is received.
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/garbage");
-  const uint32_t kBodySize = 2 * kWindowSize;
-  // Invalid content-length so the request will receive an early 500 response.
-  request.AddHeader("content-length", "-1");
-  request.set_skip_message_validation(true);
-  request.set_has_complete_message(false);
-
-  // Tell the client to not close the stream if it receives an early response.
-  client_->set_allow_bidirectional_data(true);
-  // Send the headers.
-  client_->SendMessage(request);
-  // Receive the response and let the server close writing.
-  client_->WaitForInitialResponse();
-  EXPECT_EQ(500u, client_->response_headers()->parsed_response_code());
-
-  if (negotiated_version_ > QUIC_VERSION_28) {
-    // Receive the reset stream from server on early response.
-    client_->WaitForResponseForMs(100);
-    ReliableQuicStream* stream =
-        client_->client()->session()->GetOrCreateStream(kClientDataStreamId1);
-    // The stream is reset by server's reset stream.
-    EXPECT_EQ(stream, nullptr);
-    return;
-  }
-
-  // Send a body larger than the stream flow control window.
-  string body;
-  GenerateBody(&body, kBodySize);
-  client_->SendData(body, true);
-
-  // Run the client to let any buffered data be sent.
-  // (This is OK despite already waiting for a response.)
-  client_->WaitForResponse();
-  // There should be no buffered data to write in the client's stream.
-  ReliableQuicStream* stream =
-      client_->client()->session()->GetOrCreateStream(kClientDataStreamId1);
-  EXPECT_FALSE(stream != nullptr && stream->HasBufferedData());
-}
-
-TEST_P(EndToEndTest, Trailers) {
-  // Test sending and receiving HTTP/2 Trailers (trailing HEADERS frames).
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  // Set reordering to ensure that Trailers arriving before body is ok.
-  SetPacketSendDelay(QuicTime::Delta::FromMilliseconds(2));
-  SetReorderPercentage(30);
-
-  // Add a response with headers, body, and trailers.
-  const string kBody = "body content";
-
-  SpdyHeaderBlock headers;
-  headers[":status"] = "200";
-  headers[":version"] = "HTTP/1.1";
-  headers["content-length"] = IntToString(kBody.size());
-
-  SpdyHeaderBlock trailers;
-  trailers["some-trailing-header"] = "trailing-header-value";
-
-  QuicInMemoryCache::GetInstance()->AddResponse(
-      "www.google.com", "/trailer_url", std::move(headers), kBody,
-      trailers.Clone());
-
-  EXPECT_EQ(kBody, client_->SendSynchronousRequest("/trailer_url"));
-  EXPECT_EQ(200u, client_->response_headers()->parsed_response_code());
-  EXPECT_EQ(trailers, client_->response_trailers());
-}
-
-class EndToEndTestServerPush : public EndToEndTest {
- protected:
-  const size_t kNumMaxStreams = 10;
-
-  EndToEndTestServerPush() : EndToEndTest() {
-    FLAGS_quic_supports_push_promise = true;
-    client_config_.SetMaxStreamsPerConnection(kNumMaxStreams, kNumMaxStreams);
-    client_config_.SetMaxIncomingDynamicStreamsToSend(kNumMaxStreams);
-    server_config_.SetMaxStreamsPerConnection(kNumMaxStreams, kNumMaxStreams);
-    server_config_.SetMaxIncomingDynamicStreamsToSend(kNumMaxStreams);
-    support_server_push_ = true;
-  }
-
-  // Add a request with its response and |num_resources| push resources into
-  // cache.
-  // If |resource_size| == 0, response body of push resources use default string
-  // concatenating with resource url. Otherwise, generate a string of
-  // |resource_size| as body.
-  void AddRequestAndResponseWithServerPush(string host,
-                                           string path,
-                                           string response_body,
-                                           string* push_urls,
-                                           const size_t num_resources,
-                                           const size_t resource_size) {
-    bool use_large_response = resource_size != 0;
-    string large_resource;
-    if (use_large_response) {
-      // Generate a response common body larger than flow control window for
-      // push response.
-      test::GenerateBody(&large_resource, resource_size);
-    }
-    std::list<QuicInMemoryCache::ServerPushInfo> push_resources;
-    for (size_t i = 0; i < num_resources; ++i) {
-      string url = push_urls[i];
-      GURL resource_url(url);
-      string body = use_large_response
-                        ? large_resource
-                        : "This is server push response body for " + url;
-      SpdyHeaderBlock response_headers;
-      response_headers[":version"] = "HTTP/1.1";
-      response_headers[":status"] = "200";
-      response_headers["content-length"] = IntToString(body.size());
-      push_resources.push_back(QuicInMemoryCache::ServerPushInfo(
-          resource_url, std::move(response_headers), kV3LowestPriority, body));
-    }
-
-    QuicInMemoryCache::GetInstance()->AddSimpleResponseWithServerPushResources(
-        host, path, 200, response_body, push_resources);
-  }
-};
-
-// Run all server push end to end tests with all supported versions.
-INSTANTIATE_TEST_CASE_P(EndToEndTestsServerPush,
-                        EndToEndTestServerPush,
-                        ::testing::ValuesIn(GetTestParams()));
-
-TEST_P(EndToEndTestServerPush, ServerPush) {
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  // Set reordering to ensure that body arriving before PUSH_PROMISE is ok.
-  SetPacketSendDelay(QuicTime::Delta::FromMilliseconds(2));
-  SetReorderPercentage(30);
-
-  // Add a response with headers, body, and push resources.
-  const string kBody = "body content";
-  size_t kNumResources = 4;
-  string push_urls[] = {
-      "https://google.com/font.woff", "https://google.com/script.js",
-      "https://fonts.google.com/font.woff", "https://google.com/logo-hires.jpg",
-  };
-  AddRequestAndResponseWithServerPush("example.com", "/push_example", kBody,
-                                      push_urls, kNumResources, 0);
-
-  client_->client()->set_response_listener(new TestResponseListener);
-
-  DVLOG(1) << "send request for /push_example";
-  EXPECT_EQ(kBody, client_->SendSynchronousRequest(
-                       "https://example.com/push_example"));
-  for (const string& url : push_urls) {
-    DVLOG(1) << "send request for pushed stream on url " << url;
-    string expected_body = "This is server push response body for " + url;
-    string response_body = client_->SendSynchronousRequest(url);
-    DVLOG(1) << "response body " << response_body;
-    EXPECT_EQ(expected_body, response_body);
-  }
-}
-
-TEST_P(EndToEndTestServerPush, ServerPushUnderLimit) {
-  // Tests that sending a request which has 4 push resources will trigger server
-  // to push those 4 resources and client can handle pushed resources and match
-  // them with requests later.
-  ASSERT_TRUE(Initialize());
-
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  // Set reordering to ensure that body arriving before PUSH_PROMISE is ok.
-  SetPacketSendDelay(QuicTime::Delta::FromMilliseconds(2));
-  SetReorderPercentage(30);
-
-  // Add a response with headers, body, and push resources.
-  const string kBody = "body content";
-  size_t const kNumResources = 4;
-  string push_urls[] = {
-      "https://example.com/font.woff", "https://example.com/script.js",
-      "https://fonts.example.com/font.woff",
-      "https://example.com/logo-hires.jpg",
-  };
-  AddRequestAndResponseWithServerPush("example.com", "/push_example", kBody,
-                                      push_urls, kNumResources, 0);
-  client_->client()->set_response_listener(new TestResponseListener);
-
-  // Send the first request: this will trigger the server to send all the push
-  // resources associated with this request, and these will be cached by the
-  // client.
-  EXPECT_EQ(kBody, client_->SendSynchronousRequest(
-                       "https://example.com/push_example"));
-
-  for (string url : push_urls) {
-    // Sending subsequent requesets will not actually send anything on the wire,
-    // as the responses are already in the client's cache.
-    DVLOG(1) << "send request for pushed stream on url " << url;
-    string expected_body = "This is server push response body for " + url;
-    string response_body = client_->SendSynchronousRequest(url);
-    DVLOG(1) << "response body " << response_body;
-    EXPECT_EQ(expected_body, response_body);
-  }
-  // Expect only original request has been sent and push responses have been
-  // received as normal response.
-  EXPECT_EQ(1u, client_->num_requests());
-  EXPECT_EQ(1u + kNumResources, client_->num_responses());
-}
-
-TEST_P(EndToEndTestServerPush, ServerPushOverLimitNonBlocking) {
-  // Tests that when streams are not blocked by flow control or congestion
-  // control, pushing even more resources than max number of open outgoing
-  // streams should still work because all response streams get closed
-  // immediately after pushing resources.
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  // Set reordering to ensure that body arriving before PUSH_PROMISE is ok.
-  SetPacketSendDelay(QuicTime::Delta::FromMilliseconds(2));
-  SetReorderPercentage(30);
-
-  // Add a response with headers, body, and push resources.
-  const string kBody = "body content";
-
-  // One more resource than max number of outgoing stream of this session.
-  const size_t kNumResources = 1 + kNumMaxStreams;  // 11.
-  string push_urls[11];
-  for (uint32_t i = 0; i < kNumResources; ++i) {
-    push_urls[i] = "https://example.com/push_resources" + base::UintToString(i);
-  }
-  AddRequestAndResponseWithServerPush("example.com", "/push_example", kBody,
-                                      push_urls, kNumResources, 0);
-  client_->client()->set_response_listener(new TestResponseListener);
-
-  // Send the first request: this will trigger the server to send all the push
-  // resources associated with this request, and these will be cached by the
-  // client.
-  EXPECT_EQ(kBody, client_->SendSynchronousRequest(
-                       "https://example.com/push_example"));
-
-  for (const string& url : push_urls) {
-    // Sending subsequent requesets will not actually send anything on the wire,
-    // as the responses are already in the client's cache.
-    EXPECT_EQ("This is server push response body for " + url,
-              client_->SendSynchronousRequest(url));
-  }
-
-  // Only 1 request should have been sent.
-  EXPECT_EQ(1u, client_->num_requests());
-  // The responses to the original request and all the promised resources
-  // should have been received.
-  EXPECT_EQ(12u, client_->num_responses());
-}
-
-TEST_P(EndToEndTestServerPush, ServerPushOverLimitWithBlocking) {
-  // Tests that when server tries to send more large resources(large enough to
-  // be blocked by flow control window or congestion control window) than max
-  // open outgoing streams , server can open upto max number of outgoing
-  // streams for them, and the rest will be queued up.
-
-  // Reset flow control windows.
-  size_t kFlowControlWnd = 20 * 1024;  // 20KB.
-  // Response body is larger than 1 flow controlblock window.
-  size_t kBodySize = kFlowControlWnd * 2;
-  set_client_initial_stream_flow_control_receive_window(kFlowControlWnd);
-  // Make sure conntection level flow control window is large enough not to
-  // block data being sent out though they will be blocked by stream level one.
-  set_client_initial_session_flow_control_receive_window(
-      kBodySize * kNumMaxStreams + 1024);
-
-  ASSERT_TRUE(Initialize());
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-
-  // Set reordering to ensure that body arriving before PUSH_PROMISE is ok.
-  SetPacketSendDelay(QuicTime::Delta::FromMilliseconds(2));
-  SetReorderPercentage(30);
-
-  // Add a response with headers, body, and push resources.
-  const string kBody = "body content";
-
-  const size_t kNumResources = kNumMaxStreams + 1;
-  string push_urls[11];
-  for (uint32_t i = 0; i < kNumResources; ++i) {
-    push_urls[i] = "http://example.com/push_resources" + base::UintToString(i);
-  }
-  AddRequestAndResponseWithServerPush("example.com", "/push_example", kBody,
-                                      push_urls, kNumResources, kBodySize);
-
-  client_->client()->set_response_listener(new TestResponseListener);
-
-  client_->SendRequest("https://example.com/push_example");
-
-  // Pause after the first response arrives.
-  while (!client_->response_complete()) {
-    // Because of priority, the first response arrived should be to original
-    // request.
-    client_->WaitForResponse();
-  }
-
-  // Check server session to see if it has max number of outgoing streams opened
-  // though more resources need to be pushed.
-  server_thread_->Pause();
-  QuicDispatcher* dispatcher =
-      QuicServerPeer::GetDispatcher(server_thread_->server());
-  ASSERT_EQ(1u, dispatcher->session_map().size());
-  QuicSession* session = dispatcher->session_map().begin()->second;
-  EXPECT_EQ(kNumMaxStreams, session->GetNumOpenOutgoingStreams());
-  server_thread_->Resume();
-
-  EXPECT_EQ(1u, client_->num_requests());
-  EXPECT_EQ(1u, client_->num_responses());
-  EXPECT_EQ(kBody, client_->response_body());
-
-  // "Send" request for a promised resources will not really send out it because
-  // its response is being pushed(but blocked). And the following ack and
-  // flow control behavior of SendSynchronousRequests()
-  // will unblock the stream to finish receiving response.
-  client_->SendSynchronousRequest(push_urls[0]);
-  EXPECT_EQ(1u, client_->num_requests());
-  EXPECT_EQ(2u, client_->num_responses());
-
-  // Do same thing for the rest 10 resources.
-  for (uint32_t i = 1; i < kNumResources; ++i) {
-    client_->SendSynchronousRequest(push_urls[i]);
-  }
-
-  // Because of server push, client gets all pushed resources without actually
-  // sending requests for them.
-  EXPECT_EQ(1u, client_->num_requests());
-  // Including response to original request, 12 responses in total were
-  // recieved.
-  EXPECT_EQ(12u, client_->num_responses());
-}
-
-TEST_P(EndToEndTestServerPush, DisabledWithoutConnectionOption) {
-  // Tests that server push won't be triggered when kSPSH is not set by client.
-  support_server_push_ = false;
-  ASSERT_TRUE(Initialize());
-
-  // Add a response with headers, body, and push resources.
-  const string kBody = "body content";
-  size_t const kNumResources = 4;
-  string push_urls[] = {
-      "https://example.com/font.woff", "https://example.com/script.js",
-      "https://fonts.example.com/font.woff",
-      "https://example.com/logo-hires.jpg",
-  };
-  AddRequestAndResponseWithServerPush("example.com", "/push_example", kBody,
-                                      push_urls, kNumResources, 0);
-  client_->client()->set_response_listener(new TestResponseListener);
-  EXPECT_EQ(kBody, client_->SendSynchronousRequest(
-                       "https://example.com/push_example"));
-
-  for (const string& url : push_urls) {
-    // Sending subsequent requests will trigger sending real requests because
-    // client doesn't support server push.
-    const string expected_body = "This is server push response body for " + url;
-    const string response_body = client_->SendSynchronousRequest(url);
-    EXPECT_EQ(expected_body, response_body);
-  }
-  // Same number of requests are sent as that of responses received.
-  EXPECT_EQ(1 + kNumResources, client_->num_requests());
-  EXPECT_EQ(1 + kNumResources, client_->num_responses());
-}
-
-// TODO(fayang): this test seems to cause net_unittests timeouts :|
-TEST_P(EndToEndTest, DISABLED_TestHugePostWithPacketLoss) {
-  // This test tests a huge post with introduced packet loss from client to
-  // server and body size greater than 4GB, making sure QUIC code does not break
-  // for 32-bit builds.
-  ServerStreamThatDropsBodyFactory stream_factory;
-  SetSpdyStreamFactory(&stream_factory);
-  ASSERT_TRUE(Initialize());
-  // Set client's epoll server's time out to 0 to make this test be finished
-  // within a short time.
-  client_->epoll_server()->set_timeout_in_us(0);
-
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  SetPacketLossPercentage(1);
-  // To avoid storing the whole request body in memory, use a loop to repeatedly
-  // send body size of kSizeBytes until the whole request body size is reached.
-  const int kSizeBytes = 128 * 1024;
-  HTTPMessage request(HttpConstants::HTTP_1_1, HttpConstants::POST, "/foo");
-  // Request body size is 4G plus one more kSizeBytes.
-  int64_t request_body_size_bytes = pow(2, 32) + kSizeBytes;
-  ASSERT_LT(INT64_C(4294967296), request_body_size_bytes);
-  request.AddHeader("content-length", IntToString(request_body_size_bytes));
-  request.set_has_complete_message(false);
-  string body;
-  test::GenerateBody(&body, kSizeBytes);
-
-  client_->SendMessage(request);
-  for (int i = 0; i < request_body_size_bytes / kSizeBytes; ++i) {
-    bool fin = (i == request_body_size_bytes - 1);
-    client_->SendData(string(body.data(), kSizeBytes), fin);
-    client_->client()->WaitForEvents();
-  }
-  VerifyCleanConnection(true);
-}
-
-// TODO(fayang): this test seems to cause net_unittests timeouts :|
-TEST_P(EndToEndTest, DISABLED_TestHugeResponseWithPacketLoss) {
-  // This test tests a huge response with introduced loss from server to client
-  // and body size greater than 4GB, making sure QUIC code does not break for
-  // 32-bit builds.
-  const int kSizeBytes = 128 * 1024;
-  int64_t response_body_size_bytes = pow(2, 32) + kSizeBytes;
-  ASSERT_LT(4294967296, response_body_size_bytes);
-  ServerStreamThatSendsHugeResponseFactory stream_factory(
-      response_body_size_bytes);
-  SetSpdyStreamFactory(&stream_factory);
-
-  StartServer();
-
-  // Use a quic client that drops received body.
-  QuicTestClient* client = new QuicTestClientThatDropsBody(
-      server_address_, server_hostname_, client_config_,
-      client_supported_versions_);
-  client->UseWriter(client_writer_);
-  client->Connect();
-  client_.reset(client);
-  static EpollEvent event(EPOLLOUT, false);
-  client_writer_->Initialize(
-      QuicConnectionPeer::GetHelper(client_->client()->session()->connection()),
-      QuicConnectionPeer::GetAlarmFactory(
-          client_->client()->session()->connection()),
-      new ClientDelegate(client_->client()));
-  initialized_ = true;
-  ASSERT_TRUE(client_->client()->connected());
-
-  client_->client()->WaitForCryptoHandshakeConfirmed();
-  SetPacketLossPercentage(1);
-  client_->SendRequest("/huge_response");
-  client_->WaitForResponse();
-  // TODO(fayang): Fix this test to work with stateless rejects.
-  if (!BothSidesSupportStatelessRejects()) {
-    VerifyCleanConnection(true);
-  }
-}
-
-}  // namespace
-}  // namespace test
-}  // namespace net
diff --git a/src/net/tools/quic/quic_client_base.cc b/src/net/tools/quic/quic_client_base.cc
index 1b7ed1e..b6c80df 100644
--- a/src/net/tools/quic/quic_client_base.cc
+++ b/src/net/tools/quic/quic_client_base.cc
@@ -90,10 +90,12 @@ bool QuicClientBase::Initialize() {
   const uint32_t kStreamMaxRecvWindowSize = 6 * 1024 * 1024;    //  6 MB
   if (config()->GetInitialStreamFlowControlWindowToSend() ==
       kMinimumFlowControlSendWindow) {
+    VLOG(0) << "setup chromium config";
     config()->SetInitialStreamFlowControlWindowToSend(kStreamMaxRecvWindowSize);
   }
   if (config()->GetInitialSessionFlowControlWindowToSend() ==
       kMinimumFlowControlSendWindow) {
+    VLOG(0) << "setup chromium config";
     config()->SetInitialSessionFlowControlWindowToSend(
         kSessionMaxRecvWindowSize);
   }
diff --git a/src/net/tools/quic/quic_client_bin.cc b/src/net/tools/quic/quic_client_bin.cc
index 8c97948..829e5b4 100644
--- a/src/net/tools/quic/quic_client_bin.cc
+++ b/src/net/tools/quic/quic_client_bin.cc
@@ -64,6 +64,7 @@
 #include "net/tools/quic/quic_client.h"
 #include "net/tools/quic/synchronous_host_resolver.h"
 #include "url/gurl.h"
+#include "base/files/file_util.h"
 
 using base::StringPiece;
 using net::CertVerifier;
@@ -103,6 +104,8 @@ bool FLAGS_version_mismatch_ok = false;
 bool FLAGS_redirect_is_success = true;
 // Initial MTU of the connection.
 int32_t FLAGS_initial_mtu = 0;
+string FLAGS_filepath = "";
+int32_t FLAGS_recvsize = 1024*1024*2;
 
 class FakeProofVerifier : public ProofVerifier {
  public:
@@ -209,7 +212,6 @@ int main(int argc, char* argv[]) {
       return 1;
     }
   }
-
   VLOG(1) << "server host: " << FLAGS_host << " port: " << FLAGS_port
           << " body: " << FLAGS_body << " headers: " << FLAGS_headers
           << " quiet: " << FLAGS_quiet
@@ -249,6 +251,60 @@ int main(int argc, char* argv[]) {
       base::StringPrintf("%s:%d", ip_addr.ToString().c_str(), port);
   VLOG(1) << "Resolved " << host << " to " << host_port << endl;
 
+  //config and tagvector
+  net::QuicConfig client_config;
+
+  if (line->HasSwitch("filepath")) {
+    FLAGS_filepath = line->GetSwitchValueASCII("filepath");
+    VLOG(1) << "filepath:" << FLAGS_filepath;
+  }
+  if (line->HasSwitch("recvsize")) {
+    int tmp;
+    if (base::StringToInt(line->GetSwitchValueASCII("recvsize"),
+                          &tmp)) {
+      FLAGS_recvsize = tmp;
+      client_config.SetSocketReceiveBufferToSend(tmp);
+      VLOG(1) << "recvsize:" << FLAGS_recvsize;
+    }
+  }
+  const int32_t kMaxUndecryptablePackets = 100;
+  client_config.set_max_undecryptable_packets(kMaxUndecryptablePackets*100);
+//  client_config.SetBytesForConnectionIdToSend(0);
+
+  net::QuicTagVector sopt;
+  if (line->HasSwitch("bbr")) {
+    VLOG(0) << "using BBR";
+    sopt.push_back(net::kTBBR);
+  }
+  if (line->HasSwitch("qbic")) {
+    VLOG(0) << "using QBIC";
+    sopt.push_back(net::kQBIC);
+  }
+  client_config.SetClientConnectionOptions(sopt);
+
+  if (line->HasSwitch("forceholb")) {
+    VLOG(0) << "using forceHolBlocking";
+    client_config.SetForceHolBlocking();
+  }
+
+  // Construct the string body from flags, if provided.
+  string body = FLAGS_body;
+  if (!FLAGS_body_hex.empty()) {
+    DCHECK(FLAGS_body.empty()) << "Only set one of --body and --body_hex.";
+    body = net::QuicUtils::HexDecode(FLAGS_body_hex);
+  }
+  if (!FLAGS_filepath.empty()) {
+    base::FilePath path = base::FilePath(FLAGS_filepath);
+    VLOG(1) << "filepath:"  << FLAGS_filepath << "," << path.value();
+
+    if (base::ReadFileToString(path, &body)) {
+      VLOG(1) << "ReadFile Size=" << body.size();
+    } else {
+      VLOG(1) << "Failed ReadFile, not found:" << path.value();
+      return 1;
+    }
+  }
+
   // Build the client, and try to connect.
   net::EpollServer epoll_server;
   net::QuicServerId server_id(url.host(), url.EffectiveIntPort(),
@@ -269,12 +325,17 @@ int main(int argc, char* argv[]) {
   if (line->HasSwitch("disable-certificate-verification")) {
     proof_verifier.reset(new FakeProofVerifier());
   } else {
+    proof_verifier.reset(new FakeProofVerifier());
+#if 0
     proof_verifier.reset(new ProofVerifierChromium(
         cert_verifier.get(), ct_policy_enforcer.get(),
         transport_security_state.get(), ct_verifier.get()));
+#endif
   }
   net::QuicClient client(net::QuicSocketAddress(ip_addr, port), server_id,
-                         versions, &epoll_server, std::move(proof_verifier));
+                         versions,
+                         client_config,
+                         &epoll_server, std::move(proof_verifier));
   client.set_initial_max_packet_length(
       FLAGS_initial_mtu != 0 ? FLAGS_initial_mtu : net::kDefaultMaxPacketSize);
   if (!client.Initialize()) {
@@ -295,12 +356,7 @@ int main(int argc, char* argv[]) {
   }
   cout << "Connected to " << host_port << endl;
 
-  // Construct the string body from flags, if provided.
-  string body = FLAGS_body;
-  if (!FLAGS_body_hex.empty()) {
-    DCHECK(FLAGS_body.empty()) << "Only set one of --body and --body_hex.";
-    body = net::QuicUtils::HexDecode(FLAGS_body_hex);
-  }
+
 
   // Construct a GET or POST request for supplied URL.
   SpdyHeaderBlock header_block;
diff --git a/src/net/tools/quic/quic_client_session_test.cc.orig b/src/net/tools/quic/quic_client_session_test.cc.orig
deleted file mode 100644
index b6cae39..0000000
--- a/src/net/tools/quic/quic_client_session_test.cc.orig
+++ /dev/null
@@ -1,521 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "net/tools/quic/quic_client_session.h"
-
-#include <vector>
-
-#include "base/strings/stringprintf.h"
-#include "net/base/ip_endpoint.h"
-#include "net/quic/crypto/aes_128_gcm_12_encrypter.h"
-#include "net/quic/quic_flags.h"
-#include "net/quic/spdy_utils.h"
-#include "net/quic/test_tools/crypto_test_utils.h"
-#include "net/quic/test_tools/mock_quic_spdy_client_stream.h"
-#include "net/quic/test_tools/quic_connection_peer.h"
-#include "net/quic/test_tools/quic_packet_creator_peer.h"
-#include "net/quic/test_tools/quic_spdy_session_peer.h"
-#include "net/quic/test_tools/quic_test_utils.h"
-#include "net/tools/quic/quic_spdy_client_stream.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-using base::StringPrintf;
-using net::test::ConstructEncryptedPacket;
-using net::test::ConstructMisFramedEncryptedPacket;
-using net::test::CryptoTestUtils;
-using net::test::DefaultQuicConfig;
-using net::test::MockConnection;
-using net::test::MockConnectionHelper;
-using net::test::MockQuicSpdyClientStream;
-using net::test::PacketSavingConnection;
-using net::test::QuicConnectionPeer;
-using net::test::QuicPacketCreatorPeer;
-using net::test::QuicSpdySessionPeer;
-using net::test::SupportedVersions;
-using net::test::TestPeerIPAddress;
-using net::test::ValueRestore;
-using net::test::kClientDataStreamId1;
-using net::test::kServerDataStreamId1;
-using net::test::kTestPort;
-using testing::AnyNumber;
-using testing::Invoke;
-using testing::Truly;
-using testing::_;
-
-namespace net {
-namespace test {
-namespace {
-
-const char kServerHostname[] = "test.example.com";
-const uint16_t kPort = 80;
-
-class TestQuicClientSession : public QuicClientSession {
- public:
-  explicit TestQuicClientSession(const QuicConfig& config,
-                                 QuicConnection* connection,
-                                 const QuicServerId& server_id,
-                                 QuicCryptoClientConfig* crypto_config,
-                                 QuicClientPushPromiseIndex* push_promise_index)
-      : QuicClientSession(config,
-                          connection,
-                          server_id,
-                          crypto_config,
-                          push_promise_index) {}
-
-  QuicSpdyClientStream* CreateClientStream() override {
-    return new MockQuicSpdyClientStream(GetNextOutgoingStreamId(), this);
-  }
-
-  MockQuicSpdyClientStream* CreateIncomingDynamicStream(
-      QuicStreamId id) override {
-    return new MockQuicSpdyClientStream(id, this);
-  }
-};
-
-class QuicClientSessionTest : public ::testing::TestWithParam<QuicVersion> {
- protected:
-  QuicClientSessionTest()
-      : crypto_config_(CryptoTestUtils::ProofVerifierForTesting()),
-        promised_stream_id_(kServerDataStreamId1),
-        associated_stream_id_(kClientDataStreamId1) {
-    Initialize();
-    // Advance the time, because timers do not like uninitialized times.
-    connection_->AdvanceTime(QuicTime::Delta::FromSeconds(1));
-  }
-
-  ~QuicClientSessionTest() override {
-    // Session must be destroyed before promised_by_url_
-    session_.reset(nullptr);
-  }
-
-  void Initialize() {
-    session_.reset();
-    connection_ = new PacketSavingConnection(&helper_, Perspective::IS_CLIENT,
-                                             SupportedVersions(GetParam()));
-    session_.reset(new TestQuicClientSession(
-        DefaultQuicConfig(), connection_,
-        QuicServerId(kServerHostname, kPort, PRIVACY_MODE_DISABLED),
-        &crypto_config_, &push_promise_index_));
-    session_->Initialize();
-    push_promise_[":path"] = "/bar";
-    push_promise_[":authority"] = "www.google.com";
-    push_promise_[":version"] = "HTTP/1.1";
-    push_promise_[":method"] = "GET";
-    push_promise_[":scheme"] = "https";
-    promise_url_ = SpdyUtils::GetUrlFromHeaderBlock(push_promise_);
-  }
-
-  void CompleteCryptoHandshake() {
-    session_->CryptoConnect();
-    QuicCryptoClientStream* stream =
-        static_cast<QuicCryptoClientStream*>(session_->GetCryptoStream());
-    CryptoTestUtils::FakeServerOptions options;
-    CryptoTestUtils::HandshakeWithFakeServer(&helper_, connection_, stream,
-                                             options);
-  }
-
-  QuicCryptoClientConfig crypto_config_;
-  MockConnectionHelper helper_;
-  PacketSavingConnection* connection_;
-  scoped_ptr<TestQuicClientSession> session_;
-  QuicClientPushPromiseIndex push_promise_index_;
-  SpdyHeaderBlock push_promise_;
-  string promise_url_;
-  QuicStreamId promised_stream_id_;
-  QuicStreamId associated_stream_id_;
-};
-
-INSTANTIATE_TEST_CASE_P(Tests,
-                        QuicClientSessionTest,
-                        ::testing::ValuesIn(QuicSupportedVersions()));
-
-TEST_P(QuicClientSessionTest, CryptoConnect) {
-  CompleteCryptoHandshake();
-}
-
-TEST_P(QuicClientSessionTest, NoEncryptionAfterInitialEncryption) {
-  ValueRestore<bool> old_flag(&FLAGS_quic_block_unencrypted_writes, true);
-  // Complete a handshake in order to prime the crypto config for 0-RTT.
-  CompleteCryptoHandshake();
-
-  // Now create a second session using the same crypto config.
-  Initialize();
-
-  // Starting the handshake should move immediately to encryption
-  // established and will allow streams to be created.
-  session_->CryptoConnect();
-  EXPECT_TRUE(session_->IsEncryptionEstablished());
-  QuicSpdyClientStream* stream =
-      session_->CreateOutgoingDynamicStream(kDefaultPriority);
-  DCHECK_NE(kCryptoStreamId, stream->id());
-  EXPECT_TRUE(stream != nullptr);
-
-  // Process an "inchoate" REJ from the server which will cause
-  // an inchoate CHLO to be sent and will leave the encryption level
-  // at NONE.
-  CryptoHandshakeMessage rej;
-  CryptoTestUtils::FillInDummyReject(&rej, /* stateless */ false);
-  EXPECT_TRUE(session_->IsEncryptionEstablished());
-  session_->GetCryptoStream()->OnHandshakeMessage(rej);
-  EXPECT_FALSE(session_->IsEncryptionEstablished());
-  EXPECT_EQ(ENCRYPTION_NONE,
-            QuicPacketCreatorPeer::GetEncryptionLevel(
-                QuicConnectionPeer::GetPacketCreator(connection_)));
-  // Verify that no new streams may be created.
-  EXPECT_TRUE(session_->CreateOutgoingDynamicStream(kDefaultPriority) ==
-              nullptr);
-  // Verify that no data may be send on existing streams.
-  char data[] = "hello world";
-  struct iovec iov = {data, arraysize(data)};
-  QuicIOVector iovector(&iov, 1, iov.iov_len);
-  QuicConsumedData consumed = session_->WritevData(
-      stream->id(), iovector, 0, false, MAY_FEC_PROTECT, nullptr);
-  EXPECT_FALSE(consumed.fin_consumed);
-  EXPECT_EQ(0u, consumed.bytes_consumed);
-}
-
-TEST_P(QuicClientSessionTest, MaxNumStreamsWithNoFinOrRst) {
-  EXPECT_CALL(*connection_, SendRstStream(_, _, _)).Times(AnyNumber());
-
-  session_->config()->SetMaxStreamsPerConnection(1, 1);
-
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-
-  QuicSpdyClientStream* stream =
-      session_->CreateOutgoingDynamicStream(kDefaultPriority);
-  ASSERT_TRUE(stream);
-  EXPECT_FALSE(session_->CreateOutgoingDynamicStream(kDefaultPriority));
-
-  // Close the stream, but without having received a FIN or a RST_STREAM
-  // and check that a new one can not be created.
-  session_->CloseStream(stream->id());
-  EXPECT_EQ(1u, session_->GetNumOpenOutgoingStreams());
-
-  stream = session_->CreateOutgoingDynamicStream(kDefaultPriority);
-  EXPECT_FALSE(stream);
-}
-
-TEST_P(QuicClientSessionTest, MaxNumStreamsWithRst) {
-  EXPECT_CALL(*connection_, SendRstStream(_, _, _)).Times(AnyNumber());
-
-  session_->config()->SetMaxStreamsPerConnection(1, 1);
-
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-
-  QuicSpdyClientStream* stream =
-      session_->CreateOutgoingDynamicStream(kDefaultPriority);
-  ASSERT_TRUE(stream);
-  EXPECT_FALSE(session_->CreateOutgoingDynamicStream(kDefaultPriority));
-
-  // Close the stream and receive an RST frame to remove the unfinished stream
-  session_->CloseStream(stream->id());
-  session_->OnRstStream(QuicRstStreamFrame(
-      stream->id(), AdjustErrorForVersion(QUIC_RST_ACKNOWLEDGEMENT, GetParam()),
-      0));
-  // Check that a new one can be created.
-  EXPECT_EQ(0u, session_->GetNumOpenOutgoingStreams());
-  stream = session_->CreateOutgoingDynamicStream(kDefaultPriority);
-  EXPECT_TRUE(stream);
-}
-
-TEST_P(QuicClientSessionTest, GoAwayReceived) {
-  CompleteCryptoHandshake();
-
-  // After receiving a GoAway, I should no longer be able to create outgoing
-  // streams.
-  session_->connection()->OnGoAwayFrame(
-      QuicGoAwayFrame(QUIC_PEER_GOING_AWAY, 1u, "Going away."));
-  EXPECT_EQ(nullptr, session_->CreateOutgoingDynamicStream(kDefaultPriority));
-}
-
-TEST_P(QuicClientSessionTest, SetFecProtectionFromConfig) {
-  ValueRestore<bool> old_flag(&FLAGS_enable_quic_fec, true);
-
-  // Set FEC config in client's connection options.
-  QuicTagVector copt;
-  copt.push_back(kFHDR);
-  session_->config()->SetConnectionOptionsToSend(copt);
-
-  // Doing the handshake should set up FEC config correctly.
-  CompleteCryptoHandshake();
-
-  // Verify that headers stream is always protected and data streams are
-  // optionally protected.
-  EXPECT_EQ(
-      FEC_PROTECT_ALWAYS,
-      QuicSpdySessionPeer::GetHeadersStream(session_.get())->fec_policy());
-  QuicSpdyClientStream* stream =
-      session_->CreateOutgoingDynamicStream(kDefaultPriority);
-  ASSERT_TRUE(stream);
-  EXPECT_EQ(FEC_PROTECT_OPTIONAL, stream->fec_policy());
-}
-
-static bool CheckForDecryptionError(QuicFramer* framer) {
-  return framer->error() == QUIC_DECRYPTION_FAILURE;
-}
-
-// Regression test for b/17206611.
-TEST_P(QuicClientSessionTest, InvalidPacketReceived) {
-  IPEndPoint server_address(TestPeerIPAddress(), kTestPort);
-  IPEndPoint client_address(TestPeerIPAddress(), kTestPort);
-
-  EXPECT_CALL(*connection_, ProcessUdpPacket(server_address, client_address, _))
-      .WillRepeatedly(Invoke(static_cast<MockConnection*>(connection_),
-                             &MockConnection::ReallyProcessUdpPacket));
-  EXPECT_CALL(*connection_, OnCanWrite()).Times(AnyNumber());
-  EXPECT_CALL(*connection_, OnError(_)).Times(1);
-
-  // Verify that empty packets don't close the connection.
-  QuicEncryptedPacket zero_length_packet(nullptr, 0, false);
-  EXPECT_CALL(*connection_, SendConnectionCloseWithDetails(_, _)).Times(0);
-  session_->ProcessUdpPacket(client_address, server_address,
-                             zero_length_packet);
-
-  // Verifiy that small, invalid packets don't close the connection.
-  char buf[2] = {0x00, 0x01};
-  QuicEncryptedPacket valid_packet(buf, 2, false);
-  // Close connection shouldn't be called.
-  EXPECT_CALL(*connection_, SendConnectionCloseWithDetails(_, _)).Times(0);
-  session_->ProcessUdpPacket(client_address, server_address, valid_packet);
-
-  // Verify that a non-decryptable packet doesn't close the connection.
-  QuicConnectionId connection_id = session_->connection()->connection_id();
-  scoped_ptr<QuicEncryptedPacket> packet(ConstructEncryptedPacket(
-      connection_id, false, false, false, kDefaultPathId, 100, "data"));
-  // Change the last byte of the encrypted data.
-  *(const_cast<char*>(packet->data() + packet->length() - 1)) += 1;
-  EXPECT_CALL(*connection_, SendConnectionCloseWithDetails(_, _)).Times(0);
-  EXPECT_CALL(*connection_, OnError(Truly(CheckForDecryptionError))).Times(1);
-  session_->ProcessUdpPacket(client_address, server_address, *packet);
-}
-
-// A packet with invalid framing should cause a connection to be closed.
-TEST_P(QuicClientSessionTest, InvalidFramedPacketReceived) {
-  IPEndPoint server_address(TestPeerIPAddress(), kTestPort);
-  IPEndPoint client_address(TestPeerIPAddress(), kTestPort);
-
-  EXPECT_CALL(*connection_, ProcessUdpPacket(server_address, client_address, _))
-      .WillRepeatedly(Invoke(static_cast<MockConnection*>(connection_),
-                             &MockConnection::ReallyProcessUdpPacket));
-  EXPECT_CALL(*connection_, OnError(_)).Times(1);
-
-  // Verify that a decryptable packet with bad frames does close the connection.
-  QuicConnectionId connection_id = session_->connection()->connection_id();
-  scoped_ptr<QuicEncryptedPacket> packet(ConstructMisFramedEncryptedPacket(
-      connection_id, false, false, false, kDefaultPathId, 100, "data",
-      PACKET_8BYTE_CONNECTION_ID, PACKET_6BYTE_PACKET_NUMBER, nullptr));
-  EXPECT_CALL(*connection_, SendConnectionCloseWithDetails(_, _)).Times(1);
-  session_->ProcessUdpPacket(client_address, server_address, *packet);
-}
-
-TEST_P(QuicClientSessionTest, PushPromiseOnPromiseHeaders) {
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-
-  MockQuicSpdyClientStream* stream = static_cast<MockQuicSpdyClientStream*>(
-      session_->CreateOutgoingDynamicStream(kDefaultPriority));
-
-  EXPECT_CALL(*stream, OnPromiseHeaders(_));
-  StringPiece headers_data;
-  session_->OnPromiseHeaders(associated_stream_id_, headers_data);
-}
-
-TEST_P(QuicClientSessionTest, PushPromiseOnPromiseHeadersAlreadyClosed) {
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-
-  session_->CreateOutgoingDynamicStream(kDefaultPriority);
-
-  EXPECT_CALL(*connection_,
-              SendRstStream(associated_stream_id_, QUIC_REFUSED_STREAM, 0));
-  session_->ResetPromised(associated_stream_id_, QUIC_REFUSED_STREAM);
-
-  StringPiece headers_data;
-  session_->OnPromiseHeaders(associated_stream_id_, headers_data);
-}
-
-TEST_P(QuicClientSessionTest, PushPromiseOnHeadersCompleteAlreadyClosed) {
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-
-  session_->CreateOutgoingDynamicStream(kDefaultPriority);
-  EXPECT_CALL(*connection_,
-              SendRstStream(associated_stream_id_, QUIC_REFUSED_STREAM, 0));
-  session_->ResetPromised(associated_stream_id_, QUIC_REFUSED_STREAM);
-
-  session_->OnPromiseHeadersComplete(associated_stream_id_, promised_stream_id_,
-                                     0);
-}
-
-TEST_P(QuicClientSessionTest, PushPromiseOutOfOrder) {
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-
-  MockQuicSpdyClientStream* stream = static_cast<MockQuicSpdyClientStream*>(
-      session_->CreateOutgoingDynamicStream(kDefaultPriority));
-
-  EXPECT_CALL(*stream, OnPromiseHeadersComplete(promised_stream_id_, _));
-  session_->OnPromiseHeadersComplete(associated_stream_id_, promised_stream_id_,
-                                     0);
-  associated_stream_id_ += 2;
-  EXPECT_CALL(*connection_, SendConnectionCloseWithDetails(
-                                QUIC_INVALID_STREAM_ID,
-                                "Received push stream id lesser or equal to the"
-                                " last accepted before"));
-  session_->OnPromiseHeadersComplete(associated_stream_id_, promised_stream_id_,
-                                     0);
-}
-
-TEST_P(QuicClientSessionTest, PushPromiseHandlePromise) {
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-
-  session_->CreateOutgoingDynamicStream(kDefaultPriority);
-
-  session_->HandlePromised(promised_stream_id_, push_promise_);
-
-  EXPECT_NE(session_->GetPromisedById(promised_stream_id_), nullptr);
-  EXPECT_NE(session_->GetPromisedByUrl(promise_url_), nullptr);
-}
-
-TEST_P(QuicClientSessionTest, PushPromiseAlreadyClosed) {
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-
-  session_->CreateOutgoingDynamicStream(kDefaultPriority);
-  session_->GetStream(promised_stream_id_);
-
-  EXPECT_CALL(*connection_,
-              SendRstStream(promised_stream_id_, QUIC_REFUSED_STREAM, 0));
-
-  session_->ResetPromised(promised_stream_id_, QUIC_REFUSED_STREAM);
-  SpdyHeaderBlock promise_headers;
-  session_->HandlePromised(promised_stream_id_, promise_headers);
-
-  // Verify that the promise was not created.
-  EXPECT_EQ(session_->GetPromisedById(promised_stream_id_), nullptr);
-  EXPECT_EQ(session_->GetPromisedByUrl(promise_url_), nullptr);
-}
-
-TEST_P(QuicClientSessionTest, PushPromiseDuplicateUrl) {
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-
-  session_->CreateOutgoingDynamicStream(kDefaultPriority);
-
-  session_->HandlePromised(promised_stream_id_, push_promise_);
-
-  EXPECT_NE(session_->GetPromisedById(promised_stream_id_), nullptr);
-  EXPECT_NE(session_->GetPromisedByUrl(promise_url_), nullptr);
-
-  promised_stream_id_ += 2;
-  EXPECT_CALL(*connection_, SendRstStream(promised_stream_id_,
-                                          QUIC_DUPLICATE_PROMISE_URL, 0));
-
-  session_->HandlePromised(promised_stream_id_, push_promise_);
-
-  // Verify that the promise was not created.
-  EXPECT_EQ(session_->GetPromisedById(promised_stream_id_), nullptr);
-}
-
-TEST_P(QuicClientSessionTest, ReceivingPromiseEnhanceYourCalm) {
-  for (size_t i = 0u; i < session_->get_max_promises(); i++) {
-    push_promise_[":path"] = StringPrintf("/bar%zu", i);
-
-    QuicStreamId id = promised_stream_id_ + i * 2;
-
-    session_->HandlePromised(id, push_promise_);
-
-    // Verify that the promise is in the unclaimed streams map.
-    string promise_url(SpdyUtils::GetUrlFromHeaderBlock(push_promise_));
-    EXPECT_NE(session_->GetPromisedByUrl(promise_url), nullptr);
-    EXPECT_NE(session_->GetPromisedById(id), nullptr);
-  }
-
-  // One more promise, this should be refused.
-  int i = session_->get_max_promises();
-  push_promise_[":path"] = StringPrintf("/bar%d", i);
-
-  QuicStreamId id = promised_stream_id_ + i * 2;
-  EXPECT_CALL(*connection_, SendRstStream(id, QUIC_REFUSED_STREAM, 0));
-  session_->HandlePromised(id, push_promise_);
-
-  // Verify that the promise was not created.
-  string promise_url(SpdyUtils::GetUrlFromHeaderBlock(push_promise_));
-  EXPECT_EQ(session_->GetPromisedById(id), nullptr);
-  EXPECT_EQ(session_->GetPromisedByUrl(promise_url), nullptr);
-}
-
-TEST_P(QuicClientSessionTest, IsClosedTrueAfterResetPromisedAlreadyOpen) {
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-
-  session_->GetStream(promised_stream_id_);
-  session_->ResetPromised(promised_stream_id_, QUIC_REFUSED_STREAM);
-  EXPECT_TRUE(session_->IsClosedStream(promised_stream_id_));
-}
-
-TEST_P(QuicClientSessionTest, IsClosedTrueAfterResetPromisedNonexistant) {
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-
-  session_->ResetPromised(promised_stream_id_, QUIC_REFUSED_STREAM);
-  EXPECT_TRUE(session_->IsClosedStream(promised_stream_id_));
-}
-
-TEST_P(QuicClientSessionTest, OnInitialHeadersCompleteIsPush) {
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-  session_->GetStream(promised_stream_id_);
-  session_->HandlePromised(promised_stream_id_, push_promise_);
-  EXPECT_NE(session_->GetPromisedById(promised_stream_id_), nullptr);
-  EXPECT_NE(session_->GetPromisedStream(promised_stream_id_), nullptr);
-  EXPECT_NE(session_->GetPromisedByUrl(promise_url_), nullptr);
-
-  session_->OnInitialHeadersComplete(promised_stream_id_, SpdyHeaderBlock());
-}
-
-TEST_P(QuicClientSessionTest, OnInitialHeadersCompleteIsNotPush) {
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-  session_->CreateOutgoingDynamicStream(kDefaultPriority);
-  session_->OnInitialHeadersComplete(promised_stream_id_, SpdyHeaderBlock());
-}
-
-TEST_P(QuicClientSessionTest, DeletePromised) {
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-  session_->GetStream(promised_stream_id_);
-  session_->HandlePromised(promised_stream_id_, push_promise_);
-  QuicClientPromisedInfo* promised =
-      session_->GetPromisedById(promised_stream_id_);
-  EXPECT_NE(promised, nullptr);
-  EXPECT_NE(session_->GetPromisedStream(promised_stream_id_), nullptr);
-  EXPECT_NE(session_->GetPromisedByUrl(promise_url_), nullptr);
-
-  session_->DeletePromised(promised);
-  EXPECT_EQ(session_->GetPromisedById(promised_stream_id_), nullptr);
-  EXPECT_EQ(session_->GetPromisedByUrl(promise_url_), nullptr);
-}
-
-TEST_P(QuicClientSessionTest, ResetPromised) {
-  // Initialize crypto before the client session will create a stream.
-  CompleteCryptoHandshake();
-  session_->GetStream(promised_stream_id_);
-  session_->HandlePromised(promised_stream_id_, push_promise_);
-  EXPECT_CALL(*connection_, SendRstStream(promised_stream_id_,
-                                          QUIC_STREAM_PEER_GOING_AWAY, 0));
-  session_->SendRstStream(promised_stream_id_, QUIC_STREAM_PEER_GOING_AWAY, 0);
-  QuicClientPromisedInfo* promised =
-      session_->GetPromisedById(promised_stream_id_);
-  EXPECT_NE(promised, nullptr);
-  EXPECT_NE(session_->GetPromisedByUrl(promise_url_), nullptr);
-  EXPECT_EQ(session_->GetPromisedStream(promised_stream_id_), nullptr);
-}
-
-}  // namespace
-}  // namespace test
-}  // namespace net
diff --git a/src/net/tools/quic/quic_http_response_cache.cc b/src/net/tools/quic/quic_http_response_cache.cc
index bc6c819..09ba6fc 100644
--- a/src/net/tools/quic/quic_http_response_cache.cc
+++ b/src/net/tools/quic/quic_http_response_cache.cc
@@ -82,11 +82,11 @@ void QuicHttpResponseCache::ResourceFile::Read() {
     }
     // Headers are "key: value".
     pos = line.find(": ");
-    if (pos == string::npos) {
-      LOG(DFATAL) << "Headers invalid or empty, ignoring: "
-                  << file_name_.value();
-      return;
-    }
+//    if (pos == string::npos) {
+//      LOG(DFATAL) << "Headers invalid or empty, ignoring: "
+//                  << file_name_.value();
+//      return;
+//    }
     spdy_headers_.AppendValueOrAddHeader(
         base::ToLowerASCII(line.substr(0, pos)), line.substr(pos + 2));
   }
diff --git a/src/net/tools/quic/quic_server.cc b/src/net/tools/quic/quic_server.cc
index 7054dcf..d1b4313 100644
--- a/src/net/tools/quic/quic_server.cc
+++ b/src/net/tools/quic/quic_server.cc
@@ -80,17 +80,21 @@ QuicServer::QuicServer(
 void QuicServer::Initialize() {
   // If an initial flow control window has not explicitly been set, then use a
   // sensible value for a server: 1 MB for session, 64 KB for each stream.
-  const uint32_t kInitialSessionFlowControlWindow = 1 * 1024 * 1024;  // 1 MB
-  const uint32_t kInitialStreamFlowControlWindow = 64 * 1024;         // 64 KB
+  const uint32_t kInitialSessionFlowControlWindow = 15 * 1024 * 1024;  // 1 MB
+  const uint32_t kInitialStreamFlowControlWindow = 6 * 1024 * 1024;         // 64 KB
+// const uint32_t kInitialSessionFlowControlWindow = 1 * 1024 * 1024;  // 1 MB
+//  const uint32_t kInitialStreamFlowControlWindow = 64 * 1024;         // 64 KB
   if (config_.GetInitialStreamFlowControlWindowToSend() ==
       kMinimumFlowControlSendWindow) {
+    VLOG(0) << "update config";
     config_.SetInitialStreamFlowControlWindowToSend(
-        kInitialStreamFlowControlWindow);
+        kInitialSessionFlowControlWindow);
   }
   if (config_.GetInitialSessionFlowControlWindowToSend() ==
       kMinimumFlowControlSendWindow) {
+    VLOG(0) << "update config";
     config_.SetInitialSessionFlowControlWindowToSend(
-        kInitialSessionFlowControlWindow);
+        kInitialStreamFlowControlWindow);
   }
 
   epoll_server_.set_timeout_in_us(50 * 1000);
diff --git a/src/net/tools/quic/quic_server_bin.cc b/src/net/tools/quic/quic_server_bin.cc
index 6fc2524..e9c02b8 100644
--- a/src/net/tools/quic/quic_server_bin.cc
+++ b/src/net/tools/quic/quic_server_bin.cc
@@ -20,6 +20,7 @@
 
 // The port the quic server will listen on.
 int32_t FLAGS_port = 6121;
+int32_t FLAGS_recvsize = 1024*1024*2;
 
 std::unique_ptr<net::ProofSource> CreateProofSource(
     const base::FilePath& cert_path,
@@ -78,8 +79,28 @@ int main(int argc, char* argv[]) {
     LOG(ERROR) << "missing --key_file";
     return 1;
   }
-
+  net::QuicTagVector ropt;
+  net::QuicTagVector sopt;
   net::QuicConfig config;
+
+  ropt.push_back(net::kTBBR);
+  ropt.push_back(net::kQBIC);
+  config.SetInitialReceivedConnectionOptions(ropt);
+
+  sopt.push_back(net::kTBBR);
+  sopt.push_back(net::kQBIC);
+  config.SetConnectionOptionsToSend(sopt);
+
+  if (line->HasSwitch("recvsize")) {
+    int tmp;
+    if (base::StringToInt(line->GetSwitchValueASCII("recvsize"),
+                          &tmp)) {
+      FLAGS_recvsize = tmp;
+      config.SetSocketReceiveBufferToSend(tmp);
+      VLOG(0) << "recvsize:" << FLAGS_recvsize;
+    }
+  }
+
   net::QuicServer server(
       CreateProofSource(line->GetSwitchValuePath("certificate_file"),
                         line->GetSwitchValuePath("key_file")),
diff --git a/src/net/tools/quic/quic_simple_server_session_test.cc.orig b/src/net/tools/quic/quic_simple_server_session_test.cc.orig
deleted file mode 100644
index e342c32..0000000
--- a/src/net/tools/quic/quic_simple_server_session_test.cc.orig
+++ /dev/null
@@ -1,635 +0,0 @@
-// Copyright 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "net/tools/quic/quic_simple_server_session.h"
-
-#include <algorithm>
-#include <memory>
-
-#include "base/macros.h"
-#include "base/strings/string_number_conversions.h"
-#include "net/quic/crypto/quic_crypto_server_config.h"
-#include "net/quic/crypto/quic_random.h"
-#include "net/quic/proto/cached_network_parameters.pb.h"
-#include "net/quic/quic_connection.h"
-#include "net/quic/quic_crypto_server_stream.h"
-#include "net/quic/quic_utils.h"
-#include "net/quic/test_tools/crypto_test_utils.h"
-#include "net/quic/test_tools/quic_config_peer.h"
-#include "net/quic/test_tools/quic_connection_peer.h"
-#include "net/quic/test_tools/quic_sent_packet_manager_peer.h"
-#include "net/quic/test_tools/quic_session_peer.h"
-#include "net/quic/test_tools/quic_spdy_session_peer.h"
-#include "net/quic/test_tools/quic_spdy_stream_peer.h"
-#include "net/quic/test_tools/quic_sustained_bandwidth_recorder_peer.h"
-#include "net/quic/test_tools/quic_test_utils.h"
-#include "net/test/gtest_util.h"
-#include "net/tools/quic/quic_simple_server_stream.h"
-#include "net/tools/quic/test_tools/mock_quic_server_session_visitor.h"
-#include "net/tools/quic/test_tools/quic_in_memory_cache_peer.h"
-#include "testing/gmock/include/gmock/gmock.h"
-#include "testing/gtest/include/gtest/gtest.h"
-
-using net::test::CryptoTestUtils;
-using net::test::GenerateBody;
-using net::test::MockQuicConnection;
-using net::test::MockQuicConnectionHelper;
-using net::test::QuicConfigPeer;
-using net::test::QuicConnectionPeer;
-using net::test::QuicSpdyStreamPeer;
-using net::test::QuicSentPacketManagerPeer;
-using net::test::QuicSessionPeer;
-using net::test::QuicSpdySessionPeer;
-using net::test::QuicSustainedBandwidthRecorderPeer;
-using net::test::SupportedVersions;
-using net::test::ValueRestore;
-using net::test::kClientDataStreamId1;
-using net::test::kClientDataStreamId2;
-using net::test::kClientDataStreamId3;
-using net::test::kInitialSessionFlowControlWindowForTest;
-using net::test::kInitialStreamFlowControlWindowForTest;
-using std::string;
-using testing::StrictMock;
-using testing::_;
-using testing::InSequence;
-using testing::Return;
-using testing::AtLeast;
-
-namespace net {
-namespace test {
-namespace {
-typedef QuicSimpleServerSession::PromisedStreamInfo PromisedStreamInfo;
-}  // namespace
-
-class MockQuicHeadersStream : public QuicHeadersStream {
- public:
-  explicit MockQuicHeadersStream(QuicSpdySession* session)
-      : QuicHeadersStream(session) {}
-
-  // Methods taking non-copyable types like SpdyHeaderBlock by value cannot be
-  // mocked directly.
-  size_t WritePushPromise(QuicStreamId original_stream_id,
-                          QuicStreamId promised_stream_id,
-                          SpdyHeaderBlock headers,
-                          QuicAckListenerInterface* ack_listener) override {
-    return WritePushPromiseMock(original_stream_id, promised_stream_id, headers,
-                                ack_listener);
-  }
-  MOCK_METHOD4(WritePushPromiseMock,
-               size_t(QuicStreamId original_stream_id,
-                      QuicStreamId promised_stream_id,
-                      const SpdyHeaderBlock& headers,
-                      QuicAckListenerInterface* ack_listener));
-
-  size_t WriteHeaders(QuicStreamId stream_id,
-                      SpdyHeaderBlock headers,
-                      bool fin,
-                      SpdyPriority priority,
-                      QuicAckListenerInterface* ack_listener) override {
-    return WriteHeadersMock(stream_id, headers, fin, priority, ack_listener);
-  }
-  MOCK_METHOD5(WriteHeadersMock,
-               size_t(QuicStreamId stream_id,
-                      const SpdyHeaderBlock& headers,
-                      bool fin,
-                      SpdyPriority priority,
-                      QuicAckListenerInterface* ack_listener));
-};
-
-class MockQuicCryptoServerStream : public QuicCryptoServerStream {
- public:
-  explicit MockQuicCryptoServerStream(
-      const QuicCryptoServerConfig* crypto_config,
-      QuicCompressedCertsCache* compressed_certs_cache,
-      QuicServerSessionBase* session)
-      : QuicCryptoServerStream(crypto_config,
-                               compressed_certs_cache,
-                               FLAGS_enable_quic_stateless_reject_support,
-                               session) {}
-  ~MockQuicCryptoServerStream() override {}
-
-  MOCK_METHOD1(SendServerConfigUpdate,
-               void(const CachedNetworkParameters* cached_network_parameters));
-
-  void set_encryption_established(bool has_established) {
-    encryption_established_ = has_established;
-  }
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(MockQuicCryptoServerStream);
-};
-
-class MockQuicConnectionWithSendStreamData : public MockQuicConnection {
- public:
-  MockQuicConnectionWithSendStreamData(
-      MockQuicConnectionHelper* helper,
-      MockAlarmFactory* alarm_factory,
-      Perspective perspective,
-      const QuicVersionVector& supported_versions)
-      : MockQuicConnection(helper,
-                           alarm_factory,
-                           perspective,
-                           supported_versions) {}
-
-  MOCK_METHOD5(SendStreamData,
-               QuicConsumedData(QuicStreamId id,
-                                QuicIOVector iov,
-                                QuicStreamOffset offset,
-                                bool fin,
-                                QuicAckListenerInterface* listern));
-};
-
-class QuicSimpleServerSessionPeer {
- public:
-  static void SetCryptoStream(QuicSimpleServerSession* s,
-                              QuicCryptoServerStream* crypto_stream) {
-    s->crypto_stream_.reset(crypto_stream);
-    s->static_streams()[kCryptoStreamId] = crypto_stream;
-  }
-
-  static QuicSpdyStream* CreateIncomingDynamicStream(QuicSimpleServerSession* s,
-                                                     QuicStreamId id) {
-    return s->CreateIncomingDynamicStream(id);
-  }
-
-  static QuicSimpleServerStream* CreateOutgoingDynamicStream(
-      QuicSimpleServerSession* s,
-      SpdyPriority priority) {
-    return s->CreateOutgoingDynamicStream(priority);
-  }
-
-  static std::deque<PromisedStreamInfo>* promised_streams(
-      QuicSimpleServerSession* s) {
-    return &(s->promised_streams_);
-  }
-
-  static QuicStreamId hightest_promised_stream_id(QuicSimpleServerSession* s) {
-    return s->highest_promised_stream_id_;
-  }
-};
-
-namespace {
-
-const size_t kMaxStreamsForTest = 10;
-
-class QuicSimpleServerSessionTest
-    : public ::testing::TestWithParam<QuicVersion> {
- protected:
-  QuicSimpleServerSessionTest()
-      : crypto_config_(QuicCryptoServerConfig::TESTING,
-                       QuicRandom::GetInstance(),
-                       CryptoTestUtils::ProofSourceForTesting()),
-        compressed_certs_cache_(
-            QuicCompressedCertsCache::kQuicCompressedCertsCacheSize) {
-    FLAGS_quic_always_log_bugs_for_tests = true;
-    config_.SetMaxStreamsPerConnection(kMaxStreamsForTest, kMaxStreamsForTest);
-    config_.SetMaxIncomingDynamicStreamsToSend(kMaxStreamsForTest);
-    QuicConfigPeer::SetReceivedMaxIncomingDynamicStreams(&config_,
-                                                         kMaxStreamsForTest);
-    config_.SetInitialStreamFlowControlWindowToSend(
-        kInitialStreamFlowControlWindowForTest);
-    config_.SetInitialSessionFlowControlWindowToSend(
-        kInitialSessionFlowControlWindowForTest);
-
-    connection_ = new StrictMock<MockQuicConnectionWithSendStreamData>(
-        &helper_, &alarm_factory_, Perspective::IS_SERVER,
-        SupportedVersions(GetParam()));
-    session_.reset(new QuicSimpleServerSession(
-        config_, connection_, &owner_, &session_helper_, &crypto_config_,
-        &compressed_certs_cache_));
-    MockClock clock;
-    handshake_message_.reset(crypto_config_.AddDefaultConfig(
-        QuicRandom::GetInstance(), &clock,
-        QuicCryptoServerConfig::ConfigOptions()));
-    session_->Initialize();
-    visitor_ = QuicConnectionPeer::GetVisitor(connection_);
-    headers_stream_ = new MockQuicHeadersStream(session_.get());
-    QuicSpdySessionPeer::SetHeadersStream(session_.get(), headers_stream_);
-    // TODO(jri): Remove this line once tests pass.
-    FLAGS_quic_cede_correctly = false;
-
-    session_->OnConfigNegotiated();
-  }
-
-  StrictMock<MockQuicServerSessionVisitor> owner_;
-  StrictMock<MockQuicServerSessionHelper> session_helper_;
-  MockQuicConnectionHelper helper_;
-  MockAlarmFactory alarm_factory_;
-  StrictMock<MockQuicConnectionWithSendStreamData>* connection_;
-  QuicConfig config_;
-  QuicCryptoServerConfig crypto_config_;
-  QuicCompressedCertsCache compressed_certs_cache_;
-  std::unique_ptr<QuicSimpleServerSession> session_;
-  std::unique_ptr<CryptoHandshakeMessage> handshake_message_;
-  QuicConnectionVisitorInterface* visitor_;
-  MockQuicHeadersStream* headers_stream_;
-};
-
-INSTANTIATE_TEST_CASE_P(Tests,
-                        QuicSimpleServerSessionTest,
-                        ::testing::ValuesIn(QuicSupportedVersions()));
-
-TEST_P(QuicSimpleServerSessionTest, CloseStreamDueToReset) {
-  // Open a stream, then reset it.
-  // Send two bytes of payload to open it.
-  QuicStreamFrame data1(kClientDataStreamId1, false, 0, StringPiece("HT"));
-  session_->OnStreamFrame(data1);
-  EXPECT_EQ(1u, session_->GetNumOpenIncomingStreams());
-
-  // Receive a reset (and send a RST in response).
-  QuicRstStreamFrame rst1(kClientDataStreamId1, QUIC_ERROR_PROCESSING_STREAM,
-                          0);
-  EXPECT_CALL(*connection_,
-              SendRstStream(kClientDataStreamId1, QUIC_RST_ACKNOWLEDGEMENT, 0));
-  visitor_->OnRstStream(rst1);
-  EXPECT_EQ(0u, session_->GetNumOpenIncomingStreams());
-
-  // Send the same two bytes of payload in a new packet.
-  visitor_->OnStreamFrame(data1);
-
-  // The stream should not be re-opened.
-  EXPECT_EQ(0u, session_->GetNumOpenIncomingStreams());
-  EXPECT_TRUE(connection_->connected());
-}
-
-TEST_P(QuicSimpleServerSessionTest, NeverOpenStreamDueToReset) {
-  // Send a reset (and expect the peer to send a RST in response).
-  QuicRstStreamFrame rst1(kClientDataStreamId1, QUIC_ERROR_PROCESSING_STREAM,
-                          0);
-  EXPECT_CALL(*connection_,
-              SendRstStream(kClientDataStreamId1, QUIC_RST_ACKNOWLEDGEMENT, 0));
-  visitor_->OnRstStream(rst1);
-  EXPECT_EQ(0u, session_->GetNumOpenIncomingStreams());
-
-  // Send two bytes of payload.
-  QuicStreamFrame data1(kClientDataStreamId1, false, 0, StringPiece("HT"));
-  visitor_->OnStreamFrame(data1);
-
-  // The stream should never be opened, now that the reset is received.
-  EXPECT_EQ(0u, session_->GetNumOpenIncomingStreams());
-  EXPECT_TRUE(connection_->connected());
-}
-
-TEST_P(QuicSimpleServerSessionTest, AcceptClosedStream) {
-  // Send (empty) compressed headers followed by two bytes of data.
-  QuicStreamFrame frame1(kClientDataStreamId1, false, 0,
-                         StringPiece("\1\0\0\0\0\0\0\0HT"));
-  QuicStreamFrame frame2(kClientDataStreamId2, false, 0,
-                         StringPiece("\2\0\0\0\0\0\0\0HT"));
-  visitor_->OnStreamFrame(frame1);
-  visitor_->OnStreamFrame(frame2);
-  EXPECT_EQ(2u, session_->GetNumOpenIncomingStreams());
-
-  // Send a reset (and expect the peer to send a RST in response).
-  QuicRstStreamFrame rst(kClientDataStreamId1, QUIC_ERROR_PROCESSING_STREAM, 0);
-  EXPECT_CALL(*connection_,
-              SendRstStream(kClientDataStreamId1, QUIC_RST_ACKNOWLEDGEMENT, 0));
-  visitor_->OnRstStream(rst);
-
-  // If we were tracking, we'd probably want to reject this because it's data
-  // past the reset point of stream 3.  As it's a closed stream we just drop the
-  // data on the floor, but accept the packet because it has data for stream 5.
-  QuicStreamFrame frame3(kClientDataStreamId1, false, 2, StringPiece("TP"));
-  QuicStreamFrame frame4(kClientDataStreamId2, false, 2, StringPiece("TP"));
-  visitor_->OnStreamFrame(frame3);
-  visitor_->OnStreamFrame(frame4);
-  // The stream should never be opened, now that the reset is received.
-  EXPECT_EQ(1u, session_->GetNumOpenIncomingStreams());
-  EXPECT_TRUE(connection_->connected());
-}
-
-TEST_P(QuicSimpleServerSessionTest, CreateIncomingDynamicStreamDisconnected) {
-  // Tests that incoming stream creation fails when connection is not connected.
-  size_t initial_num_open_stream = session_->GetNumOpenIncomingStreams();
-  QuicConnectionPeer::TearDownLocalConnectionState(connection_);
-  EXPECT_DFATAL(QuicSimpleServerSessionPeer::CreateIncomingDynamicStream(
-                    session_.get(), kClientDataStreamId1),
-                "ShouldCreateIncomingDynamicStream called when disconnected");
-  EXPECT_EQ(initial_num_open_stream, session_->GetNumOpenIncomingStreams());
-}
-
-TEST_P(QuicSimpleServerSessionTest, CreateEvenIncomingDynamicStream) {
-  // Tests that incoming stream creation fails when given stream id is even.
-  size_t initial_num_open_stream = session_->GetNumOpenIncomingStreams();
-  EXPECT_CALL(*connection_,
-              CloseConnection(QUIC_INVALID_STREAM_ID,
-                              "Client created even numbered stream", _));
-  QuicSimpleServerSessionPeer::CreateIncomingDynamicStream(session_.get(), 2);
-  EXPECT_EQ(initial_num_open_stream, session_->GetNumOpenIncomingStreams());
-}
-
-TEST_P(QuicSimpleServerSessionTest, CreateIncomingDynamicStream) {
-  QuicSpdyStream* stream =
-      QuicSimpleServerSessionPeer::CreateIncomingDynamicStream(
-          session_.get(), kClientDataStreamId1);
-  EXPECT_NE(nullptr, stream);
-  EXPECT_EQ(kClientDataStreamId1, stream->id());
-}
-
-TEST_P(QuicSimpleServerSessionTest, CreateOutgoingDynamicStreamDisconnected) {
-  // Tests that outgoing stream creation fails when connection is not connected.
-  size_t initial_num_open_stream = session_->GetNumOpenOutgoingStreams();
-  QuicConnectionPeer::TearDownLocalConnectionState(connection_);
-  EXPECT_DFATAL(QuicSimpleServerSessionPeer::CreateOutgoingDynamicStream(
-                    session_.get(), kDefaultPriority),
-                "ShouldCreateOutgoingDynamicStream called when disconnected");
-
-  EXPECT_EQ(initial_num_open_stream, session_->GetNumOpenOutgoingStreams());
-}
-
-TEST_P(QuicSimpleServerSessionTest, CreateOutgoingDynamicStreamUnencrypted) {
-  // Tests that outgoing stream creation fails when encryption has not yet been
-  // established.
-  size_t initial_num_open_stream = session_->GetNumOpenOutgoingStreams();
-  EXPECT_DFATAL(QuicSimpleServerSessionPeer::CreateOutgoingDynamicStream(
-                    session_.get(), kDefaultPriority),
-                "Encryption not established so no outgoing stream created.");
-  EXPECT_EQ(initial_num_open_stream, session_->GetNumOpenOutgoingStreams());
-}
-
-TEST_P(QuicSimpleServerSessionTest, CreateOutgoingDynamicStreamUptoLimit) {
-  // Tests that outgoing stream creation should not be affected by existing
-  // incoming stream and vice-versa. But when reaching the limit of max outgoing
-  // stream allowed, creation should fail.
-
-  // Receive some data to initiate a incoming stream which should not effect
-  // creating outgoing streams.
-  QuicStreamFrame data1(kClientDataStreamId1, false, 0, StringPiece("HT"));
-  session_->OnStreamFrame(data1);
-  EXPECT_EQ(1u, session_->GetNumOpenIncomingStreams());
-  EXPECT_EQ(0u, session_->GetNumOpenOutgoingStreams());
-
-  // Assume encryption already established.
-  MockQuicCryptoServerStream* crypto_stream = new MockQuicCryptoServerStream(
-      &crypto_config_, &compressed_certs_cache_, session_.get());
-  crypto_stream->set_encryption_established(true);
-  QuicSimpleServerSessionPeer::SetCryptoStream(session_.get(), crypto_stream);
-
-  // Create push streams till reaching the upper limit of allowed open streams.
-  for (size_t i = 0; i < kMaxStreamsForTest; ++i) {
-    QuicSpdyStream* created_stream =
-        QuicSimpleServerSessionPeer::CreateOutgoingDynamicStream(
-            session_.get(), kDefaultPriority);
-    EXPECT_EQ(2 * (i + 1), created_stream->id());
-    EXPECT_EQ(i + 1, session_->GetNumOpenOutgoingStreams());
-  }
-
-  // Continuing creating push stream would fail.
-  EXPECT_EQ(nullptr, QuicSimpleServerSessionPeer::CreateOutgoingDynamicStream(
-                         session_.get(), kDefaultPriority));
-  EXPECT_EQ(kMaxStreamsForTest, session_->GetNumOpenOutgoingStreams());
-
-  // Create peer initiated stream should have no problem.
-  QuicStreamFrame data2(kClientDataStreamId2, false, 0, StringPiece("HT"));
-  session_->OnStreamFrame(data2);
-  EXPECT_EQ(2u, session_->GetNumOpenIncomingStreams());
-}
-
-TEST_P(QuicSimpleServerSessionTest, OnStreamFrameWithEvenStreamId) {
-  QuicStreamFrame frame(2, false, 0, StringPiece());
-  EXPECT_CALL(*connection_,
-              CloseConnection(QUIC_INVALID_STREAM_ID,
-                              "Client sent data on server push stream", _));
-  session_->OnStreamFrame(frame);
-}
-
-TEST_P(QuicSimpleServerSessionTest, GetEvenIncomingError) {
-  // Tests that calling GetOrCreateDynamicStream() on an outgoing stream not
-  // promised yet should result close connection.
-  EXPECT_CALL(*connection_, CloseConnection(QUIC_INVALID_STREAM_ID,
-                                            "Data for nonexistent stream", _));
-  EXPECT_EQ(nullptr,
-            QuicSessionPeer::GetOrCreateDynamicStream(session_.get(), 4));
-}
-
-// In order to test the case where server push stream creation goes beyond
-// limit, server push streams need to be hanging there instead of
-// immediately closing after sending back response.
-// To achieve this goal, this class resets flow control windows so that large
-// responses will not be sent fully in order to prevent push streams from being
-// closed immediately.
-// Also adjust connection-level flow control window to ensure a large response
-// can cause stream-level flow control blocked but not connection-level.
-class QuicSimpleServerSessionServerPushTest
-    : public QuicSimpleServerSessionTest {
- protected:
-  const size_t kStreamFlowControlWindowSize = 32 * 1024;  // 32KB.
-
-  QuicSimpleServerSessionServerPushTest() : QuicSimpleServerSessionTest() {
-    config_.SetMaxStreamsPerConnection(kMaxStreamsForTest, kMaxStreamsForTest);
-
-    // Reset stream level flow control window to be 32KB.
-    QuicConfigPeer::SetReceivedInitialStreamFlowControlWindow(
-        &config_, kStreamFlowControlWindowSize);
-    // Reset connection level flow control window to be 1.5 MB which is large
-    // enough that it won't block any stream to write before stream level flow
-    // control blocks it.
-    QuicConfigPeer::SetReceivedInitialSessionFlowControlWindow(
-        &config_, kInitialSessionFlowControlWindowForTest);
-    // Enable server push.
-    QuicTagVector copt;
-    copt.push_back(kSPSH);
-    QuicConfigPeer::SetReceivedConnectionOptions(&config_, copt);
-
-    connection_ = new StrictMock<MockQuicConnectionWithSendStreamData>(
-        &helper_, &alarm_factory_, Perspective::IS_SERVER,
-        SupportedVersions(GetParam()));
-    session_.reset(new QuicSimpleServerSession(
-        config_, connection_, &owner_, &session_helper_, &crypto_config_,
-        &compressed_certs_cache_));
-    session_->Initialize();
-    // Needed to make new session flow control window and server push work.
-    session_->OnConfigNegotiated();
-
-    visitor_ = QuicConnectionPeer::GetVisitor(connection_);
-    headers_stream_ = new MockQuicHeadersStream(session_.get());
-    QuicSpdySessionPeer::SetHeadersStream(session_.get(), headers_stream_);
-
-    // Assume encryption already established.
-    MockQuicCryptoServerStream* crypto_stream = new MockQuicCryptoServerStream(
-        &crypto_config_, &compressed_certs_cache_, session_.get());
-    crypto_stream->set_encryption_established(true);
-    QuicSimpleServerSessionPeer::SetCryptoStream(session_.get(), crypto_stream);
-  }
-
-  // Given |num_resources|, create this number of fake push resources and push
-  // them by sending PUSH_PROMISE for all and sending push responses for as much
-  // as possible(limited by kMaxStreamsForTest).
-  // If |num_resources| > kMaxStreamsForTest, the left over will be queued.
-  void PromisePushResources(size_t num_resources) {
-    // To prevent push streams from being closed the response need to be larger
-    // than stream flow control window so stream won't send the full body.
-    size_t body_size = 2 * kStreamFlowControlWindowSize;  // 64KB.
-
-    config_.SetMaxStreamsPerConnection(kMaxStreamsForTest, kMaxStreamsForTest);
-
-    QuicInMemoryCachePeer::ResetForTests();
-
-    string request_url = "mail.google.com/";
-    SpdyHeaderBlock request_headers;
-    string resource_host = "www.google.com";
-    string partial_push_resource_path = "/server_push_src";
-    std::list<QuicInMemoryCache::ServerPushInfo> push_resources;
-    string scheme = "http";
-    for (unsigned int i = 1; i <= num_resources; ++i) {
-      QuicStreamId stream_id = i * 2;
-      string path = partial_push_resource_path + base::UintToString(i);
-      string url = scheme + "://" + resource_host + path;
-      GURL resource_url = GURL(url);
-      string body;
-      GenerateBody(&body, body_size);
-      QuicInMemoryCache::GetInstance()->AddSimpleResponse(resource_host, path,
-                                                          200, body);
-      push_resources.push_back(QuicInMemoryCache::ServerPushInfo(
-          resource_url, SpdyHeaderBlock(), kDefaultPriority, body));
-      // PUSH_PROMISED are sent for all the resources.
-      EXPECT_CALL(
-          *headers_stream_,
-          WritePushPromiseMock(kClientDataStreamId1, stream_id, _, nullptr));
-      if (i <= kMaxStreamsForTest) {
-        // |kMaxStreamsForTest| promised responses should be sent.
-        EXPECT_CALL(
-            *headers_stream_,
-            WriteHeadersMock(stream_id, _, false, kDefaultPriority, nullptr));
-        // Since flow control window is smaller than response body, not the
-        // whole body will be sent.
-        if (!session_->force_hol_blocking()) {
-          EXPECT_CALL(*connection_,
-                      SendStreamData(stream_id, _, 0, false, nullptr))
-              .WillOnce(Return(
-                  QuicConsumedData(kStreamFlowControlWindowSize, false)));
-          EXPECT_CALL(*connection_, SendBlocked(stream_id));
-        } else {
-          // The forced HOL blocking encapsulates the stream data into
-          // HTTP/2 DATA frames within the headers stream.  HTTP/2
-          // DATA frames are limited to a max size of 16KB, so the
-          // 64KB body will be fragemented into four DATA frames.
-          EXPECT_CALL(*connection_, SendStreamData(_, _, _, false, nullptr))
-              .Times(body_size / 16384)
-              .WillOnce(Return(QuicConsumedData(9 + 16394, false)))
-              .WillOnce(Return(QuicConsumedData(9 + 16394, false)))
-              .WillOnce(Return(QuicConsumedData(9 + 16394, false)))
-              .WillOnce(Return(QuicConsumedData(9 + 16394, false)));
-          EXPECT_CALL(*connection_, SendBlocked(_));
-        }
-      }
-    }
-    session_->PromisePushResources(request_url, push_resources,
-                                   kClientDataStreamId1, request_headers);
-  }
-};
-
-INSTANTIATE_TEST_CASE_P(Tests,
-                        QuicSimpleServerSessionServerPushTest,
-                        ::testing::ValuesIn(QuicSupportedVersions()));
-
-TEST_P(QuicSimpleServerSessionServerPushTest, TestPromisePushResources) {
-  // Tests that given more than kMaxOpenStreamForTest resources, all their
-  // PUSH_PROMISE's will be sent out and only |kMaxOpenStreamForTest| streams
-  // will be opened and send push response.
-
-  if (session_->force_hol_blocking()) {
-    return;
-  }
-  size_t num_resources = kMaxStreamsForTest + 5;
-  PromisePushResources(num_resources);
-  EXPECT_EQ(kMaxStreamsForTest, session_->GetNumOpenOutgoingStreams());
-}
-
-TEST_P(QuicSimpleServerSessionServerPushTest,
-       HandlePromisedPushRequestsAfterStreamDraining) {
-  if (session_->force_hol_blocking()) {
-    return;
-  }
-
-  // Tests that after promised stream queued up, when an opened stream is marked
-  // draining, a queued promised stream will become open and send push response.
-  size_t num_resources = kMaxStreamsForTest + 1;
-  PromisePushResources(num_resources);
-  QuicStreamId next_out_going_stream_id = num_resources * 2;
-
-  // After an open stream is marked draining, a new stream is expected to be
-  // created and a response sent on the stream.
-  EXPECT_CALL(*headers_stream_,
-              WriteHeadersMock(next_out_going_stream_id, _, false,
-                               kDefaultPriority, nullptr));
-  EXPECT_CALL(*connection_,
-              SendStreamData(next_out_going_stream_id, _, 0, false, nullptr))
-      .WillOnce(Return(QuicConsumedData(kStreamFlowControlWindowSize, false)));
-  EXPECT_CALL(*connection_, SendBlocked(next_out_going_stream_id));
-  session_->StreamDraining(2);
-  // Number of open outgoing streams should still be the same, because a new
-  // stream is opened. And the queue should be empty.
-  EXPECT_EQ(kMaxStreamsForTest, session_->GetNumOpenOutgoingStreams());
-}
-
-TEST_P(QuicSimpleServerSessionServerPushTest,
-       ResetPromisedStreamToCancelServerPush) {
-  if (session_->force_hol_blocking()) {
-    return;
-  }
-  // Tests that after all resources are promised, a RST frame from client can
-  // prevent a promised resource to be send out.
-
-  // Having two extra resources to be send later. One of them will be reset, so
-  // when opened stream become close, only one will become open.
-  size_t num_resources = kMaxStreamsForTest + 2;
-  PromisePushResources(num_resources);
-
-  // Reset the last stream in the queue. It should be marked cancelled.
-  QuicStreamId stream_got_reset = num_resources * 2;
-  QuicRstStreamFrame rst(stream_got_reset, QUIC_STREAM_CANCELLED, 0);
-  EXPECT_CALL(*connection_,
-              SendRstStream(stream_got_reset, QUIC_RST_ACKNOWLEDGEMENT, 0));
-  visitor_->OnRstStream(rst);
-
-  // When the first 2 streams becomes draining, the two queued up stream could
-  // be created. But since one of them was marked cancelled due to RST frame,
-  // only one queued resource will be sent out.
-  QuicStreamId stream_not_reset = (kMaxStreamsForTest + 1) * 2;
-  InSequence s;
-  EXPECT_CALL(*headers_stream_, WriteHeadersMock(stream_not_reset, _, false,
-                                                 kDefaultPriority, nullptr));
-  EXPECT_CALL(*connection_,
-              SendStreamData(stream_not_reset, _, 0, false, nullptr))
-      .WillOnce(Return(QuicConsumedData(kStreamFlowControlWindowSize, false)));
-  EXPECT_CALL(*connection_, SendBlocked(stream_not_reset));
-  EXPECT_CALL(*headers_stream_, WriteHeadersMock(stream_got_reset, _, false,
-                                                 kDefaultPriority, nullptr))
-      .Times(0);
-
-  session_->StreamDraining(2);
-  session_->StreamDraining(4);
-}
-
-TEST_P(QuicSimpleServerSessionServerPushTest,
-       CloseStreamToHandleMorePromisedStream) {
-  if (session_->force_hol_blocking()) {
-    return;
-  }
-  // Tests that closing a open outgoing stream can trigger a promised resource
-  // in the queue to be send out.
-  size_t num_resources = kMaxStreamsForTest + 1;
-  PromisePushResources(num_resources);
-  QuicStreamId stream_to_open = num_resources * 2;
-
-  // Resetting 1st open stream will close the stream and give space for extra
-  // stream to be opened.
-  QuicStreamId stream_got_reset = 2;
-  EXPECT_CALL(*connection_,
-              SendRstStream(stream_got_reset, QUIC_RST_ACKNOWLEDGEMENT, _));
-  EXPECT_CALL(*headers_stream_, WriteHeadersMock(stream_to_open, _, false,
-                                                 kDefaultPriority, nullptr));
-  EXPECT_CALL(*connection_,
-              SendStreamData(stream_to_open, _, 0, false, nullptr))
-      .WillOnce(Return(QuicConsumedData(kStreamFlowControlWindowSize, false)));
-
-  EXPECT_CALL(*connection_, SendBlocked(stream_to_open));
-  QuicRstStreamFrame rst(stream_got_reset, QUIC_STREAM_CANCELLED, 0);
-  visitor_->OnRstStream(rst);
-}
-
-}  // namespace
-}  // namespace test
-}  // namespace net
diff --git a/src/net/tools/quic/quic_simple_server_stream.cc b/src/net/tools/quic/quic_simple_server_stream.cc
index 89f262e..666bcab 100644
--- a/src/net/tools/quic/quic_simple_server_stream.cc
+++ b/src/net/tools/quic/quic_simple_server_stream.cc
@@ -157,6 +157,7 @@ void QuicSimpleServerStream::SendResponse() {
   // status, send error response.
   string request_url = request_headers_[":authority"].as_string() +
                        request_headers_[":path"].as_string();
+#if 0
   int response_code;
   const SpdyHeaderBlock& response_headers = response->headers();
   if (!ParseHeaderStatusCode(response_headers, &response_code)) {
@@ -184,9 +185,10 @@ void QuicSimpleServerStream::SendResponse() {
       return;
     }
   }
+#endif//sakacho
   std::list<QuicHttpResponseCache::ServerPushInfo> resources =
       response_cache_->GetServerPushResources(request_url);
-  DVLOG(1) << "Found " << resources.size() << " push resources for stream "
+  VLOG(0) << "Found " << resources.size() << " push resources for stream "
            << id();
 
   if (!resources.empty()) {
@@ -196,7 +198,7 @@ void QuicSimpleServerStream::SendResponse() {
                                   request_headers_);
   }
 
-  DVLOG(1) << "Sending response for stream " << id();
+  VLOG(0) << "Sending response for stream " << id() << ",size=" << response->body().size();
   SendHeadersAndBodyAndTrailers(response->headers().Clone(), response->body(),
                                 response->trailers().Clone());
 }
@@ -231,6 +233,9 @@ void QuicSimpleServerStream::SendHeadersAndBodyAndTrailers(
   if (!allow_bidirectional_data() && !reading_stopped()) {
     StopReading();
   }
+#if 1//add sakacho
+  response_headers[":status"] = "200";
+#endif
 
   // Send the headers, with a FIN if there's nothing else to send.
   bool send_fin = (body.empty() && response_trailers.empty());
diff --git a/src/net/tools/quic/test_tools/quic_test_client.cc.orig b/src/net/tools/quic/test_tools/quic_test_client.cc.orig
deleted file mode 100644
index 29c173b..0000000
--- a/src/net/tools/quic/test_tools/quic_test_client.cc.orig
+++ /dev/null
@@ -1,757 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "net/tools/quic/test_tools/quic_test_client.h"
-
-#include <memory>
-#include <utility>
-
-#include "base/memory/ptr_util.h"
-#include "base/time/time.h"
-#include "net/base/completion_callback.h"
-#include "net/base/net_errors.h"
-#include "net/cert/cert_verify_result.h"
-#include "net/cert/x509_certificate.h"
-#include "net/quic/core/crypto/proof_verifier.h"
-#include "net/quic/core/quic_flags.h"
-#include "net/quic/core/quic_server_id.h"
-#include "net/quic/core/quic_utils.h"
-#include "net/quic/test_tools/crypto_test_utils.h"
-#include "net/quic/test_tools/quic_connection_peer.h"
-#include "net/quic/test_tools/quic_spdy_session_peer.h"
-#include "net/quic/test_tools/quic_test_utils.h"
-#include "net/quic/test_tools/reliable_quic_stream_peer.h"
-#include "net/tools/balsa/balsa_headers.h"
-#include "net/tools/quic/quic_epoll_connection_helper.h"
-#include "net/tools/quic/quic_packet_writer_wrapper.h"
-#include "net/tools/quic/quic_spdy_client_stream.h"
-#include "net/tools/quic/spdy_balsa_utils.h"
-#include "net/tools/quic/test_tools/http_message.h"
-#include "net/tools/quic/test_tools/quic_client_peer.h"
-#include "url/gurl.h"
-
-using base::StringPiece;
-using net::QuicServerId;
-using net::test::QuicConnectionPeer;
-using net::test::QuicSpdySessionPeer;
-using net::test::ReliableQuicStreamPeer;
-using std::string;
-using std::vector;
-using testing::_;
-using testing::Invoke;
-
-namespace net {
-namespace test {
-namespace {
-
-// RecordingProofVerifier accepts any certificate chain and records the common
-// name of the leaf and then delegates the actual verfication to an actual
-// verifier. If no optional verifier is provided, then VerifyProof will return
-// success.
-class RecordingProofVerifier : public ProofVerifier {
- public:
-  explicit RecordingProofVerifier(std::unique_ptr<ProofVerifier> verifier)
-      : verifier_(std::move(verifier)) {}
-
-  // ProofVerifier interface.
-  QuicAsyncStatus VerifyProof(
-      const string& hostname,
-      const uint16_t port,
-      const string& server_config,
-      QuicVersion quic_version,
-      StringPiece chlo_hash,
-      const vector<string>& certs,
-      const string& cert_sct,
-      const string& signature,
-      const ProofVerifyContext* context,
-      string* error_details,
-      std::unique_ptr<ProofVerifyDetails>* details,
-      std::unique_ptr<ProofVerifierCallback> callback) override {
-    common_name_.clear();
-    if (certs.empty()) {
-      return QUIC_FAILURE;
-    }
-
-    // Convert certs to X509Certificate.
-    vector<StringPiece> cert_pieces(certs.size());
-    for (unsigned i = 0; i < certs.size(); i++) {
-      cert_pieces[i] = StringPiece(certs[i]);
-    }
-    // TODO(rtenneti): Fix after adding support for real certs. Currently,
-    // cert_pieces are "leaf" and "intermediate" and CreateFromDERCertChain
-    // fails to return cert from these cert_pieces.
-    //    scoped_refptr<net::X509Certificate> cert =
-    //        net::X509Certificate::CreateFromDERCertChain(cert_pieces);
-    //    if (!cert.get()) {
-    //      return QUIC_FAILURE;
-    //    }
-    //
-    //    common_name_ = cert->subject().GetDisplayName();
-    cert_sct_ = cert_sct;
-
-    if (!verifier_) {
-      return QUIC_SUCCESS;
-    }
-
-    return verifier_->VerifyProof(
-        hostname, port, server_config, quic_version, chlo_hash, certs, cert_sct,
-        signature, context, error_details, details, std::move(callback));
-  }
-
-  QuicAsyncStatus VerifyCertChain(
-      const std::string& hostname,
-      const std::vector<std::string>& certs,
-      const ProofVerifyContext* verify_context,
-      std::string* error_details,
-      std::unique_ptr<ProofVerifyDetails>* verify_details,
-      std::unique_ptr<ProofVerifierCallback> callback) override {
-    return QUIC_SUCCESS;
-  }
-
-  const string& common_name() const { return common_name_; }
-
-  const string& cert_sct() const { return cert_sct_; }
-
- private:
-  std::unique_ptr<ProofVerifier> verifier_;
-  string common_name_;
-  string cert_sct_;
-};
-
-}  // anonymous namespace
-
-BalsaHeaders* MungeHeaders(const BalsaHeaders* const_headers) {
-  StringPiece uri = const_headers->request_uri();
-  if (uri.empty()) {
-    return nullptr;
-  }
-  if (const_headers->request_method() == "CONNECT") {
-    return nullptr;
-  }
-  BalsaHeaders* headers = new BalsaHeaders;
-  headers->CopyFrom(*const_headers);
-  if (!uri.starts_with("https://") && !uri.starts_with("http://")) {
-    // If we have a relative URL, set some defaults.
-    string full_uri = "https://test.example.com";
-    full_uri.append(uri.as_string());
-    headers->SetRequestUri(full_uri);
-  }
-  return headers;
-}
-
-MockableQuicClient::MockableQuicClient(
-    IPEndPoint server_address,
-    const QuicServerId& server_id,
-    const QuicVersionVector& supported_versions,
-    EpollServer* epoll_server)
-    : MockableQuicClient(server_address,
-                         server_id,
-                         QuicConfig(),
-                         supported_versions,
-                         epoll_server) {}
-
-MockableQuicClient::MockableQuicClient(
-    IPEndPoint server_address,
-    const QuicServerId& server_id,
-    const QuicConfig& config,
-    const QuicVersionVector& supported_versions,
-    EpollServer* epoll_server)
-    : MockableQuicClient(server_address,
-                         server_id,
-                         config,
-                         supported_versions,
-                         epoll_server,
-                         nullptr) {}
-
-MockableQuicClient::MockableQuicClient(
-    IPEndPoint server_address,
-    const QuicServerId& server_id,
-    const QuicConfig& config,
-    const QuicVersionVector& supported_versions,
-    EpollServer* epoll_server,
-    std::unique_ptr<ProofVerifier> proof_verifier)
-    : QuicClient(server_address,
-                 server_id,
-                 supported_versions,
-                 config,
-                 epoll_server,
-                 base::WrapUnique(
-                     new RecordingProofVerifier(std::move(proof_verifier)))),
-      override_connection_id_(0),
-      test_writer_(nullptr) {
-  ON_CALL(*this, ProcessPacket(_, _, _))
-      .WillByDefault(Invoke(this, &MockableQuicClient::ProcessPacketBase));
-}
-
-void MockableQuicClient::ProcessPacketBase(const IPEndPoint& self_address,
-                                           const IPEndPoint& peer_address,
-                                           const QuicReceivedPacket& packet) {
-  QuicClient::ProcessPacket(self_address, peer_address, packet);
-}
-
-MockableQuicClient::~MockableQuicClient() {
-  if (connected()) {
-    Disconnect();
-  }
-}
-
-QuicPacketWriter* MockableQuicClient::CreateQuicPacketWriter() {
-  QuicPacketWriter* writer = QuicClient::CreateQuicPacketWriter();
-  if (!test_writer_) {
-    return writer;
-  }
-  test_writer_->set_writer(writer);
-  return test_writer_;
-}
-
-QuicConnectionId MockableQuicClient::GenerateNewConnectionId() {
-  return override_connection_id_ ? override_connection_id_
-                                 : QuicClient::GenerateNewConnectionId();
-}
-
-// Takes ownership of writer.
-void MockableQuicClient::UseWriter(QuicPacketWriterWrapper* writer) {
-  CHECK(test_writer_ == nullptr);
-  test_writer_ = writer;
-}
-
-void MockableQuicClient::UseConnectionId(QuicConnectionId connection_id) {
-  override_connection_id_ = connection_id;
-}
-
-QuicTestClient::QuicTestClient(IPEndPoint server_address,
-                               const string& server_hostname,
-                               const QuicVersionVector& supported_versions)
-    : QuicTestClient(server_address,
-                     server_hostname,
-                     QuicConfig(),
-                     supported_versions) {}
-
-QuicTestClient::QuicTestClient(IPEndPoint server_address,
-                               const string& server_hostname,
-                               const QuicConfig& config,
-                               const QuicVersionVector& supported_versions)
-    : client_(new MockableQuicClient(server_address,
-                                     QuicServerId(server_hostname,
-                                                  server_address.port(),
-                                                  PRIVACY_MODE_DISABLED),
-                                     config,
-                                     supported_versions,
-                                     &epoll_server_)),
-      response_complete_(false),
-      allow_bidirectional_data_(false) {
-  Initialize();
-}
-
-QuicTestClient::QuicTestClient(IPEndPoint server_address,
-                               const string& server_hostname,
-                               const QuicConfig& config,
-                               const QuicVersionVector& supported_versions,
-                               std::unique_ptr<ProofVerifier> proof_verifier)
-    : client_(new MockableQuicClient(server_address,
-                                     QuicServerId(server_hostname,
-                                                  server_address.port(),
-                                                  PRIVACY_MODE_DISABLED),
-                                     config,
-                                     supported_versions,
-                                     &epoll_server_,
-                                     std::move(proof_verifier))),
-      response_complete_(false),
-      allow_bidirectional_data_(false) {
-  Initialize();
-}
-
-QuicTestClient::QuicTestClient()
-    : response_complete_(false), allow_bidirectional_data_(false) {}
-
-QuicTestClient::~QuicTestClient() {
-  if (stream_) {
-    stream_->set_visitor(nullptr);
-  }
-  client_->Disconnect();
-}
-
-void QuicTestClient::Initialize() {
-  priority_ = 3;
-  connect_attempted_ = false;
-  auto_reconnect_ = false;
-  buffer_body_ = true;
-  num_requests_ = 0;
-  num_responses_ = 0;
-  ClearPerRequestState();
-  // As chrome will generally do this, we want it to be the default when it's
-  // not overridden.
-  if (!client_->config()->HasSetBytesForConnectionIdToSend()) {
-    client_->config()->SetBytesForConnectionIdToSend(0);
-  }
-}
-
-void QuicTestClient::SetUserAgentID(const string& user_agent_id) {
-  client_->SetUserAgentID(user_agent_id);
-}
-
-ssize_t QuicTestClient::SendRequest(const string& uri) {
-  HTTPMessage message;
-  FillInRequest(uri, &message);
-  return SendMessage(message);
-}
-
-void QuicTestClient::SendRequestsAndWaitForResponses(
-    const vector<string>& url_list) {
-  for (const string& url : url_list) {
-    SendRequest(url);
-  }
-  while (client()->WaitForEvents()) {
-  }
-  return;
-}
-
-ssize_t QuicTestClient::GetOrCreateStreamAndSendRequest(
-    const BalsaHeaders* headers,
-    StringPiece body,
-    bool fin,
-    QuicAckListenerInterface* delegate) {
-  if (headers) {
-    QuicClientPushPromiseIndex::TryHandle* handle;
-    QuicAsyncStatus rv = client()->push_promise_index()->Try(
-        SpdyBalsaUtils::RequestHeadersToSpdyHeaders(*headers), this, &handle);
-    if (rv == QUIC_SUCCESS)
-      return 1;
-    if (rv == QUIC_PENDING) {
-      // May need to retry request if asynchronous rendezvous fails.
-      auto* new_headers = new BalsaHeaders;
-      new_headers->CopyFrom(*headers);
-      push_promise_data_to_resend_.reset(
-          new TestClientDataToResend(new_headers, body, fin, this, delegate));
-      return 1;
-    }
-  }
-
-  // Maybe it's better just to overload this.  it's just that we need
-  // for the GetOrCreateStream function to call something else...which
-  // is icky and complicated, but maybe not worse than this.
-  QuicSpdyClientStream* stream = GetOrCreateStream();
-  if (stream == nullptr) {
-    return 0;
-  }
-
-  ssize_t ret = 0;
-  if (headers != nullptr) {
-    SpdyHeaderBlock spdy_headers =
-        SpdyBalsaUtils::RequestHeadersToSpdyHeaders(*headers);
-    if (headers->HasHeader("transfer-encoding")) {
-      // We have tests which rely on sending a non-standards-compliant
-      // T-E header.
-      string encoding;
-      headers->GetAllOfHeaderAsString("transfer-encoding", &encoding);
-      spdy_headers.insert(std::make_pair("transfer-encoding", encoding));
-    }
-    if (static_cast<StringPiece>(spdy_headers[":authority"]).empty()) {
-      // HTTP/2 requests should include the :authority pseudo hader.
-      spdy_headers[":authority"] = client_->server_id().host();
-    }
-    ret = stream->SendRequest(std::move(spdy_headers), body, fin);
-    ++num_requests_;
-  } else {
-    stream->WriteOrBufferBody(body.as_string(), fin, delegate);
-    ret = body.length();
-  }
-  if (FLAGS_enable_quic_stateless_reject_support) {
-    BalsaHeaders* new_headers = nullptr;
-    if (headers) {
-      new_headers = new BalsaHeaders;
-      new_headers->CopyFrom(*headers);
-    }
-    auto* data_to_resend =
-        new TestClientDataToResend(new_headers, body, fin, this, delegate);
-    client()->MaybeAddQuicDataToResend(data_to_resend);
-  }
-  return ret;
-}
-
-ssize_t QuicTestClient::SendMessage(const HTTPMessage& message) {
-  stream_ = nullptr;  // Always force creation of a stream for SendMessage.
-  // Any response we might have received for a previous request would no longer
-  // be valid.  TODO(jeffpiazza): There's probably additional client state that
-  // should be reset here, too, if we were being more careful.
-  response_complete_ = false;
-
-  // If we're not connected, try to find an sni hostname.
-  if (!connected()) {
-    GURL url(message.headers()->request_uri().as_string());
-    if (override_sni_set_) {
-      client_->set_server_id(QuicServerId(override_sni_, url.EffectiveIntPort(),
-                                          PRIVACY_MODE_DISABLED));
-    } else {
-      if (!url.host().empty()) {
-        client_->set_server_id(QuicServerId(url.host(), url.EffectiveIntPort(),
-                                            PRIVACY_MODE_DISABLED));
-      }
-    }
-  }
-
-  // TODO(rtenneti): Add support for HTTPMessage::body_chunks().
-  // CHECK(message.body_chunks().empty())
-  //      << "HTTPMessage::body_chunks not supported";
-
-  std::unique_ptr<BalsaHeaders> munged_headers(MungeHeaders(message.headers()));
-  ssize_t ret = GetOrCreateStreamAndSendRequest(
-      (munged_headers.get() ? munged_headers.get() : message.headers()),
-      message.body(), message.has_complete_message(), nullptr);
-  WaitForWriteToFlush();
-  return ret;
-}
-
-ssize_t QuicTestClient::SendData(const string& data, bool last_data) {
-  return SendData(data, last_data, nullptr);
-}
-
-ssize_t QuicTestClient::SendData(const string& data,
-                                 bool last_data,
-                                 QuicAckListenerInterface* delegate) {
-  return GetOrCreateStreamAndSendRequest(nullptr, StringPiece(data), last_data,
-                                         delegate);
-}
-
-bool QuicTestClient::response_complete() const {
-  return response_complete_;
-}
-
-int QuicTestClient::response_header_size() const {
-  return response_header_size_;
-}
-
-int64_t QuicTestClient::response_body_size() const {
-  return response_body_size_;
-}
-
-bool QuicTestClient::buffer_body() const {
-  return buffer_body_;
-}
-
-void QuicTestClient::set_buffer_body(bool buffer_body) {
-  buffer_body_ = buffer_body;
-}
-
-bool QuicTestClient::ServerInLameDuckMode() const {
-  return false;
-}
-
-const string& QuicTestClient::response_body() {
-  return response_;
-}
-
-string QuicTestClient::SendCustomSynchronousRequest(
-    const HTTPMessage& message) {
-  if (SendMessage(message) == 0) {
-    DLOG(ERROR) << "Failed the request for uri:"
-                << message.headers()->request_uri();
-    // Set the response_ explicitly.  Otherwise response_ will contain the
-    // response from the previously successful request.
-    response_ = "";
-  } else {
-    WaitForResponse();
-  }
-  return response_;
-}
-
-string QuicTestClient::SendSynchronousRequest(const string& uri) {
-  HTTPMessage message;
-  FillInRequest(uri, &message);
-  return SendCustomSynchronousRequest(message);
-}
-
-void QuicTestClient::SetStream(QuicSpdyClientStream* stream) {
-  stream_ = stream;
-  if (stream_ != nullptr) {
-    response_complete_ = false;
-    stream_->set_visitor(this);
-  }
-}
-
-QuicSpdyClientStream* QuicTestClient::GetOrCreateStream() {
-  if (!connect_attempted_ || auto_reconnect_) {
-    if (!connected()) {
-      Connect();
-    }
-    if (!connected()) {
-      return nullptr;
-    }
-  }
-  if (!stream_) {
-    SetStream(client_->CreateReliableClientStream());
-    if (stream_) {
-      stream_->SetPriority(priority_);
-      stream_->set_allow_bidirectional_data(allow_bidirectional_data_);
-    }
-  }
-
-  return stream_;
-}
-
-QuicErrorCode QuicTestClient::connection_error() {
-  return client()->connection_error();
-}
-
-MockableQuicClient* QuicTestClient::client() {
-  return client_.get();
-}
-
-const string& QuicTestClient::cert_common_name() const {
-  return reinterpret_cast<RecordingProofVerifier*>(client_->proof_verifier())
-      ->common_name();
-}
-
-const string& QuicTestClient::cert_sct() const {
-  return reinterpret_cast<RecordingProofVerifier*>(client_->proof_verifier())
-      ->cert_sct();
-}
-
-QuicTagValueMap QuicTestClient::GetServerConfig() const {
-  QuicCryptoClientConfig* config = client_->crypto_config();
-  QuicCryptoClientConfig::CachedState* state =
-      config->LookupOrCreate(client_->server_id());
-  const CryptoHandshakeMessage* handshake_msg = state->GetServerConfig();
-  if (handshake_msg != nullptr) {
-    return handshake_msg->tag_value_map();
-  } else {
-    return QuicTagValueMap();
-  }
-}
-
-bool QuicTestClient::connected() const {
-  return client_->connected();
-}
-
-void QuicTestClient::Connect() {
-  DCHECK(!connected());
-  if (!connect_attempted_) {
-    client_->Initialize();
-  }
-  client_->Connect();
-  connect_attempted_ = true;
-}
-
-void QuicTestClient::ResetConnection() {
-  Disconnect();
-  Connect();
-}
-
-void QuicTestClient::Disconnect() {
-  client_->Disconnect();
-  connect_attempted_ = false;
-}
-
-IPEndPoint QuicTestClient::local_address() const {
-  return client_->GetLatestClientAddress();
-}
-
-void QuicTestClient::ClearPerRequestState() {
-  stream_error_ = QUIC_STREAM_NO_ERROR;
-  stream_ = nullptr;
-  response_ = "";
-  response_complete_ = false;
-  response_headers_complete_ = false;
-  response_headers_.Clear();
-  bytes_read_ = 0;
-  bytes_written_ = 0;
-  response_header_size_ = 0;
-  response_body_size_ = 0;
-}
-
-bool QuicTestClient::HaveActiveStream() {
-  return push_promise_data_to_resend_.get() ||
-         (stream_ != nullptr &&
-          !client_->session()->IsClosedStream(stream_->id()));
-}
-
-void QuicTestClient::WaitUntil(int timeout_ms, std::function<bool()> trigger) {
-  int64_t timeout_us = timeout_ms * base::Time::kMicrosecondsPerMillisecond;
-  int64_t old_timeout_us = epoll_server()->timeout_in_us();
-  if (timeout_us > 0) {
-    epoll_server()->set_timeout_in_us(timeout_us);
-  }
-  const QuicClock* clock =
-      QuicConnectionPeer::GetHelper(client()->session()->connection())
-          ->GetClock();
-  QuicTime end_waiting_time =
-      clock->Now() + QuicTime::Delta::FromMicroseconds(timeout_us);
-  while (HaveActiveStream() && !(trigger && trigger()) &&
-         (timeout_us < 0 || clock->Now() < end_waiting_time)) {
-    client_->WaitForEvents();
-  }
-  if (timeout_us > 0) {
-    epoll_server()->set_timeout_in_us(old_timeout_us);
-  }
-  if (trigger && !trigger()) {
-    VLOG(1) << "Client WaitUntil returning with trigger returning false.";
-  }
-}
-
-ssize_t QuicTestClient::Send(const void* buffer, size_t size) {
-  return SendData(string(static_cast<const char*>(buffer), size), false);
-}
-
-bool QuicTestClient::response_headers_complete() const {
-  if (stream_ != nullptr) {
-    return stream_->headers_decompressed();
-  }
-  return response_headers_complete_;
-}
-
-const BalsaHeaders* QuicTestClient::response_headers() const {
-  if (stream_ != nullptr) {
-    SpdyBalsaUtils::SpdyHeadersToResponseHeaders(stream_->response_headers(),
-                                                 &response_headers_);
-    return &response_headers_;
-  } else {
-    return &response_headers_;
-  }
-}
-
-const SpdyHeaderBlock& QuicTestClient::response_trailers() const {
-  return response_trailers_;
-}
-
-int64_t QuicTestClient::response_size() const {
-  return bytes_read();
-}
-
-size_t QuicTestClient::bytes_read() const {
-  // While stream_ is available, its member functions provide more accurate
-  // information.  bytes_read_ is updated only when stream_ becomes null.
-  if (stream_) {
-    return stream_->stream_bytes_read() + stream_->header_bytes_read();
-  } else {
-    return bytes_read_;
-  }
-}
-
-size_t QuicTestClient::bytes_written() const {
-  // While stream_ is available, its member functions provide more accurate
-  // information.  bytes_written_ is updated only when stream_ becomes null.
-  if (stream_) {
-    return stream_->stream_bytes_written() + stream_->header_bytes_written();
-  } else {
-    return bytes_written_;
-  }
-}
-
-void QuicTestClient::OnClose(QuicSpdyStream* stream) {
-  if (stream != nullptr) {
-    // Always close the stream, regardless of whether it was the last stream
-    // written.
-    client()->OnClose(stream);
-    ++num_responses_;
-  }
-  if (stream_ != stream) {
-    return;
-  }
-  if (buffer_body()) {
-    // TODO(fnk): The stream still buffers the whole thing. Fix that.
-    response_ = stream_->data();
-  }
-  response_complete_ = true;
-  response_headers_complete_ = stream_->headers_decompressed();
-  SpdyBalsaUtils::SpdyHeadersToResponseHeaders(stream_->response_headers(),
-                                               &response_headers_);
-  response_trailers_ = stream_->received_trailers().Clone();
-  stream_error_ = stream_->stream_error();
-  bytes_read_ = stream_->stream_bytes_read() + stream_->header_bytes_read();
-  bytes_written_ =
-      stream_->stream_bytes_written() + stream_->header_bytes_written();
-  response_header_size_ = response_headers_.GetSizeForWriteBuffer();
-  response_body_size_ = stream_->data().size();
-  stream_ = nullptr;
-}
-
-bool QuicTestClient::CheckVary(const SpdyHeaderBlock& client_request,
-                               const SpdyHeaderBlock& promise_request,
-                               const SpdyHeaderBlock& promise_response) {
-  return true;
-}
-
-void QuicTestClient::OnRendezvousResult(QuicSpdyStream* stream) {
-  std::unique_ptr<TestClientDataToResend> data_to_resend =
-      std::move(push_promise_data_to_resend_);
-  SetStream(static_cast<QuicSpdyClientStream*>(stream));
-  if (stream) {
-    stream->OnDataAvailable();
-  } else if (data_to_resend.get()) {
-    data_to_resend->Resend();
-  }
-}
-
-void QuicTestClient::UseWriter(QuicPacketWriterWrapper* writer) {
-  client_->UseWriter(writer);
-}
-
-void QuicTestClient::UseConnectionId(QuicConnectionId connection_id) {
-  DCHECK(!connected());
-  client_->UseConnectionId(connection_id);
-}
-
-ssize_t QuicTestClient::SendAndWaitForResponse(const void* buffer,
-                                               size_t size) {
-  LOG(DFATAL) << "Not implemented";
-  return 0;
-}
-
-void QuicTestClient::Bind(IPEndPoint* local_address) {
-  DLOG(WARNING) << "Bind will be done during connect";
-}
-
-void QuicTestClient::MigrateSocket(const IPAddress& new_host) {
-  client_->MigrateSocket(new_host);
-}
-
-string QuicTestClient::SerializeMessage(const HTTPMessage& message) {
-  LOG(DFATAL) << "Not implemented";
-  return "";
-}
-
-IPAddress QuicTestClient::bind_to_address() const {
-  return client_->bind_to_address();
-}
-
-void QuicTestClient::set_bind_to_address(const IPAddress& address) {
-  client_->set_bind_to_address(address);
-}
-
-const IPEndPoint& QuicTestClient::address() const {
-  return client_->server_address();
-}
-
-size_t QuicTestClient::requests_sent() const {
-  LOG(DFATAL) << "Not implemented";
-  return 0;
-}
-
-void QuicTestClient::WaitForWriteToFlush() {
-  while (connected() && client()->session()->HasDataToWrite()) {
-    client_->WaitForEvents();
-  }
-}
-
-void QuicTestClient::TestClientDataToResend::Resend() {
-  test_client_->GetOrCreateStreamAndSendRequest(headers_, body_, fin_,
-                                                delegate_);
-  if (headers_ != nullptr) {
-    delete headers_;
-    headers_ = nullptr;
-  }
-}
-
-// static
-void QuicTestClient::FillInRequest(const string& uri, HTTPMessage* message) {
-  CHECK(message);
-  message->headers()->SetRequestVersion(
-      HTTPMessage::VersionToString(HttpConstants::HTTP_1_1));
-  message->headers()->SetRequestMethod(
-      HTTPMessage::MethodToString(HttpConstants::GET));
-  message->headers()->SetRequestUri(uri);
-}
-
-}  // namespace test
-}  // namespace net
